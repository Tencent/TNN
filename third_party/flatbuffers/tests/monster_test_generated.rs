// automatically generated by the FlatBuffers compiler, do not modify



use crate::include_test2_generated::*;
use crate::include_test1_generated::*;
use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod my_game {

  use crate::include_test2_generated::*;
  use crate::include_test1_generated::*;
  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum InParentNamespaceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct InParentNamespace<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InParentNamespace<'a> {
    type Inner = InParentNamespace<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> InParentNamespace<'a> {
    pub const fn get_fully_qualified_name() -> &'static str {
        "MyGame.InParentNamespace"
    }

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InParentNamespace { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args InParentNamespaceArgs) -> flatbuffers::WIPOffset<InParentNamespace<'bldr>> {
      let mut builder = InParentNamespaceBuilder::new(_fbb);
      builder.finish()
    }

    pub fn unpack(&self) -> InParentNamespaceT {
      InParentNamespaceT {
      }
    }
}

impl flatbuffers::Verifiable for InParentNamespace<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct InParentNamespaceArgs {
}
impl<'a> Default for InParentNamespaceArgs {
    #[inline]
    fn default() -> Self {
        InParentNamespaceArgs {
        }
    }
}
pub struct InParentNamespaceBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InParentNamespaceBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InParentNamespaceBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InParentNamespaceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<InParentNamespace<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for InParentNamespace<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("InParentNamespace");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct InParentNamespaceT {
}
impl Default for InParentNamespaceT {
  fn default() -> Self {
    Self {
    }
  }
}
impl InParentNamespaceT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<InParentNamespace<'b>> {
    InParentNamespace::create(_fbb, &InParentNamespaceArgs{
    })
  }
}
#[allow(unused_imports, dead_code)]
pub mod example_2 {

  use crate::include_test2_generated::*;
  use crate::include_test1_generated::*;
  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum MonsterOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Monster<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Monster<'a> {
    type Inner = Monster<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Monster<'a> {
    pub const fn get_fully_qualified_name() -> &'static str {
        "MyGame.Example2.Monster"
    }

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Monster { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args MonsterArgs) -> flatbuffers::WIPOffset<Monster<'bldr>> {
      let mut builder = MonsterBuilder::new(_fbb);
      builder.finish()
    }

    pub fn unpack(&self) -> MonsterT {
      MonsterT {
      }
    }
}

impl flatbuffers::Verifiable for Monster<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct MonsterArgs {
}
impl<'a> Default for MonsterArgs {
    #[inline]
    fn default() -> Self {
        MonsterArgs {
        }
    }
}
pub struct MonsterBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MonsterBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MonsterBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MonsterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Monster<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Monster<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Monster");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MonsterT {
}
impl Default for MonsterT {
  fn default() -> Self {
    Self {
    }
  }
}
impl MonsterT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Monster<'b>> {
    Monster::create(_fbb, &MonsterArgs{
    })
  }
}
}  // pub mod Example2

#[allow(unused_imports, dead_code)]
pub mod example {

  use crate::include_test2_generated::*;
  use crate::include_test1_generated::*;
  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[allow(non_upper_case_globals)]
mod bitflags_color {
  flatbuffers::bitflags::bitflags! {
    /// Composite components of Monster color.
    #[derive(Default)]
    pub struct Color: u8 {
      const Red = 1;
      /// \brief color Green
      /// Green is bit_flag with value (1u << 1)
      const Green = 2;
      /// \brief color Blue (1u << 3)
      const Blue = 8;
    }
  }
}
pub use self::bitflags_color::Color;

impl<'a> flatbuffers::Follow<'a> for Color {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    unsafe { Self::from_bits_unchecked(b) }
  }
}

impl flatbuffers::Push for Color {
    type Output = Color;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.bits()); }
    }
}

impl flatbuffers::EndianScalar for Color {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.bits());
    unsafe { Self::from_bits_unchecked(b) }
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.bits());
    unsafe { Self::from_bits_unchecked(b) }
  }
}

impl<'a> flatbuffers::Verifiable for Color {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Color {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_RACE: i8 = -1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_RACE: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RACE: [Race; 4] = [
  Race::None,
  Race::Human,
  Race::Dwarf,
  Race::Elf,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Race(pub i8);
#[allow(non_upper_case_globals)]
impl Race {
  pub const None: Self = Self(-1);
  pub const Human: Self = Self(0);
  pub const Dwarf: Self = Self(1);
  pub const Elf: Self = Self(2);

  pub const ENUM_MIN: i8 = -1;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::None,
    Self::Human,
    Self::Dwarf,
    Self::Elf,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::None => Some("None"),
      Self::Human => Some("Human"),
      Self::Dwarf => Some("Dwarf"),
      Self::Elf => Some("Elf"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for Race {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Race {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<i8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for Race {
    type Output = Race;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for Race {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = i8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = i8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Race {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Race {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ANY: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ANY: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ANY: [Any; 4] = [
  Any::NONE,
  Any::Monster,
  Any::TestSimpleTableWithEnum,
  Any::MyGame_Example2_Monster,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Any(pub u8);
#[allow(non_upper_case_globals)]
impl Any {
  pub const NONE: Self = Self(0);
  pub const Monster: Self = Self(1);
  pub const TestSimpleTableWithEnum: Self = Self(2);
  pub const MyGame_Example2_Monster: Self = Self(3);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Monster,
    Self::TestSimpleTableWithEnum,
    Self::MyGame_Example2_Monster,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Monster => Some("Monster"),
      Self::TestSimpleTableWithEnum => Some("TestSimpleTableWithEnum"),
      Self::MyGame_Example2_Monster => Some("MyGame_Example2_Monster"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for Any {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Any {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for Any {
    type Output = Any;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for Any {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Any {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Any {}
pub struct AnyUnionTableOffset {}

#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub enum AnyT {
  NONE,
  Monster(Box<MonsterT>),
  TestSimpleTableWithEnum(Box<TestSimpleTableWithEnumT>),
  MyGameExample2Monster(Box<super::example_2::MonsterT>),
}
impl Default for AnyT {
  fn default() -> Self {
    Self::NONE
  }
}
impl AnyT {
  pub fn any_type(&self) -> Any {
    match self {
      Self::NONE => Any::NONE,
      Self::Monster(_) => Any::Monster,
      Self::TestSimpleTableWithEnum(_) => Any::TestSimpleTableWithEnum,
      Self::MyGameExample2Monster(_) => Any::MyGame_Example2_Monster,
    }
  }
  pub fn pack(&self, fbb: &mut flatbuffers::FlatBufferBuilder) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    match self {
      Self::NONE => None,
      Self::Monster(v) => Some(v.pack(fbb).as_union_value()),
      Self::TestSimpleTableWithEnum(v) => Some(v.pack(fbb).as_union_value()),
      Self::MyGameExample2Monster(v) => Some(v.pack(fbb).as_union_value()),
    }
  }
  /// If the union variant matches, return the owned MonsterT, setting the union to NONE.
  pub fn take_monster(&mut self) -> Option<Box<MonsterT>> {
    if let Self::Monster(_) = self {
      let v = std::mem::replace(self, Self::NONE);
      if let Self::Monster(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the MonsterT.
  pub fn as_monster(&self) -> Option<&MonsterT> {
    if let Self::Monster(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the MonsterT.
  pub fn as_monster_mut(&mut self) -> Option<&mut MonsterT> {
    if let Self::Monster(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned TestSimpleTableWithEnumT, setting the union to NONE.
  pub fn take_test_simple_table_with_enum(&mut self) -> Option<Box<TestSimpleTableWithEnumT>> {
    if let Self::TestSimpleTableWithEnum(_) = self {
      let v = std::mem::replace(self, Self::NONE);
      if let Self::TestSimpleTableWithEnum(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the TestSimpleTableWithEnumT.
  pub fn as_test_simple_table_with_enum(&self) -> Option<&TestSimpleTableWithEnumT> {
    if let Self::TestSimpleTableWithEnum(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the TestSimpleTableWithEnumT.
  pub fn as_test_simple_table_with_enum_mut(&mut self) -> Option<&mut TestSimpleTableWithEnumT> {
    if let Self::TestSimpleTableWithEnum(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned super::example_2::MonsterT, setting the union to NONE.
  pub fn take_my_game_example_2_monster(&mut self) -> Option<Box<super::example_2::MonsterT>> {
    if let Self::MyGameExample2Monster(_) = self {
      let v = std::mem::replace(self, Self::NONE);
      if let Self::MyGameExample2Monster(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the super::example_2::MonsterT.
  pub fn as_my_game_example_2_monster(&self) -> Option<&super::example_2::MonsterT> {
    if let Self::MyGameExample2Monster(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the super::example_2::MonsterT.
  pub fn as_my_game_example_2_monster_mut(&mut self) -> Option<&mut super::example_2::MonsterT> {
    if let Self::MyGameExample2Monster(v) = self { Some(v.as_mut()) } else { None }
  }
}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ANY_UNIQUE_ALIASES: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ANY_UNIQUE_ALIASES: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ANY_UNIQUE_ALIASES: [AnyUniqueAliases; 4] = [
  AnyUniqueAliases::NONE,
  AnyUniqueAliases::M,
  AnyUniqueAliases::TS,
  AnyUniqueAliases::M2,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AnyUniqueAliases(pub u8);
#[allow(non_upper_case_globals)]
impl AnyUniqueAliases {
  pub const NONE: Self = Self(0);
  pub const M: Self = Self(1);
  pub const TS: Self = Self(2);
  pub const M2: Self = Self(3);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::M,
    Self::TS,
    Self::M2,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::M => Some("M"),
      Self::TS => Some("TS"),
      Self::M2 => Some("M2"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for AnyUniqueAliases {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AnyUniqueAliases {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for AnyUniqueAliases {
    type Output = AnyUniqueAliases;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for AnyUniqueAliases {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AnyUniqueAliases {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AnyUniqueAliases {}
pub struct AnyUniqueAliasesUnionTableOffset {}

#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub enum AnyUniqueAliasesT {
  NONE,
  M(Box<MonsterT>),
  TS(Box<TestSimpleTableWithEnumT>),
  M2(Box<super::example_2::MonsterT>),
}
impl Default for AnyUniqueAliasesT {
  fn default() -> Self {
    Self::NONE
  }
}
impl AnyUniqueAliasesT {
  pub fn any_unique_aliases_type(&self) -> AnyUniqueAliases {
    match self {
      Self::NONE => AnyUniqueAliases::NONE,
      Self::M(_) => AnyUniqueAliases::M,
      Self::TS(_) => AnyUniqueAliases::TS,
      Self::M2(_) => AnyUniqueAliases::M2,
    }
  }
  pub fn pack(&self, fbb: &mut flatbuffers::FlatBufferBuilder) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    match self {
      Self::NONE => None,
      Self::M(v) => Some(v.pack(fbb).as_union_value()),
      Self::TS(v) => Some(v.pack(fbb).as_union_value()),
      Self::M2(v) => Some(v.pack(fbb).as_union_value()),
    }
  }
  /// If the union variant matches, return the owned MonsterT, setting the union to NONE.
  pub fn take_m(&mut self) -> Option<Box<MonsterT>> {
    if let Self::M(_) = self {
      let v = std::mem::replace(self, Self::NONE);
      if let Self::M(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the MonsterT.
  pub fn as_m(&self) -> Option<&MonsterT> {
    if let Self::M(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the MonsterT.
  pub fn as_m_mut(&mut self) -> Option<&mut MonsterT> {
    if let Self::M(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned TestSimpleTableWithEnumT, setting the union to NONE.
  pub fn take_ts(&mut self) -> Option<Box<TestSimpleTableWithEnumT>> {
    if let Self::TS(_) = self {
      let v = std::mem::replace(self, Self::NONE);
      if let Self::TS(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the TestSimpleTableWithEnumT.
  pub fn as_ts(&self) -> Option<&TestSimpleTableWithEnumT> {
    if let Self::TS(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the TestSimpleTableWithEnumT.
  pub fn as_ts_mut(&mut self) -> Option<&mut TestSimpleTableWithEnumT> {
    if let Self::TS(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned super::example_2::MonsterT, setting the union to NONE.
  pub fn take_m2(&mut self) -> Option<Box<super::example_2::MonsterT>> {
    if let Self::M2(_) = self {
      let v = std::mem::replace(self, Self::NONE);
      if let Self::M2(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the super::example_2::MonsterT.
  pub fn as_m2(&self) -> Option<&super::example_2::MonsterT> {
    if let Self::M2(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the super::example_2::MonsterT.
  pub fn as_m2_mut(&mut self) -> Option<&mut super::example_2::MonsterT> {
    if let Self::M2(v) = self { Some(v.as_mut()) } else { None }
  }
}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ANY_AMBIGUOUS_ALIASES: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ANY_AMBIGUOUS_ALIASES: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ANY_AMBIGUOUS_ALIASES: [AnyAmbiguousAliases; 4] = [
  AnyAmbiguousAliases::NONE,
  AnyAmbiguousAliases::M1,
  AnyAmbiguousAliases::M2,
  AnyAmbiguousAliases::M3,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AnyAmbiguousAliases(pub u8);
#[allow(non_upper_case_globals)]
impl AnyAmbiguousAliases {
  pub const NONE: Self = Self(0);
  pub const M1: Self = Self(1);
  pub const M2: Self = Self(2);
  pub const M3: Self = Self(3);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::M1,
    Self::M2,
    Self::M3,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::M1 => Some("M1"),
      Self::M2 => Some("M2"),
      Self::M3 => Some("M3"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for AnyAmbiguousAliases {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AnyAmbiguousAliases {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for AnyAmbiguousAliases {
    type Output = AnyAmbiguousAliases;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for AnyAmbiguousAliases {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AnyAmbiguousAliases {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AnyAmbiguousAliases {}
pub struct AnyAmbiguousAliasesUnionTableOffset {}

#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub enum AnyAmbiguousAliasesT {
  NONE,
  M1(Box<MonsterT>),
  M2(Box<MonsterT>),
  M3(Box<MonsterT>),
}
impl Default for AnyAmbiguousAliasesT {
  fn default() -> Self {
    Self::NONE
  }
}
impl AnyAmbiguousAliasesT {
  pub fn any_ambiguous_aliases_type(&self) -> AnyAmbiguousAliases {
    match self {
      Self::NONE => AnyAmbiguousAliases::NONE,
      Self::M1(_) => AnyAmbiguousAliases::M1,
      Self::M2(_) => AnyAmbiguousAliases::M2,
      Self::M3(_) => AnyAmbiguousAliases::M3,
    }
  }
  pub fn pack(&self, fbb: &mut flatbuffers::FlatBufferBuilder) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    match self {
      Self::NONE => None,
      Self::M1(v) => Some(v.pack(fbb).as_union_value()),
      Self::M2(v) => Some(v.pack(fbb).as_union_value()),
      Self::M3(v) => Some(v.pack(fbb).as_union_value()),
    }
  }
  /// If the union variant matches, return the owned MonsterT, setting the union to NONE.
  pub fn take_m1(&mut self) -> Option<Box<MonsterT>> {
    if let Self::M1(_) = self {
      let v = std::mem::replace(self, Self::NONE);
      if let Self::M1(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the MonsterT.
  pub fn as_m1(&self) -> Option<&MonsterT> {
    if let Self::M1(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the MonsterT.
  pub fn as_m1_mut(&mut self) -> Option<&mut MonsterT> {
    if let Self::M1(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned MonsterT, setting the union to NONE.
  pub fn take_m2(&mut self) -> Option<Box<MonsterT>> {
    if let Self::M2(_) = self {
      let v = std::mem::replace(self, Self::NONE);
      if let Self::M2(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the MonsterT.
  pub fn as_m2(&self) -> Option<&MonsterT> {
    if let Self::M2(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the MonsterT.
  pub fn as_m2_mut(&mut self) -> Option<&mut MonsterT> {
    if let Self::M2(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned MonsterT, setting the union to NONE.
  pub fn take_m3(&mut self) -> Option<Box<MonsterT>> {
    if let Self::M3(_) = self {
      let v = std::mem::replace(self, Self::NONE);
      if let Self::M3(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the MonsterT.
  pub fn as_m3(&self) -> Option<&MonsterT> {
    if let Self::M3(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the MonsterT.
  pub fn as_m3_mut(&mut self) -> Option<&mut MonsterT> {
    if let Self::M3(v) = self { Some(v.as_mut()) } else { None }
  }
}
// struct Test, aligned to 2
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Test(pub [u8; 4]);
impl Default for Test { 
  fn default() -> Self { 
    Self([0; 4])
  }
}
impl std::fmt::Debug for Test {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    f.debug_struct("Test")
      .field("a", &self.a())
      .field("b", &self.b())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Test {}
impl flatbuffers::SafeSliceAccess for Test {}
impl<'a> flatbuffers::Follow<'a> for Test {
  type Inner = &'a Test;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Test>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Test {
  type Inner = &'a Test;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Test>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Test {
    type Output = Test;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Test as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Test {
    type Output = Test;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Test as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Test {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}
impl<'a> Test {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    a: i16,
    b: i8,
  ) -> Self {
    let mut s = Self([0; 4]);
    s.set_a(a);
    s.set_b(b);
    s
  }

    pub const fn get_fully_qualified_name() -> &'static str {
        "MyGame.Example.Test"
    }

  pub fn a(&self) -> i16 {
    let mut mem = core::mem::MaybeUninit::<i16>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<i16>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_a(&mut self, x: i16) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const i16 as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<i16>(),
      );
    }
  }

  pub fn b(&self) -> i8 {
    let mut mem = core::mem::MaybeUninit::<i8>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[2..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<i8>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_b(&mut self, x: i8) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const i8 as *const u8,
        self.0[2..].as_mut_ptr(),
        core::mem::size_of::<i8>(),
      );
    }
  }

  pub fn unpack(&self) -> TestT {
    TestT {
      a: self.a(),
      b: self.b(),
    }
  }
}

#[derive(Debug, Clone, PartialEq, Default)]
pub struct TestT {
  pub a: i16,
  pub b: i8,
}
impl TestT {
  pub fn pack(&self) -> Test {
    Test::new(
      self.a,
      self.b,
    )
  }
}

// struct Vec3, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Vec3(pub [u8; 32]);
impl Default for Vec3 { 
  fn default() -> Self { 
    Self([0; 32])
  }
}
impl std::fmt::Debug for Vec3 {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    f.debug_struct("Vec3")
      .field("x", &self.x())
      .field("y", &self.y())
      .field("z", &self.z())
      .field("test1", &self.test1())
      .field("test2", &self.test2())
      .field("test3", &self.test3())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Vec3 {}
impl flatbuffers::SafeSliceAccess for Vec3 {}
impl<'a> flatbuffers::Follow<'a> for Vec3 {
  type Inner = &'a Vec3;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Vec3>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vec3 {
  type Inner = &'a Vec3;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Vec3>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Vec3 {
    type Output = Vec3;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Vec3 as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Vec3 {
    type Output = Vec3;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Vec3 as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Vec3 {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}
impl<'a> Vec3 {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    x: f32,
    y: f32,
    z: f32,
    test1: f64,
    test2: Color,
    test3: &Test,
  ) -> Self {
    let mut s = Self([0; 32]);
    s.set_x(x);
    s.set_y(y);
    s.set_z(z);
    s.set_test1(test1);
    s.set_test2(test2);
    s.set_test3(&test3);
    s
  }

    pub const fn get_fully_qualified_name() -> &'static str {
        "MyGame.Example.Vec3"
    }

  pub fn x(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<f32>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<f32>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_x(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const f32 as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<f32>(),
      );
    }
  }

  pub fn y(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<f32>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<f32>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_y(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const f32 as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<f32>(),
      );
    }
  }

  pub fn z(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<f32>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<f32>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_z(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const f32 as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<f32>(),
      );
    }
  }

  pub fn test1(&self) -> f64 {
    let mut mem = core::mem::MaybeUninit::<f64>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[16..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<f64>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_test1(&mut self, x: f64) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const f64 as *const u8,
        self.0[16..].as_mut_ptr(),
        core::mem::size_of::<f64>(),
      );
    }
  }

  pub fn test2(&self) -> Color {
    let mut mem = core::mem::MaybeUninit::<Color>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[24..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<Color>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_test2(&mut self, x: Color) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const Color as *const u8,
        self.0[24..].as_mut_ptr(),
        core::mem::size_of::<Color>(),
      );
    }
  }

  pub fn test3(&self) -> &Test {
    unsafe { &*(self.0[26..].as_ptr() as *const Test) }
  }

  pub fn set_test3(&mut self, x: &Test) {
    self.0[26..26+4].copy_from_slice(&x.0)
  }

  pub fn unpack(&self) -> Vec3T {
    Vec3T {
      x: self.x(),
      y: self.y(),
      z: self.z(),
      test1: self.test1(),
      test2: self.test2(),
      test3: self.test3().unpack(),
    }
  }
}

#[derive(Debug, Clone, PartialEq, Default)]
pub struct Vec3T {
  pub x: f32,
  pub y: f32,
  pub z: f32,
  pub test1: f64,
  pub test2: Color,
  pub test3: TestT,
}
impl Vec3T {
  pub fn pack(&self) -> Vec3 {
    Vec3::new(
      self.x,
      self.y,
      self.z,
      self.test1,
      self.test2,
      &self.test3.pack(),
    )
  }
}

// struct Ability, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Ability(pub [u8; 8]);
impl Default for Ability { 
  fn default() -> Self { 
    Self([0; 8])
  }
}
impl std::fmt::Debug for Ability {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    f.debug_struct("Ability")
      .field("id", &self.id())
      .field("distance", &self.distance())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Ability {}
impl flatbuffers::SafeSliceAccess for Ability {}
impl<'a> flatbuffers::Follow<'a> for Ability {
  type Inner = &'a Ability;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Ability>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Ability {
  type Inner = &'a Ability;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Ability>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Ability {
    type Output = Ability;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Ability as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Ability {
    type Output = Ability;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Ability as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Ability {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}
impl<'a> Ability {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    id: u32,
    distance: u32,
  ) -> Self {
    let mut s = Self([0; 8]);
    s.set_id(id);
    s.set_distance(distance);
    s
  }

    pub const fn get_fully_qualified_name() -> &'static str {
        "MyGame.Example.Ability"
    }

  pub fn id(&self) -> u32 {
    let mut mem = core::mem::MaybeUninit::<u32>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<u32>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_id(&mut self, x: u32) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const u32 as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<u32>(),
      );
    }
  }

  #[inline]
  pub fn key_compare_less_than(&self, o: &Ability) ->  bool {
    self.id() < o.id()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: u32) ->  ::std::cmp::Ordering {
    let key = self.id();
    key.cmp(&val)
  }
  pub fn distance(&self) -> u32 {
    let mut mem = core::mem::MaybeUninit::<u32>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<u32>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_distance(&mut self, x: u32) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const u32 as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<u32>(),
      );
    }
  }

  pub fn unpack(&self) -> AbilityT {
    AbilityT {
      id: self.id(),
      distance: self.distance(),
    }
  }
}

#[derive(Debug, Clone, PartialEq, Default)]
pub struct AbilityT {
  pub id: u32,
  pub distance: u32,
}
impl AbilityT {
  pub fn pack(&self) -> Ability {
    Ability::new(
      self.id,
      self.distance,
    )
  }
}

// struct StructOfStructs, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct StructOfStructs(pub [u8; 20]);
impl Default for StructOfStructs { 
  fn default() -> Self { 
    Self([0; 20])
  }
}
impl std::fmt::Debug for StructOfStructs {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    f.debug_struct("StructOfStructs")
      .field("a", &self.a())
      .field("b", &self.b())
      .field("c", &self.c())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for StructOfStructs {}
impl flatbuffers::SafeSliceAccess for StructOfStructs {}
impl<'a> flatbuffers::Follow<'a> for StructOfStructs {
  type Inner = &'a StructOfStructs;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a StructOfStructs>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a StructOfStructs {
  type Inner = &'a StructOfStructs;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<StructOfStructs>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for StructOfStructs {
    type Output = StructOfStructs;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const StructOfStructs as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b StructOfStructs {
    type Output = StructOfStructs;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const StructOfStructs as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for StructOfStructs {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}
impl<'a> StructOfStructs {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    a: &Ability,
    b: &Test,
    c: &Ability,
  ) -> Self {
    let mut s = Self([0; 20]);
    s.set_a(&a);
    s.set_b(&b);
    s.set_c(&c);
    s
  }

    pub const fn get_fully_qualified_name() -> &'static str {
        "MyGame.Example.StructOfStructs"
    }

  pub fn a(&self) -> &Ability {
    unsafe { &*(self.0[0..].as_ptr() as *const Ability) }
  }

  pub fn set_a(&mut self, x: &Ability) {
    self.0[0..0+8].copy_from_slice(&x.0)
  }

  pub fn b(&self) -> &Test {
    unsafe { &*(self.0[8..].as_ptr() as *const Test) }
  }

  pub fn set_b(&mut self, x: &Test) {
    self.0[8..8+4].copy_from_slice(&x.0)
  }

  pub fn c(&self) -> &Ability {
    unsafe { &*(self.0[12..].as_ptr() as *const Ability) }
  }

  pub fn set_c(&mut self, x: &Ability) {
    self.0[12..12+8].copy_from_slice(&x.0)
  }

  pub fn unpack(&self) -> StructOfStructsT {
    StructOfStructsT {
      a: self.a().unpack(),
      b: self.b().unpack(),
      c: self.c().unpack(),
    }
  }
}

#[derive(Debug, Clone, PartialEq, Default)]
pub struct StructOfStructsT {
  pub a: AbilityT,
  pub b: TestT,
  pub c: AbilityT,
}
impl StructOfStructsT {
  pub fn pack(&self) -> StructOfStructs {
    StructOfStructs::new(
      &self.a.pack(),
      &self.b.pack(),
      &self.c.pack(),
    )
  }
}

pub enum TestSimpleTableWithEnumOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TestSimpleTableWithEnum<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TestSimpleTableWithEnum<'a> {
    type Inner = TestSimpleTableWithEnum<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> TestSimpleTableWithEnum<'a> {
    pub const fn get_fully_qualified_name() -> &'static str {
        "MyGame.Example.TestSimpleTableWithEnum"
    }

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TestSimpleTableWithEnum { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TestSimpleTableWithEnumArgs) -> flatbuffers::WIPOffset<TestSimpleTableWithEnum<'bldr>> {
      let mut builder = TestSimpleTableWithEnumBuilder::new(_fbb);
      builder.add_color(args.color);
      builder.finish()
    }

    pub fn unpack(&self) -> TestSimpleTableWithEnumT {
      let color = self.color();
      TestSimpleTableWithEnumT {
        color,
      }
    }
    pub const VT_COLOR: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn color(&self) -> Color {
    self._tab.get::<Color>(TestSimpleTableWithEnum::VT_COLOR, Some(Color::Green)).unwrap()
  }
}

impl flatbuffers::Verifiable for TestSimpleTableWithEnum<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Color>(&"color", Self::VT_COLOR, false)?
     .finish();
    Ok(())
  }
}
pub struct TestSimpleTableWithEnumArgs {
    pub color: Color,
}
impl<'a> Default for TestSimpleTableWithEnumArgs {
    #[inline]
    fn default() -> Self {
        TestSimpleTableWithEnumArgs {
            color: Color::Green,
        }
    }
}
pub struct TestSimpleTableWithEnumBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TestSimpleTableWithEnumBuilder<'a, 'b> {
  #[inline]
  pub fn add_color(&mut self, color: Color) {
    self.fbb_.push_slot::<Color>(TestSimpleTableWithEnum::VT_COLOR, color, Color::Green);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TestSimpleTableWithEnumBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TestSimpleTableWithEnumBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TestSimpleTableWithEnum<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for TestSimpleTableWithEnum<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("TestSimpleTableWithEnum");
      ds.field("color", &self.color());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TestSimpleTableWithEnumT {
  pub color: Color,
}
impl Default for TestSimpleTableWithEnumT {
  fn default() -> Self {
    Self {
      color: Color::Green,
    }
  }
}
impl TestSimpleTableWithEnumT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<TestSimpleTableWithEnum<'b>> {
    let color = self.color;
    TestSimpleTableWithEnum::create(_fbb, &TestSimpleTableWithEnumArgs{
      color,
    })
  }
}
pub enum StatOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Stat<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Stat<'a> {
    type Inner = Stat<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Stat<'a> {
    pub const fn get_fully_qualified_name() -> &'static str {
        "MyGame.Example.Stat"
    }

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Stat { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StatArgs<'args>) -> flatbuffers::WIPOffset<Stat<'bldr>> {
      let mut builder = StatBuilder::new(_fbb);
      builder.add_val(args.val);
      if let Some(x) = args.id { builder.add_id(x); }
      builder.add_count(args.count);
      builder.finish()
    }

    pub fn unpack(&self) -> StatT {
      let id = self.id().map(|x| {
        x.to_string()
      });
      let val = self.val();
      let count = self.count();
      StatT {
        id,
        val,
        count,
      }
    }
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_VAL: flatbuffers::VOffsetT = 6;
    pub const VT_COUNT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Stat::VT_ID, None)
  }
  #[inline]
  pub fn val(&self) -> i64 {
    self._tab.get::<i64>(Stat::VT_VAL, Some(0)).unwrap()
  }
  #[inline]
  pub fn count(&self) -> u16 {
    self._tab.get::<u16>(Stat::VT_COUNT, Some(0)).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Stat) ->  bool {
    self.count() < o.count()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: u16) ->  ::std::cmp::Ordering {
    let key = self.count();
    key.cmp(&val)
  }
}

impl flatbuffers::Verifiable for Stat<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"id", Self::VT_ID, false)?
     .visit_field::<i64>(&"val", Self::VT_VAL, false)?
     .visit_field::<u16>(&"count", Self::VT_COUNT, false)?
     .finish();
    Ok(())
  }
}
pub struct StatArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub val: i64,
    pub count: u16,
}
impl<'a> Default for StatArgs<'a> {
    #[inline]
    fn default() -> Self {
        StatArgs {
            id: None,
            val: 0,
            count: 0,
        }
    }
}
pub struct StatBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StatBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Stat::VT_ID, id);
  }
  #[inline]
  pub fn add_val(&mut self, val: i64) {
    self.fbb_.push_slot::<i64>(Stat::VT_VAL, val, 0);
  }
  #[inline]
  pub fn add_count(&mut self, count: u16) {
    self.fbb_.push_slot::<u16>(Stat::VT_COUNT, count, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StatBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StatBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Stat<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Stat<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Stat");
      ds.field("id", &self.id());
      ds.field("val", &self.val());
      ds.field("count", &self.count());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct StatT {
  pub id: Option<String>,
  pub val: i64,
  pub count: u16,
}
impl Default for StatT {
  fn default() -> Self {
    Self {
      id: None,
      val: 0,
      count: 0,
    }
  }
}
impl StatT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Stat<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let val = self.val;
    let count = self.count;
    Stat::create(_fbb, &StatArgs{
      id,
      val,
      count,
    })
  }
}
pub enum ReferrableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Referrable<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Referrable<'a> {
    type Inner = Referrable<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Referrable<'a> {
    pub const fn get_fully_qualified_name() -> &'static str {
        "MyGame.Example.Referrable"
    }

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Referrable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ReferrableArgs) -> flatbuffers::WIPOffset<Referrable<'bldr>> {
      let mut builder = ReferrableBuilder::new(_fbb);
      builder.add_id(args.id);
      builder.finish()
    }

    pub fn unpack(&self) -> ReferrableT {
      let id = self.id();
      ReferrableT {
        id,
      }
    }
    pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn id(&self) -> u64 {
    self._tab.get::<u64>(Referrable::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Referrable) ->  bool {
    self.id() < o.id()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: u64) ->  ::std::cmp::Ordering {
    let key = self.id();
    key.cmp(&val)
  }
}

impl flatbuffers::Verifiable for Referrable<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>(&"id", Self::VT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct ReferrableArgs {
    pub id: u64,
}
impl<'a> Default for ReferrableArgs {
    #[inline]
    fn default() -> Self {
        ReferrableArgs {
            id: 0,
        }
    }
}
pub struct ReferrableBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReferrableBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(Referrable::VT_ID, id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReferrableBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReferrableBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Referrable<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Referrable<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Referrable");
      ds.field("id", &self.id());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ReferrableT {
  pub id: u64,
}
impl Default for ReferrableT {
  fn default() -> Self {
    Self {
      id: 0,
    }
  }
}
impl ReferrableT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Referrable<'b>> {
    let id = self.id;
    Referrable::create(_fbb, &ReferrableArgs{
      id,
    })
  }
}
pub enum MonsterOffset {}
#[derive(Copy, Clone, PartialEq)]

/// an example documentation comment: "monster object"
pub struct Monster<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Monster<'a> {
    type Inner = Monster<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Monster<'a> {
    pub const fn get_fully_qualified_name() -> &'static str {
        "MyGame.Example.Monster"
    }

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Monster { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MonsterArgs<'args>) -> flatbuffers::WIPOffset<Monster<'bldr>> {
      let mut builder = MonsterBuilder::new(_fbb);
      builder.add_non_owning_reference(args.non_owning_reference);
      builder.add_co_owning_reference(args.co_owning_reference);
      builder.add_single_weak_reference(args.single_weak_reference);
      builder.add_testhashu64_fnv1a(args.testhashu64_fnv1a);
      builder.add_testhashs64_fnv1a(args.testhashs64_fnv1a);
      builder.add_testhashu64_fnv1(args.testhashu64_fnv1);
      builder.add_testhashs64_fnv1(args.testhashs64_fnv1);
      if let Some(x) = args.scalar_key_sorted_tables { builder.add_scalar_key_sorted_tables(x); }
      if let Some(x) = args.testrequirednestedflatbuffer { builder.add_testrequirednestedflatbuffer(x); }
      if let Some(x) = args.vector_of_enums { builder.add_vector_of_enums(x); }
      if let Some(x) = args.any_ambiguous { builder.add_any_ambiguous(x); }
      if let Some(x) = args.any_unique { builder.add_any_unique(x); }
      if let Some(x) = args.vector_of_non_owning_references { builder.add_vector_of_non_owning_references(x); }
      if let Some(x) = args.vector_of_co_owning_references { builder.add_vector_of_co_owning_references(x); }
      if let Some(x) = args.vector_of_strong_referrables { builder.add_vector_of_strong_referrables(x); }
      if let Some(x) = args.vector_of_weak_references { builder.add_vector_of_weak_references(x); }
      if let Some(x) = args.vector_of_referrables { builder.add_vector_of_referrables(x); }
      if let Some(x) = args.parent_namespace_test { builder.add_parent_namespace_test(x); }
      if let Some(x) = args.vector_of_doubles { builder.add_vector_of_doubles(x); }
      if let Some(x) = args.vector_of_longs { builder.add_vector_of_longs(x); }
      if let Some(x) = args.test5 { builder.add_test5(x); }
      if let Some(x) = args.flex { builder.add_flex(x); }
      if let Some(x) = args.testarrayofsortedstruct { builder.add_testarrayofsortedstruct(x); }
      if let Some(x) = args.testarrayofstring2 { builder.add_testarrayofstring2(x); }
      builder.add_testf3(args.testf3);
      builder.add_testf2(args.testf2);
      builder.add_testf(args.testf);
      if let Some(x) = args.testarrayofbools { builder.add_testarrayofbools(x); }
      builder.add_testhashu32_fnv1a(args.testhashu32_fnv1a);
      builder.add_testhashs32_fnv1a(args.testhashs32_fnv1a);
      builder.add_testhashu32_fnv1(args.testhashu32_fnv1);
      builder.add_testhashs32_fnv1(args.testhashs32_fnv1);
      if let Some(x) = args.testempty { builder.add_testempty(x); }
      if let Some(x) = args.testnestedflatbuffer { builder.add_testnestedflatbuffer(x); }
      if let Some(x) = args.enemy { builder.add_enemy(x); }
      if let Some(x) = args.testarrayoftables { builder.add_testarrayoftables(x); }
      if let Some(x) = args.testarrayofstring { builder.add_testarrayofstring(x); }
      if let Some(x) = args.test4 { builder.add_test4(x); }
      if let Some(x) = args.test { builder.add_test(x); }
      if let Some(x) = args.inventory { builder.add_inventory(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      if let Some(x) = args.pos { builder.add_pos(x); }
      builder.add_hp(args.hp);
      builder.add_mana(args.mana);
      builder.add_signed_enum(args.signed_enum);
      builder.add_any_ambiguous_type(args.any_ambiguous_type);
      builder.add_any_unique_type(args.any_unique_type);
      builder.add_testbool(args.testbool);
      builder.add_test_type(args.test_type);
      builder.add_color(args.color);
      builder.finish()
    }

    pub fn unpack(&self) -> MonsterT {
      let pos = self.pos().map(|x| {
        x.unpack()
      });
      let mana = self.mana();
      let hp = self.hp();
      let name = {
        let x = self.name();
        x.to_string()
      };
      let inventory = self.inventory().map(|x| {
        x.to_vec()
      });
      let color = self.color();
      let test = match self.test_type() {
        Any::NONE => AnyT::NONE,
        Any::Monster => AnyT::Monster(Box::new(
          self.test_as_monster()
              .expect("Invalid union table, expected `Any::Monster`.")
              .unpack()
        )),
        Any::TestSimpleTableWithEnum => AnyT::TestSimpleTableWithEnum(Box::new(
          self.test_as_test_simple_table_with_enum()
              .expect("Invalid union table, expected `Any::TestSimpleTableWithEnum`.")
              .unpack()
        )),
        Any::MyGame_Example2_Monster => AnyT::MyGameExample2Monster(Box::new(
          self.test_as_my_game_example_2_monster()
              .expect("Invalid union table, expected `Any::MyGame_Example2_Monster`.")
              .unpack()
        )),
        _ => AnyT::NONE,
      };
      let test4 = self.test4().map(|x| {
        x.iter().map(|t| t.unpack()).collect()
      });
      let testarrayofstring = self.testarrayofstring().map(|x| {
        x.iter().map(|s| s.to_string()).collect()
      });
      let testarrayoftables = self.testarrayoftables().map(|x| {
        x.iter().map(|t| t.unpack()).collect()
      });
      let enemy = self.enemy().map(|x| {
        Box::new(x.unpack())
      });
      let testnestedflatbuffer = self.testnestedflatbuffer().map(|x| {
        x.to_vec()
      });
      let testempty = self.testempty().map(|x| {
        Box::new(x.unpack())
      });
      let testbool = self.testbool();
      let testhashs32_fnv1 = self.testhashs32_fnv1();
      let testhashu32_fnv1 = self.testhashu32_fnv1();
      let testhashs64_fnv1 = self.testhashs64_fnv1();
      let testhashu64_fnv1 = self.testhashu64_fnv1();
      let testhashs32_fnv1a = self.testhashs32_fnv1a();
      let testhashu32_fnv1a = self.testhashu32_fnv1a();
      let testhashs64_fnv1a = self.testhashs64_fnv1a();
      let testhashu64_fnv1a = self.testhashu64_fnv1a();
      let testarrayofbools = self.testarrayofbools().map(|x| {
        x.to_vec()
      });
      let testf = self.testf();
      let testf2 = self.testf2();
      let testf3 = self.testf3();
      let testarrayofstring2 = self.testarrayofstring2().map(|x| {
        x.iter().map(|s| s.to_string()).collect()
      });
      let testarrayofsortedstruct = self.testarrayofsortedstruct().map(|x| {
        x.iter().map(|t| t.unpack()).collect()
      });
      let flex = self.flex().map(|x| {
        x.to_vec()
      });
      let test5 = self.test5().map(|x| {
        x.iter().map(|t| t.unpack()).collect()
      });
      let vector_of_longs = self.vector_of_longs().map(|x| {
        x.into_iter().collect()
      });
      let vector_of_doubles = self.vector_of_doubles().map(|x| {
        x.into_iter().collect()
      });
      let parent_namespace_test = self.parent_namespace_test().map(|x| {
        Box::new(x.unpack())
      });
      let vector_of_referrables = self.vector_of_referrables().map(|x| {
        x.iter().map(|t| t.unpack()).collect()
      });
      let single_weak_reference = self.single_weak_reference();
      let vector_of_weak_references = self.vector_of_weak_references().map(|x| {
        x.into_iter().collect()
      });
      let vector_of_strong_referrables = self.vector_of_strong_referrables().map(|x| {
        x.iter().map(|t| t.unpack()).collect()
      });
      let co_owning_reference = self.co_owning_reference();
      let vector_of_co_owning_references = self.vector_of_co_owning_references().map(|x| {
        x.into_iter().collect()
      });
      let non_owning_reference = self.non_owning_reference();
      let vector_of_non_owning_references = self.vector_of_non_owning_references().map(|x| {
        x.into_iter().collect()
      });
      let any_unique = match self.any_unique_type() {
        AnyUniqueAliases::NONE => AnyUniqueAliasesT::NONE,
        AnyUniqueAliases::M => AnyUniqueAliasesT::M(Box::new(
          self.any_unique_as_m()
              .expect("Invalid union table, expected `AnyUniqueAliases::M`.")
              .unpack()
        )),
        AnyUniqueAliases::TS => AnyUniqueAliasesT::TS(Box::new(
          self.any_unique_as_ts()
              .expect("Invalid union table, expected `AnyUniqueAliases::TS`.")
              .unpack()
        )),
        AnyUniqueAliases::M2 => AnyUniqueAliasesT::M2(Box::new(
          self.any_unique_as_m2()
              .expect("Invalid union table, expected `AnyUniqueAliases::M2`.")
              .unpack()
        )),
        _ => AnyUniqueAliasesT::NONE,
      };
      let any_ambiguous = match self.any_ambiguous_type() {
        AnyAmbiguousAliases::NONE => AnyAmbiguousAliasesT::NONE,
        AnyAmbiguousAliases::M1 => AnyAmbiguousAliasesT::M1(Box::new(
          self.any_ambiguous_as_m1()
              .expect("Invalid union table, expected `AnyAmbiguousAliases::M1`.")
              .unpack()
        )),
        AnyAmbiguousAliases::M2 => AnyAmbiguousAliasesT::M2(Box::new(
          self.any_ambiguous_as_m2()
              .expect("Invalid union table, expected `AnyAmbiguousAliases::M2`.")
              .unpack()
        )),
        AnyAmbiguousAliases::M3 => AnyAmbiguousAliasesT::M3(Box::new(
          self.any_ambiguous_as_m3()
              .expect("Invalid union table, expected `AnyAmbiguousAliases::M3`.")
              .unpack()
        )),
        _ => AnyAmbiguousAliasesT::NONE,
      };
      let vector_of_enums = self.vector_of_enums().map(|x| {
        x.into_iter().collect()
      });
      let signed_enum = self.signed_enum();
      let testrequirednestedflatbuffer = self.testrequirednestedflatbuffer().map(|x| {
        x.to_vec()
      });
      let scalar_key_sorted_tables = self.scalar_key_sorted_tables().map(|x| {
        x.iter().map(|t| t.unpack()).collect()
      });
      MonsterT {
        pos,
        mana,
        hp,
        name,
        inventory,
        color,
        test,
        test4,
        testarrayofstring,
        testarrayoftables,
        enemy,
        testnestedflatbuffer,
        testempty,
        testbool,
        testhashs32_fnv1,
        testhashu32_fnv1,
        testhashs64_fnv1,
        testhashu64_fnv1,
        testhashs32_fnv1a,
        testhashu32_fnv1a,
        testhashs64_fnv1a,
        testhashu64_fnv1a,
        testarrayofbools,
        testf,
        testf2,
        testf3,
        testarrayofstring2,
        testarrayofsortedstruct,
        flex,
        test5,
        vector_of_longs,
        vector_of_doubles,
        parent_namespace_test,
        vector_of_referrables,
        single_weak_reference,
        vector_of_weak_references,
        vector_of_strong_referrables,
        co_owning_reference,
        vector_of_co_owning_references,
        non_owning_reference,
        vector_of_non_owning_references,
        any_unique,
        any_ambiguous,
        vector_of_enums,
        signed_enum,
        testrequirednestedflatbuffer,
        scalar_key_sorted_tables,
      }
    }
    pub const VT_POS: flatbuffers::VOffsetT = 4;
    pub const VT_MANA: flatbuffers::VOffsetT = 6;
    pub const VT_HP: flatbuffers::VOffsetT = 8;
    pub const VT_NAME: flatbuffers::VOffsetT = 10;
    pub const VT_INVENTORY: flatbuffers::VOffsetT = 14;
    pub const VT_COLOR: flatbuffers::VOffsetT = 16;
    pub const VT_TEST_TYPE: flatbuffers::VOffsetT = 18;
    pub const VT_TEST: flatbuffers::VOffsetT = 20;
    pub const VT_TEST4: flatbuffers::VOffsetT = 22;
    pub const VT_TESTARRAYOFSTRING: flatbuffers::VOffsetT = 24;
    pub const VT_TESTARRAYOFTABLES: flatbuffers::VOffsetT = 26;
    pub const VT_ENEMY: flatbuffers::VOffsetT = 28;
    pub const VT_TESTNESTEDFLATBUFFER: flatbuffers::VOffsetT = 30;
    pub const VT_TESTEMPTY: flatbuffers::VOffsetT = 32;
    pub const VT_TESTBOOL: flatbuffers::VOffsetT = 34;
    pub const VT_TESTHASHS32_FNV1: flatbuffers::VOffsetT = 36;
    pub const VT_TESTHASHU32_FNV1: flatbuffers::VOffsetT = 38;
    pub const VT_TESTHASHS64_FNV1: flatbuffers::VOffsetT = 40;
    pub const VT_TESTHASHU64_FNV1: flatbuffers::VOffsetT = 42;
    pub const VT_TESTHASHS32_FNV1A: flatbuffers::VOffsetT = 44;
    pub const VT_TESTHASHU32_FNV1A: flatbuffers::VOffsetT = 46;
    pub const VT_TESTHASHS64_FNV1A: flatbuffers::VOffsetT = 48;
    pub const VT_TESTHASHU64_FNV1A: flatbuffers::VOffsetT = 50;
    pub const VT_TESTARRAYOFBOOLS: flatbuffers::VOffsetT = 52;
    pub const VT_TESTF: flatbuffers::VOffsetT = 54;
    pub const VT_TESTF2: flatbuffers::VOffsetT = 56;
    pub const VT_TESTF3: flatbuffers::VOffsetT = 58;
    pub const VT_TESTARRAYOFSTRING2: flatbuffers::VOffsetT = 60;
    pub const VT_TESTARRAYOFSORTEDSTRUCT: flatbuffers::VOffsetT = 62;
    pub const VT_FLEX: flatbuffers::VOffsetT = 64;
    pub const VT_TEST5: flatbuffers::VOffsetT = 66;
    pub const VT_VECTOR_OF_LONGS: flatbuffers::VOffsetT = 68;
    pub const VT_VECTOR_OF_DOUBLES: flatbuffers::VOffsetT = 70;
    pub const VT_PARENT_NAMESPACE_TEST: flatbuffers::VOffsetT = 72;
    pub const VT_VECTOR_OF_REFERRABLES: flatbuffers::VOffsetT = 74;
    pub const VT_SINGLE_WEAK_REFERENCE: flatbuffers::VOffsetT = 76;
    pub const VT_VECTOR_OF_WEAK_REFERENCES: flatbuffers::VOffsetT = 78;
    pub const VT_VECTOR_OF_STRONG_REFERRABLES: flatbuffers::VOffsetT = 80;
    pub const VT_CO_OWNING_REFERENCE: flatbuffers::VOffsetT = 82;
    pub const VT_VECTOR_OF_CO_OWNING_REFERENCES: flatbuffers::VOffsetT = 84;
    pub const VT_NON_OWNING_REFERENCE: flatbuffers::VOffsetT = 86;
    pub const VT_VECTOR_OF_NON_OWNING_REFERENCES: flatbuffers::VOffsetT = 88;
    pub const VT_ANY_UNIQUE_TYPE: flatbuffers::VOffsetT = 90;
    pub const VT_ANY_UNIQUE: flatbuffers::VOffsetT = 92;
    pub const VT_ANY_AMBIGUOUS_TYPE: flatbuffers::VOffsetT = 94;
    pub const VT_ANY_AMBIGUOUS: flatbuffers::VOffsetT = 96;
    pub const VT_VECTOR_OF_ENUMS: flatbuffers::VOffsetT = 98;
    pub const VT_SIGNED_ENUM: flatbuffers::VOffsetT = 100;
    pub const VT_TESTREQUIREDNESTEDFLATBUFFER: flatbuffers::VOffsetT = 102;
    pub const VT_SCALAR_KEY_SORTED_TABLES: flatbuffers::VOffsetT = 104;

  #[inline]
  pub fn pos(&self) -> Option<&'a Vec3> {
    self._tab.get::<Vec3>(Monster::VT_POS, None)
  }
  #[inline]
  pub fn mana(&self) -> i16 {
    self._tab.get::<i16>(Monster::VT_MANA, Some(150)).unwrap()
  }
  #[inline]
  pub fn hp(&self) -> i16 {
    self._tab.get::<i16>(Monster::VT_HP, Some(100)).unwrap()
  }
  #[inline]
  pub fn name(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Monster::VT_NAME, None).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Monster) ->  bool {
    self.name() < o.name()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) ->  ::std::cmp::Ordering {
    let key = self.name();
    key.cmp(&val)
  }
  #[inline]
  pub fn inventory(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Monster::VT_INVENTORY, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn color(&self) -> Color {
    self._tab.get::<Color>(Monster::VT_COLOR, Some(Color::Blue)).unwrap()
  }
  #[inline]
  pub fn test_type(&self) -> Any {
    self._tab.get::<Any>(Monster::VT_TEST_TYPE, Some(Any::NONE)).unwrap()
  }
  #[inline]
  pub fn test(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Monster::VT_TEST, None)
  }
  #[inline]
  pub fn test4(&self) -> Option<&'a [Test]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Test>>>(Monster::VT_TEST4, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn testarrayofstring(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Monster::VT_TESTARRAYOFSTRING, None)
  }
  /// an example documentation comment: this will end up in the generated code
  /// multiline too
  #[inline]
  pub fn testarrayoftables(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Monster<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Monster>>>>(Monster::VT_TESTARRAYOFTABLES, None)
  }
  #[inline]
  pub fn enemy(&self) -> Option<Monster<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Monster>>(Monster::VT_ENEMY, None)
  }
  #[inline]
  pub fn testnestedflatbuffer(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Monster::VT_TESTNESTEDFLATBUFFER, None).map(|v| v.safe_slice())
  }
  pub fn testnestedflatbuffer_nested_flatbuffer(&'a self) -> Option<Monster<'a>> {
    self.testnestedflatbuffer().map(|data| {
      use flatbuffers::Follow;
      <flatbuffers::ForwardsUOffset<Monster<'a>>>::follow(data, 0)
    })
  }
  #[inline]
  pub fn testempty(&self) -> Option<Stat<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Stat>>(Monster::VT_TESTEMPTY, None)
  }
  #[inline]
  pub fn testbool(&self) -> bool {
    self._tab.get::<bool>(Monster::VT_TESTBOOL, Some(false)).unwrap()
  }
  #[inline]
  pub fn testhashs32_fnv1(&self) -> i32 {
    self._tab.get::<i32>(Monster::VT_TESTHASHS32_FNV1, Some(0)).unwrap()
  }
  #[inline]
  pub fn testhashu32_fnv1(&self) -> u32 {
    self._tab.get::<u32>(Monster::VT_TESTHASHU32_FNV1, Some(0)).unwrap()
  }
  #[inline]
  pub fn testhashs64_fnv1(&self) -> i64 {
    self._tab.get::<i64>(Monster::VT_TESTHASHS64_FNV1, Some(0)).unwrap()
  }
  #[inline]
  pub fn testhashu64_fnv1(&self) -> u64 {
    self._tab.get::<u64>(Monster::VT_TESTHASHU64_FNV1, Some(0)).unwrap()
  }
  #[inline]
  pub fn testhashs32_fnv1a(&self) -> i32 {
    self._tab.get::<i32>(Monster::VT_TESTHASHS32_FNV1A, Some(0)).unwrap()
  }
  #[inline]
  pub fn testhashu32_fnv1a(&self) -> u32 {
    self._tab.get::<u32>(Monster::VT_TESTHASHU32_FNV1A, Some(0)).unwrap()
  }
  #[inline]
  pub fn testhashs64_fnv1a(&self) -> i64 {
    self._tab.get::<i64>(Monster::VT_TESTHASHS64_FNV1A, Some(0)).unwrap()
  }
  #[inline]
  pub fn testhashu64_fnv1a(&self) -> u64 {
    self._tab.get::<u64>(Monster::VT_TESTHASHU64_FNV1A, Some(0)).unwrap()
  }
  #[inline]
  pub fn testarrayofbools(&self) -> Option<&'a [bool]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, bool>>>(Monster::VT_TESTARRAYOFBOOLS, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn testf(&self) -> f32 {
    self._tab.get::<f32>(Monster::VT_TESTF, Some(3.14159)).unwrap()
  }
  #[inline]
  pub fn testf2(&self) -> f32 {
    self._tab.get::<f32>(Monster::VT_TESTF2, Some(3.0)).unwrap()
  }
  #[inline]
  pub fn testf3(&self) -> f32 {
    self._tab.get::<f32>(Monster::VT_TESTF3, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn testarrayofstring2(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Monster::VT_TESTARRAYOFSTRING2, None)
  }
  #[inline]
  pub fn testarrayofsortedstruct(&self) -> Option<&'a [Ability]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Ability>>>(Monster::VT_TESTARRAYOFSORTEDSTRUCT, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn flex(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Monster::VT_FLEX, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn test5(&self) -> Option<&'a [Test]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Test>>>(Monster::VT_TEST5, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn vector_of_longs(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(Monster::VT_VECTOR_OF_LONGS, None)
  }
  #[inline]
  pub fn vector_of_doubles(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Monster::VT_VECTOR_OF_DOUBLES, None)
  }
  #[inline]
  pub fn parent_namespace_test(&self) -> Option<super::InParentNamespace<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<super::InParentNamespace>>(Monster::VT_PARENT_NAMESPACE_TEST, None)
  }
  #[inline]
  pub fn vector_of_referrables(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Referrable<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Referrable>>>>(Monster::VT_VECTOR_OF_REFERRABLES, None)
  }
  #[inline]
  pub fn single_weak_reference(&self) -> u64 {
    self._tab.get::<u64>(Monster::VT_SINGLE_WEAK_REFERENCE, Some(0)).unwrap()
  }
  #[inline]
  pub fn vector_of_weak_references(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(Monster::VT_VECTOR_OF_WEAK_REFERENCES, None)
  }
  #[inline]
  pub fn vector_of_strong_referrables(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Referrable<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Referrable>>>>(Monster::VT_VECTOR_OF_STRONG_REFERRABLES, None)
  }
  #[inline]
  pub fn co_owning_reference(&self) -> u64 {
    self._tab.get::<u64>(Monster::VT_CO_OWNING_REFERENCE, Some(0)).unwrap()
  }
  #[inline]
  pub fn vector_of_co_owning_references(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(Monster::VT_VECTOR_OF_CO_OWNING_REFERENCES, None)
  }
  #[inline]
  pub fn non_owning_reference(&self) -> u64 {
    self._tab.get::<u64>(Monster::VT_NON_OWNING_REFERENCE, Some(0)).unwrap()
  }
  #[inline]
  pub fn vector_of_non_owning_references(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(Monster::VT_VECTOR_OF_NON_OWNING_REFERENCES, None)
  }
  #[inline]
  pub fn any_unique_type(&self) -> AnyUniqueAliases {
    self._tab.get::<AnyUniqueAliases>(Monster::VT_ANY_UNIQUE_TYPE, Some(AnyUniqueAliases::NONE)).unwrap()
  }
  #[inline]
  pub fn any_unique(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Monster::VT_ANY_UNIQUE, None)
  }
  #[inline]
  pub fn any_ambiguous_type(&self) -> AnyAmbiguousAliases {
    self._tab.get::<AnyAmbiguousAliases>(Monster::VT_ANY_AMBIGUOUS_TYPE, Some(AnyAmbiguousAliases::NONE)).unwrap()
  }
  #[inline]
  pub fn any_ambiguous(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Monster::VT_ANY_AMBIGUOUS, None)
  }
  #[inline]
  pub fn vector_of_enums(&self) -> Option<flatbuffers::Vector<'a, Color>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Color>>>(Monster::VT_VECTOR_OF_ENUMS, None)
  }
  #[inline]
  pub fn signed_enum(&self) -> Race {
    self._tab.get::<Race>(Monster::VT_SIGNED_ENUM, Some(Race::None)).unwrap()
  }
  #[inline]
  pub fn testrequirednestedflatbuffer(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Monster::VT_TESTREQUIREDNESTEDFLATBUFFER, None).map(|v| v.safe_slice())
  }
  pub fn testrequirednestedflatbuffer_nested_flatbuffer(&'a self) -> Option<Monster<'a>> {
    self.testrequirednestedflatbuffer().map(|data| {
      use flatbuffers::Follow;
      <flatbuffers::ForwardsUOffset<Monster<'a>>>::follow(data, 0)
    })
  }
  #[inline]
  pub fn scalar_key_sorted_tables(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Stat<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Stat>>>>(Monster::VT_SCALAR_KEY_SORTED_TABLES, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_monster(&self) -> Option<Monster<'a>> {
    if self.test_type() == Any::Monster {
      self.test().map(Monster::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_test_simple_table_with_enum(&self) -> Option<TestSimpleTableWithEnum<'a>> {
    if self.test_type() == Any::TestSimpleTableWithEnum {
      self.test().map(TestSimpleTableWithEnum::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_my_game_example_2_monster(&self) -> Option<super::example_2::Monster<'a>> {
    if self.test_type() == Any::MyGame_Example2_Monster {
      self.test().map(super::example_2::Monster::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn any_unique_as_m(&self) -> Option<Monster<'a>> {
    if self.any_unique_type() == AnyUniqueAliases::M {
      self.any_unique().map(Monster::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn any_unique_as_ts(&self) -> Option<TestSimpleTableWithEnum<'a>> {
    if self.any_unique_type() == AnyUniqueAliases::TS {
      self.any_unique().map(TestSimpleTableWithEnum::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn any_unique_as_m2(&self) -> Option<super::example_2::Monster<'a>> {
    if self.any_unique_type() == AnyUniqueAliases::M2 {
      self.any_unique().map(super::example_2::Monster::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn any_ambiguous_as_m1(&self) -> Option<Monster<'a>> {
    if self.any_ambiguous_type() == AnyAmbiguousAliases::M1 {
      self.any_ambiguous().map(Monster::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn any_ambiguous_as_m2(&self) -> Option<Monster<'a>> {
    if self.any_ambiguous_type() == AnyAmbiguousAliases::M2 {
      self.any_ambiguous().map(Monster::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn any_ambiguous_as_m3(&self) -> Option<Monster<'a>> {
    if self.any_ambiguous_type() == AnyAmbiguousAliases::M3 {
      self.any_ambiguous().map(Monster::init_from_table)
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Monster<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Vec3>(&"pos", Self::VT_POS, false)?
     .visit_field::<i16>(&"mana", Self::VT_MANA, false)?
     .visit_field::<i16>(&"hp", Self::VT_HP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"inventory", Self::VT_INVENTORY, false)?
     .visit_field::<Color>(&"color", Self::VT_COLOR, false)?
     .visit_union::<Any, _>(&"test_type", Self::VT_TEST_TYPE, &"test", Self::VT_TEST, false, |key, v, pos| {
        match key {
          Any::Monster => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Monster>>("Any::Monster", pos),
          Any::TestSimpleTableWithEnum => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TestSimpleTableWithEnum>>("Any::TestSimpleTableWithEnum", pos),
          Any::MyGame_Example2_Monster => v.verify_union_variant::<flatbuffers::ForwardsUOffset<super::example_2::Monster>>("Any::MyGame_Example2_Monster", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Test>>>(&"test4", Self::VT_TEST4, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>(&"testarrayofstring", Self::VT_TESTARRAYOFSTRING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Monster>>>>(&"testarrayoftables", Self::VT_TESTARRAYOFTABLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Monster>>(&"enemy", Self::VT_ENEMY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"testnestedflatbuffer", Self::VT_TESTNESTEDFLATBUFFER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Stat>>(&"testempty", Self::VT_TESTEMPTY, false)?
     .visit_field::<bool>(&"testbool", Self::VT_TESTBOOL, false)?
     .visit_field::<i32>(&"testhashs32_fnv1", Self::VT_TESTHASHS32_FNV1, false)?
     .visit_field::<u32>(&"testhashu32_fnv1", Self::VT_TESTHASHU32_FNV1, false)?
     .visit_field::<i64>(&"testhashs64_fnv1", Self::VT_TESTHASHS64_FNV1, false)?
     .visit_field::<u64>(&"testhashu64_fnv1", Self::VT_TESTHASHU64_FNV1, false)?
     .visit_field::<i32>(&"testhashs32_fnv1a", Self::VT_TESTHASHS32_FNV1A, false)?
     .visit_field::<u32>(&"testhashu32_fnv1a", Self::VT_TESTHASHU32_FNV1A, false)?
     .visit_field::<i64>(&"testhashs64_fnv1a", Self::VT_TESTHASHS64_FNV1A, false)?
     .visit_field::<u64>(&"testhashu64_fnv1a", Self::VT_TESTHASHU64_FNV1A, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, bool>>>(&"testarrayofbools", Self::VT_TESTARRAYOFBOOLS, false)?
     .visit_field::<f32>(&"testf", Self::VT_TESTF, false)?
     .visit_field::<f32>(&"testf2", Self::VT_TESTF2, false)?
     .visit_field::<f32>(&"testf3", Self::VT_TESTF3, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>(&"testarrayofstring2", Self::VT_TESTARRAYOFSTRING2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Ability>>>(&"testarrayofsortedstruct", Self::VT_TESTARRAYOFSORTEDSTRUCT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"flex", Self::VT_FLEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Test>>>(&"test5", Self::VT_TEST5, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>(&"vector_of_longs", Self::VT_VECTOR_OF_LONGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"vector_of_doubles", Self::VT_VECTOR_OF_DOUBLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::InParentNamespace>>(&"parent_namespace_test", Self::VT_PARENT_NAMESPACE_TEST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Referrable>>>>(&"vector_of_referrables", Self::VT_VECTOR_OF_REFERRABLES, false)?
     .visit_field::<u64>(&"single_weak_reference", Self::VT_SINGLE_WEAK_REFERENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>(&"vector_of_weak_references", Self::VT_VECTOR_OF_WEAK_REFERENCES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Referrable>>>>(&"vector_of_strong_referrables", Self::VT_VECTOR_OF_STRONG_REFERRABLES, false)?
     .visit_field::<u64>(&"co_owning_reference", Self::VT_CO_OWNING_REFERENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>(&"vector_of_co_owning_references", Self::VT_VECTOR_OF_CO_OWNING_REFERENCES, false)?
     .visit_field::<u64>(&"non_owning_reference", Self::VT_NON_OWNING_REFERENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>(&"vector_of_non_owning_references", Self::VT_VECTOR_OF_NON_OWNING_REFERENCES, false)?
     .visit_union::<AnyUniqueAliases, _>(&"any_unique_type", Self::VT_ANY_UNIQUE_TYPE, &"any_unique", Self::VT_ANY_UNIQUE, false, |key, v, pos| {
        match key {
          AnyUniqueAliases::M => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Monster>>("AnyUniqueAliases::M", pos),
          AnyUniqueAliases::TS => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TestSimpleTableWithEnum>>("AnyUniqueAliases::TS", pos),
          AnyUniqueAliases::M2 => v.verify_union_variant::<flatbuffers::ForwardsUOffset<super::example_2::Monster>>("AnyUniqueAliases::M2", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<AnyAmbiguousAliases, _>(&"any_ambiguous_type", Self::VT_ANY_AMBIGUOUS_TYPE, &"any_ambiguous", Self::VT_ANY_AMBIGUOUS, false, |key, v, pos| {
        match key {
          AnyAmbiguousAliases::M1 => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Monster>>("AnyAmbiguousAliases::M1", pos),
          AnyAmbiguousAliases::M2 => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Monster>>("AnyAmbiguousAliases::M2", pos),
          AnyAmbiguousAliases::M3 => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Monster>>("AnyAmbiguousAliases::M3", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Color>>>(&"vector_of_enums", Self::VT_VECTOR_OF_ENUMS, false)?
     .visit_field::<Race>(&"signed_enum", Self::VT_SIGNED_ENUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"testrequirednestedflatbuffer", Self::VT_TESTREQUIREDNESTEDFLATBUFFER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Stat>>>>(&"scalar_key_sorted_tables", Self::VT_SCALAR_KEY_SORTED_TABLES, false)?
     .finish();
    Ok(())
  }
}
pub struct MonsterArgs<'a> {
    pub pos: Option<&'a Vec3>,
    pub mana: i16,
    pub hp: i16,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub inventory: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub color: Color,
    pub test_type: Any,
    pub test: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub test4: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Test>>>,
    pub testarrayofstring: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub testarrayoftables: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Monster<'a>>>>>,
    pub enemy: Option<flatbuffers::WIPOffset<Monster<'a>>>,
    pub testnestedflatbuffer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub testempty: Option<flatbuffers::WIPOffset<Stat<'a>>>,
    pub testbool: bool,
    pub testhashs32_fnv1: i32,
    pub testhashu32_fnv1: u32,
    pub testhashs64_fnv1: i64,
    pub testhashu64_fnv1: u64,
    pub testhashs32_fnv1a: i32,
    pub testhashu32_fnv1a: u32,
    pub testhashs64_fnv1a: i64,
    pub testhashu64_fnv1a: u64,
    pub testarrayofbools: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, bool>>>,
    pub testf: f32,
    pub testf2: f32,
    pub testf3: f32,
    pub testarrayofstring2: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub testarrayofsortedstruct: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Ability>>>,
    pub flex: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub test5: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Test>>>,
    pub vector_of_longs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub vector_of_doubles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub parent_namespace_test: Option<flatbuffers::WIPOffset<super::InParentNamespace<'a>>>,
    pub vector_of_referrables: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Referrable<'a>>>>>,
    pub single_weak_reference: u64,
    pub vector_of_weak_references: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub vector_of_strong_referrables: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Referrable<'a>>>>>,
    pub co_owning_reference: u64,
    pub vector_of_co_owning_references: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub non_owning_reference: u64,
    pub vector_of_non_owning_references: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub any_unique_type: AnyUniqueAliases,
    pub any_unique: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub any_ambiguous_type: AnyAmbiguousAliases,
    pub any_ambiguous: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub vector_of_enums: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Color>>>,
    pub signed_enum: Race,
    pub testrequirednestedflatbuffer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub scalar_key_sorted_tables: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Stat<'a>>>>>,
}
impl<'a> Default for MonsterArgs<'a> {
    #[inline]
    fn default() -> Self {
        MonsterArgs {
            pos: None,
            mana: 150,
            hp: 100,
            name: None, // required field
            inventory: None,
            color: Color::Blue,
            test_type: Any::NONE,
            test: None,
            test4: None,
            testarrayofstring: None,
            testarrayoftables: None,
            enemy: None,
            testnestedflatbuffer: None,
            testempty: None,
            testbool: false,
            testhashs32_fnv1: 0,
            testhashu32_fnv1: 0,
            testhashs64_fnv1: 0,
            testhashu64_fnv1: 0,
            testhashs32_fnv1a: 0,
            testhashu32_fnv1a: 0,
            testhashs64_fnv1a: 0,
            testhashu64_fnv1a: 0,
            testarrayofbools: None,
            testf: 3.14159,
            testf2: 3.0,
            testf3: 0.0,
            testarrayofstring2: None,
            testarrayofsortedstruct: None,
            flex: None,
            test5: None,
            vector_of_longs: None,
            vector_of_doubles: None,
            parent_namespace_test: None,
            vector_of_referrables: None,
            single_weak_reference: 0,
            vector_of_weak_references: None,
            vector_of_strong_referrables: None,
            co_owning_reference: 0,
            vector_of_co_owning_references: None,
            non_owning_reference: 0,
            vector_of_non_owning_references: None,
            any_unique_type: AnyUniqueAliases::NONE,
            any_unique: None,
            any_ambiguous_type: AnyAmbiguousAliases::NONE,
            any_ambiguous: None,
            vector_of_enums: None,
            signed_enum: Race::None,
            testrequirednestedflatbuffer: None,
            scalar_key_sorted_tables: None,
        }
    }
}
pub struct MonsterBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MonsterBuilder<'a, 'b> {
  #[inline]
  pub fn add_pos(&mut self, pos: &Vec3) {
    self.fbb_.push_slot_always::<&Vec3>(Monster::VT_POS, pos);
  }
  #[inline]
  pub fn add_mana(&mut self, mana: i16) {
    self.fbb_.push_slot::<i16>(Monster::VT_MANA, mana, 150);
  }
  #[inline]
  pub fn add_hp(&mut self, hp: i16) {
    self.fbb_.push_slot::<i16>(Monster::VT_HP, hp, 100);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_NAME, name);
  }
  #[inline]
  pub fn add_inventory(&mut self, inventory: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_INVENTORY, inventory);
  }
  #[inline]
  pub fn add_color(&mut self, color: Color) {
    self.fbb_.push_slot::<Color>(Monster::VT_COLOR, color, Color::Blue);
  }
  #[inline]
  pub fn add_test_type(&mut self, test_type: Any) {
    self.fbb_.push_slot::<Any>(Monster::VT_TEST_TYPE, test_type, Any::NONE);
  }
  #[inline]
  pub fn add_test(&mut self, test: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TEST, test);
  }
  #[inline]
  pub fn add_test4(&mut self, test4: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Test>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TEST4, test4);
  }
  #[inline]
  pub fn add_testarrayofstring(&mut self, testarrayofstring: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TESTARRAYOFSTRING, testarrayofstring);
  }
  #[inline]
  pub fn add_testarrayoftables(&mut self, testarrayoftables: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Monster<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TESTARRAYOFTABLES, testarrayoftables);
  }
  #[inline]
  pub fn add_enemy(&mut self, enemy: flatbuffers::WIPOffset<Monster<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Monster>>(Monster::VT_ENEMY, enemy);
  }
  #[inline]
  pub fn add_testnestedflatbuffer(&mut self, testnestedflatbuffer: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TESTNESTEDFLATBUFFER, testnestedflatbuffer);
  }
  #[inline]
  pub fn add_testempty(&mut self, testempty: flatbuffers::WIPOffset<Stat<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Stat>>(Monster::VT_TESTEMPTY, testempty);
  }
  #[inline]
  pub fn add_testbool(&mut self, testbool: bool) {
    self.fbb_.push_slot::<bool>(Monster::VT_TESTBOOL, testbool, false);
  }
  #[inline]
  pub fn add_testhashs32_fnv1(&mut self, testhashs32_fnv1: i32) {
    self.fbb_.push_slot::<i32>(Monster::VT_TESTHASHS32_FNV1, testhashs32_fnv1, 0);
  }
  #[inline]
  pub fn add_testhashu32_fnv1(&mut self, testhashu32_fnv1: u32) {
    self.fbb_.push_slot::<u32>(Monster::VT_TESTHASHU32_FNV1, testhashu32_fnv1, 0);
  }
  #[inline]
  pub fn add_testhashs64_fnv1(&mut self, testhashs64_fnv1: i64) {
    self.fbb_.push_slot::<i64>(Monster::VT_TESTHASHS64_FNV1, testhashs64_fnv1, 0);
  }
  #[inline]
  pub fn add_testhashu64_fnv1(&mut self, testhashu64_fnv1: u64) {
    self.fbb_.push_slot::<u64>(Monster::VT_TESTHASHU64_FNV1, testhashu64_fnv1, 0);
  }
  #[inline]
  pub fn add_testhashs32_fnv1a(&mut self, testhashs32_fnv1a: i32) {
    self.fbb_.push_slot::<i32>(Monster::VT_TESTHASHS32_FNV1A, testhashs32_fnv1a, 0);
  }
  #[inline]
  pub fn add_testhashu32_fnv1a(&mut self, testhashu32_fnv1a: u32) {
    self.fbb_.push_slot::<u32>(Monster::VT_TESTHASHU32_FNV1A, testhashu32_fnv1a, 0);
  }
  #[inline]
  pub fn add_testhashs64_fnv1a(&mut self, testhashs64_fnv1a: i64) {
    self.fbb_.push_slot::<i64>(Monster::VT_TESTHASHS64_FNV1A, testhashs64_fnv1a, 0);
  }
  #[inline]
  pub fn add_testhashu64_fnv1a(&mut self, testhashu64_fnv1a: u64) {
    self.fbb_.push_slot::<u64>(Monster::VT_TESTHASHU64_FNV1A, testhashu64_fnv1a, 0);
  }
  #[inline]
  pub fn add_testarrayofbools(&mut self, testarrayofbools: flatbuffers::WIPOffset<flatbuffers::Vector<'b , bool>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TESTARRAYOFBOOLS, testarrayofbools);
  }
  #[inline]
  pub fn add_testf(&mut self, testf: f32) {
    self.fbb_.push_slot::<f32>(Monster::VT_TESTF, testf, 3.14159);
  }
  #[inline]
  pub fn add_testf2(&mut self, testf2: f32) {
    self.fbb_.push_slot::<f32>(Monster::VT_TESTF2, testf2, 3.0);
  }
  #[inline]
  pub fn add_testf3(&mut self, testf3: f32) {
    self.fbb_.push_slot::<f32>(Monster::VT_TESTF3, testf3, 0.0);
  }
  #[inline]
  pub fn add_testarrayofstring2(&mut self, testarrayofstring2: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TESTARRAYOFSTRING2, testarrayofstring2);
  }
  #[inline]
  pub fn add_testarrayofsortedstruct(&mut self, testarrayofsortedstruct: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Ability>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TESTARRAYOFSORTEDSTRUCT, testarrayofsortedstruct);
  }
  #[inline]
  pub fn add_flex(&mut self, flex: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_FLEX, flex);
  }
  #[inline]
  pub fn add_test5(&mut self, test5: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Test>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TEST5, test5);
  }
  #[inline]
  pub fn add_vector_of_longs(&mut self, vector_of_longs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_VECTOR_OF_LONGS, vector_of_longs);
  }
  #[inline]
  pub fn add_vector_of_doubles(&mut self, vector_of_doubles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_VECTOR_OF_DOUBLES, vector_of_doubles);
  }
  #[inline]
  pub fn add_parent_namespace_test(&mut self, parent_namespace_test: flatbuffers::WIPOffset<super::InParentNamespace<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::InParentNamespace>>(Monster::VT_PARENT_NAMESPACE_TEST, parent_namespace_test);
  }
  #[inline]
  pub fn add_vector_of_referrables(&mut self, vector_of_referrables: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Referrable<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_VECTOR_OF_REFERRABLES, vector_of_referrables);
  }
  #[inline]
  pub fn add_single_weak_reference(&mut self, single_weak_reference: u64) {
    self.fbb_.push_slot::<u64>(Monster::VT_SINGLE_WEAK_REFERENCE, single_weak_reference, 0);
  }
  #[inline]
  pub fn add_vector_of_weak_references(&mut self, vector_of_weak_references: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_VECTOR_OF_WEAK_REFERENCES, vector_of_weak_references);
  }
  #[inline]
  pub fn add_vector_of_strong_referrables(&mut self, vector_of_strong_referrables: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Referrable<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_VECTOR_OF_STRONG_REFERRABLES, vector_of_strong_referrables);
  }
  #[inline]
  pub fn add_co_owning_reference(&mut self, co_owning_reference: u64) {
    self.fbb_.push_slot::<u64>(Monster::VT_CO_OWNING_REFERENCE, co_owning_reference, 0);
  }
  #[inline]
  pub fn add_vector_of_co_owning_references(&mut self, vector_of_co_owning_references: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_VECTOR_OF_CO_OWNING_REFERENCES, vector_of_co_owning_references);
  }
  #[inline]
  pub fn add_non_owning_reference(&mut self, non_owning_reference: u64) {
    self.fbb_.push_slot::<u64>(Monster::VT_NON_OWNING_REFERENCE, non_owning_reference, 0);
  }
  #[inline]
  pub fn add_vector_of_non_owning_references(&mut self, vector_of_non_owning_references: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_VECTOR_OF_NON_OWNING_REFERENCES, vector_of_non_owning_references);
  }
  #[inline]
  pub fn add_any_unique_type(&mut self, any_unique_type: AnyUniqueAliases) {
    self.fbb_.push_slot::<AnyUniqueAliases>(Monster::VT_ANY_UNIQUE_TYPE, any_unique_type, AnyUniqueAliases::NONE);
  }
  #[inline]
  pub fn add_any_unique(&mut self, any_unique: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_ANY_UNIQUE, any_unique);
  }
  #[inline]
  pub fn add_any_ambiguous_type(&mut self, any_ambiguous_type: AnyAmbiguousAliases) {
    self.fbb_.push_slot::<AnyAmbiguousAliases>(Monster::VT_ANY_AMBIGUOUS_TYPE, any_ambiguous_type, AnyAmbiguousAliases::NONE);
  }
  #[inline]
  pub fn add_any_ambiguous(&mut self, any_ambiguous: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_ANY_AMBIGUOUS, any_ambiguous);
  }
  #[inline]
  pub fn add_vector_of_enums(&mut self, vector_of_enums: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Color>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_VECTOR_OF_ENUMS, vector_of_enums);
  }
  #[inline]
  pub fn add_signed_enum(&mut self, signed_enum: Race) {
    self.fbb_.push_slot::<Race>(Monster::VT_SIGNED_ENUM, signed_enum, Race::None);
  }
  #[inline]
  pub fn add_testrequirednestedflatbuffer(&mut self, testrequirednestedflatbuffer: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TESTREQUIREDNESTEDFLATBUFFER, testrequirednestedflatbuffer);
  }
  #[inline]
  pub fn add_scalar_key_sorted_tables(&mut self, scalar_key_sorted_tables: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Stat<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_SCALAR_KEY_SORTED_TABLES, scalar_key_sorted_tables);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MonsterBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MonsterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Monster<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Monster::VT_NAME,"name");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Monster<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Monster");
      ds.field("pos", &self.pos());
      ds.field("mana", &self.mana());
      ds.field("hp", &self.hp());
      ds.field("name", &self.name());
      ds.field("inventory", &self.inventory());
      ds.field("color", &self.color());
      ds.field("test_type", &self.test_type());
      match self.test_type() {
        Any::Monster => {
          if let Some(x) = self.test_as_monster() {
            ds.field("test", &x)
          } else {
            ds.field("test", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Any::TestSimpleTableWithEnum => {
          if let Some(x) = self.test_as_test_simple_table_with_enum() {
            ds.field("test", &x)
          } else {
            ds.field("test", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Any::MyGame_Example2_Monster => {
          if let Some(x) = self.test_as_my_game_example_2_monster() {
            ds.field("test", &x)
          } else {
            ds.field("test", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("test", &x)
        },
      };
      ds.field("test4", &self.test4());
      ds.field("testarrayofstring", &self.testarrayofstring());
      ds.field("testarrayoftables", &self.testarrayoftables());
      ds.field("enemy", &self.enemy());
      ds.field("testnestedflatbuffer", &self.testnestedflatbuffer());
      ds.field("testempty", &self.testempty());
      ds.field("testbool", &self.testbool());
      ds.field("testhashs32_fnv1", &self.testhashs32_fnv1());
      ds.field("testhashu32_fnv1", &self.testhashu32_fnv1());
      ds.field("testhashs64_fnv1", &self.testhashs64_fnv1());
      ds.field("testhashu64_fnv1", &self.testhashu64_fnv1());
      ds.field("testhashs32_fnv1a", &self.testhashs32_fnv1a());
      ds.field("testhashu32_fnv1a", &self.testhashu32_fnv1a());
      ds.field("testhashs64_fnv1a", &self.testhashs64_fnv1a());
      ds.field("testhashu64_fnv1a", &self.testhashu64_fnv1a());
      ds.field("testarrayofbools", &self.testarrayofbools());
      ds.field("testf", &self.testf());
      ds.field("testf2", &self.testf2());
      ds.field("testf3", &self.testf3());
      ds.field("testarrayofstring2", &self.testarrayofstring2());
      ds.field("testarrayofsortedstruct", &self.testarrayofsortedstruct());
      ds.field("flex", &self.flex());
      ds.field("test5", &self.test5());
      ds.field("vector_of_longs", &self.vector_of_longs());
      ds.field("vector_of_doubles", &self.vector_of_doubles());
      ds.field("parent_namespace_test", &self.parent_namespace_test());
      ds.field("vector_of_referrables", &self.vector_of_referrables());
      ds.field("single_weak_reference", &self.single_weak_reference());
      ds.field("vector_of_weak_references", &self.vector_of_weak_references());
      ds.field("vector_of_strong_referrables", &self.vector_of_strong_referrables());
      ds.field("co_owning_reference", &self.co_owning_reference());
      ds.field("vector_of_co_owning_references", &self.vector_of_co_owning_references());
      ds.field("non_owning_reference", &self.non_owning_reference());
      ds.field("vector_of_non_owning_references", &self.vector_of_non_owning_references());
      ds.field("any_unique_type", &self.any_unique_type());
      match self.any_unique_type() {
        AnyUniqueAliases::M => {
          if let Some(x) = self.any_unique_as_m() {
            ds.field("any_unique", &x)
          } else {
            ds.field("any_unique", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyUniqueAliases::TS => {
          if let Some(x) = self.any_unique_as_ts() {
            ds.field("any_unique", &x)
          } else {
            ds.field("any_unique", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyUniqueAliases::M2 => {
          if let Some(x) = self.any_unique_as_m2() {
            ds.field("any_unique", &x)
          } else {
            ds.field("any_unique", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("any_unique", &x)
        },
      };
      ds.field("any_ambiguous_type", &self.any_ambiguous_type());
      match self.any_ambiguous_type() {
        AnyAmbiguousAliases::M1 => {
          if let Some(x) = self.any_ambiguous_as_m1() {
            ds.field("any_ambiguous", &x)
          } else {
            ds.field("any_ambiguous", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyAmbiguousAliases::M2 => {
          if let Some(x) = self.any_ambiguous_as_m2() {
            ds.field("any_ambiguous", &x)
          } else {
            ds.field("any_ambiguous", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyAmbiguousAliases::M3 => {
          if let Some(x) = self.any_ambiguous_as_m3() {
            ds.field("any_ambiguous", &x)
          } else {
            ds.field("any_ambiguous", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("any_ambiguous", &x)
        },
      };
      ds.field("vector_of_enums", &self.vector_of_enums());
      ds.field("signed_enum", &self.signed_enum());
      ds.field("testrequirednestedflatbuffer", &self.testrequirednestedflatbuffer());
      ds.field("scalar_key_sorted_tables", &self.scalar_key_sorted_tables());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MonsterT {
  pub pos: Option<Vec3T>,
  pub mana: i16,
  pub hp: i16,
  pub name: String,
  pub inventory: Option<Vec<u8>>,
  pub color: Color,
  pub test: AnyT,
  pub test4: Option<Vec<TestT>>,
  pub testarrayofstring: Option<Vec<String>>,
  pub testarrayoftables: Option<Vec<MonsterT>>,
  pub enemy: Option<Box<MonsterT>>,
  pub testnestedflatbuffer: Option<Vec<u8>>,
  pub testempty: Option<Box<StatT>>,
  pub testbool: bool,
  pub testhashs32_fnv1: i32,
  pub testhashu32_fnv1: u32,
  pub testhashs64_fnv1: i64,
  pub testhashu64_fnv1: u64,
  pub testhashs32_fnv1a: i32,
  pub testhashu32_fnv1a: u32,
  pub testhashs64_fnv1a: i64,
  pub testhashu64_fnv1a: u64,
  pub testarrayofbools: Option<Vec<bool>>,
  pub testf: f32,
  pub testf2: f32,
  pub testf3: f32,
  pub testarrayofstring2: Option<Vec<String>>,
  pub testarrayofsortedstruct: Option<Vec<AbilityT>>,
  pub flex: Option<Vec<u8>>,
  pub test5: Option<Vec<TestT>>,
  pub vector_of_longs: Option<Vec<i64>>,
  pub vector_of_doubles: Option<Vec<f64>>,
  pub parent_namespace_test: Option<Box<super::InParentNamespaceT>>,
  pub vector_of_referrables: Option<Vec<ReferrableT>>,
  pub single_weak_reference: u64,
  pub vector_of_weak_references: Option<Vec<u64>>,
  pub vector_of_strong_referrables: Option<Vec<ReferrableT>>,
  pub co_owning_reference: u64,
  pub vector_of_co_owning_references: Option<Vec<u64>>,
  pub non_owning_reference: u64,
  pub vector_of_non_owning_references: Option<Vec<u64>>,
  pub any_unique: AnyUniqueAliasesT,
  pub any_ambiguous: AnyAmbiguousAliasesT,
  pub vector_of_enums: Option<Vec<Color>>,
  pub signed_enum: Race,
  pub testrequirednestedflatbuffer: Option<Vec<u8>>,
  pub scalar_key_sorted_tables: Option<Vec<StatT>>,
}
impl Default for MonsterT {
  fn default() -> Self {
    Self {
      pos: None,
      mana: 150,
      hp: 100,
      name: "".to_string(),
      inventory: None,
      color: Color::Blue,
      test: AnyT::NONE,
      test4: None,
      testarrayofstring: None,
      testarrayoftables: None,
      enemy: None,
      testnestedflatbuffer: None,
      testempty: None,
      testbool: false,
      testhashs32_fnv1: 0,
      testhashu32_fnv1: 0,
      testhashs64_fnv1: 0,
      testhashu64_fnv1: 0,
      testhashs32_fnv1a: 0,
      testhashu32_fnv1a: 0,
      testhashs64_fnv1a: 0,
      testhashu64_fnv1a: 0,
      testarrayofbools: None,
      testf: 3.14159,
      testf2: 3.0,
      testf3: 0.0,
      testarrayofstring2: None,
      testarrayofsortedstruct: None,
      flex: None,
      test5: None,
      vector_of_longs: None,
      vector_of_doubles: None,
      parent_namespace_test: None,
      vector_of_referrables: None,
      single_weak_reference: 0,
      vector_of_weak_references: None,
      vector_of_strong_referrables: None,
      co_owning_reference: 0,
      vector_of_co_owning_references: None,
      non_owning_reference: 0,
      vector_of_non_owning_references: None,
      any_unique: AnyUniqueAliasesT::NONE,
      any_ambiguous: AnyAmbiguousAliasesT::NONE,
      vector_of_enums: None,
      signed_enum: Race::None,
      testrequirednestedflatbuffer: None,
      scalar_key_sorted_tables: None,
    }
  }
}
impl MonsterT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Monster<'b>> {
    let pos_tmp = self.pos.as_ref().map(|x| x.pack());
    let pos = pos_tmp.as_ref();
    let mana = self.mana;
    let hp = self.hp;
    let name = Some({
      let x = &self.name;
      _fbb.create_string(x)
    });
    let inventory = self.inventory.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let color = self.color;
    let test_type = self.test.any_type();
    let test = self.test.pack(_fbb);
    let test4 = self.test4.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack()).collect();_fbb.create_vector(&w)
    });
    let testarrayofstring = self.testarrayofstring.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| s.as_ref()).collect();_fbb.create_vector_of_strings(&w)
    });
    let testarrayoftables = self.testarrayoftables.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let enemy = self.enemy.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let testnestedflatbuffer = self.testnestedflatbuffer.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let testempty = self.testempty.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let testbool = self.testbool;
    let testhashs32_fnv1 = self.testhashs32_fnv1;
    let testhashu32_fnv1 = self.testhashu32_fnv1;
    let testhashs64_fnv1 = self.testhashs64_fnv1;
    let testhashu64_fnv1 = self.testhashu64_fnv1;
    let testhashs32_fnv1a = self.testhashs32_fnv1a;
    let testhashu32_fnv1a = self.testhashu32_fnv1a;
    let testhashs64_fnv1a = self.testhashs64_fnv1a;
    let testhashu64_fnv1a = self.testhashu64_fnv1a;
    let testarrayofbools = self.testarrayofbools.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let testf = self.testf;
    let testf2 = self.testf2;
    let testf3 = self.testf3;
    let testarrayofstring2 = self.testarrayofstring2.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| s.as_ref()).collect();_fbb.create_vector_of_strings(&w)
    });
    let testarrayofsortedstruct = self.testarrayofsortedstruct.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack()).collect();_fbb.create_vector(&w)
    });
    let flex = self.flex.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let test5 = self.test5.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack()).collect();_fbb.create_vector(&w)
    });
    let vector_of_longs = self.vector_of_longs.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let vector_of_doubles = self.vector_of_doubles.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let parent_namespace_test = self.parent_namespace_test.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let vector_of_referrables = self.vector_of_referrables.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let single_weak_reference = self.single_weak_reference;
    let vector_of_weak_references = self.vector_of_weak_references.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let vector_of_strong_referrables = self.vector_of_strong_referrables.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let co_owning_reference = self.co_owning_reference;
    let vector_of_co_owning_references = self.vector_of_co_owning_references.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let non_owning_reference = self.non_owning_reference;
    let vector_of_non_owning_references = self.vector_of_non_owning_references.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let any_unique_type = self.any_unique.any_unique_aliases_type();
    let any_unique = self.any_unique.pack(_fbb);
    let any_ambiguous_type = self.any_ambiguous.any_ambiguous_aliases_type();
    let any_ambiguous = self.any_ambiguous.pack(_fbb);
    let vector_of_enums = self.vector_of_enums.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let signed_enum = self.signed_enum;
    let testrequirednestedflatbuffer = self.testrequirednestedflatbuffer.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let scalar_key_sorted_tables = self.scalar_key_sorted_tables.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    Monster::create(_fbb, &MonsterArgs{
      pos,
      mana,
      hp,
      name,
      inventory,
      color,
      test_type,
      test,
      test4,
      testarrayofstring,
      testarrayoftables,
      enemy,
      testnestedflatbuffer,
      testempty,
      testbool,
      testhashs32_fnv1,
      testhashu32_fnv1,
      testhashs64_fnv1,
      testhashu64_fnv1,
      testhashs32_fnv1a,
      testhashu32_fnv1a,
      testhashs64_fnv1a,
      testhashu64_fnv1a,
      testarrayofbools,
      testf,
      testf2,
      testf3,
      testarrayofstring2,
      testarrayofsortedstruct,
      flex,
      test5,
      vector_of_longs,
      vector_of_doubles,
      parent_namespace_test,
      vector_of_referrables,
      single_weak_reference,
      vector_of_weak_references,
      vector_of_strong_referrables,
      co_owning_reference,
      vector_of_co_owning_references,
      non_owning_reference,
      vector_of_non_owning_references,
      any_unique_type,
      any_unique,
      any_ambiguous_type,
      any_ambiguous,
      vector_of_enums,
      signed_enum,
      testrequirednestedflatbuffer,
      scalar_key_sorted_tables,
    })
  }
}
pub enum TypeAliasesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TypeAliases<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TypeAliases<'a> {
    type Inner = TypeAliases<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> TypeAliases<'a> {
    pub const fn get_fully_qualified_name() -> &'static str {
        "MyGame.Example.TypeAliases"
    }

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TypeAliases { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TypeAliasesArgs<'args>) -> flatbuffers::WIPOffset<TypeAliases<'bldr>> {
      let mut builder = TypeAliasesBuilder::new(_fbb);
      builder.add_f64_(args.f64_);
      builder.add_u64_(args.u64_);
      builder.add_i64_(args.i64_);
      if let Some(x) = args.vf64 { builder.add_vf64(x); }
      if let Some(x) = args.v8 { builder.add_v8(x); }
      builder.add_f32_(args.f32_);
      builder.add_u32_(args.u32_);
      builder.add_i32_(args.i32_);
      builder.add_u16_(args.u16_);
      builder.add_i16_(args.i16_);
      builder.add_u8_(args.u8_);
      builder.add_i8_(args.i8_);
      builder.finish()
    }

    pub fn unpack(&self) -> TypeAliasesT {
      let i8_ = self.i8_();
      let u8_ = self.u8_();
      let i16_ = self.i16_();
      let u16_ = self.u16_();
      let i32_ = self.i32_();
      let u32_ = self.u32_();
      let i64_ = self.i64_();
      let u64_ = self.u64_();
      let f32_ = self.f32_();
      let f64_ = self.f64_();
      let v8 = self.v8().map(|x| {
        x.to_vec()
      });
      let vf64 = self.vf64().map(|x| {
        x.into_iter().collect()
      });
      TypeAliasesT {
        i8_,
        u8_,
        i16_,
        u16_,
        i32_,
        u32_,
        i64_,
        u64_,
        f32_,
        f64_,
        v8,
        vf64,
      }
    }
    pub const VT_I8_: flatbuffers::VOffsetT = 4;
    pub const VT_U8_: flatbuffers::VOffsetT = 6;
    pub const VT_I16_: flatbuffers::VOffsetT = 8;
    pub const VT_U16_: flatbuffers::VOffsetT = 10;
    pub const VT_I32_: flatbuffers::VOffsetT = 12;
    pub const VT_U32_: flatbuffers::VOffsetT = 14;
    pub const VT_I64_: flatbuffers::VOffsetT = 16;
    pub const VT_U64_: flatbuffers::VOffsetT = 18;
    pub const VT_F32_: flatbuffers::VOffsetT = 20;
    pub const VT_F64_: flatbuffers::VOffsetT = 22;
    pub const VT_V8: flatbuffers::VOffsetT = 24;
    pub const VT_VF64: flatbuffers::VOffsetT = 26;

  #[inline]
  pub fn i8_(&self) -> i8 {
    self._tab.get::<i8>(TypeAliases::VT_I8_, Some(0)).unwrap()
  }
  #[inline]
  pub fn u8_(&self) -> u8 {
    self._tab.get::<u8>(TypeAliases::VT_U8_, Some(0)).unwrap()
  }
  #[inline]
  pub fn i16_(&self) -> i16 {
    self._tab.get::<i16>(TypeAliases::VT_I16_, Some(0)).unwrap()
  }
  #[inline]
  pub fn u16_(&self) -> u16 {
    self._tab.get::<u16>(TypeAliases::VT_U16_, Some(0)).unwrap()
  }
  #[inline]
  pub fn i32_(&self) -> i32 {
    self._tab.get::<i32>(TypeAliases::VT_I32_, Some(0)).unwrap()
  }
  #[inline]
  pub fn u32_(&self) -> u32 {
    self._tab.get::<u32>(TypeAliases::VT_U32_, Some(0)).unwrap()
  }
  #[inline]
  pub fn i64_(&self) -> i64 {
    self._tab.get::<i64>(TypeAliases::VT_I64_, Some(0)).unwrap()
  }
  #[inline]
  pub fn u64_(&self) -> u64 {
    self._tab.get::<u64>(TypeAliases::VT_U64_, Some(0)).unwrap()
  }
  #[inline]
  pub fn f32_(&self) -> f32 {
    self._tab.get::<f32>(TypeAliases::VT_F32_, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn f64_(&self) -> f64 {
    self._tab.get::<f64>(TypeAliases::VT_F64_, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn v8(&self) -> Option<&'a [i8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i8>>>(TypeAliases::VT_V8, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn vf64(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(TypeAliases::VT_VF64, None)
  }
}

impl flatbuffers::Verifiable for TypeAliases<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i8>(&"i8_", Self::VT_I8_, false)?
     .visit_field::<u8>(&"u8_", Self::VT_U8_, false)?
     .visit_field::<i16>(&"i16_", Self::VT_I16_, false)?
     .visit_field::<u16>(&"u16_", Self::VT_U16_, false)?
     .visit_field::<i32>(&"i32_", Self::VT_I32_, false)?
     .visit_field::<u32>(&"u32_", Self::VT_U32_, false)?
     .visit_field::<i64>(&"i64_", Self::VT_I64_, false)?
     .visit_field::<u64>(&"u64_", Self::VT_U64_, false)?
     .visit_field::<f32>(&"f32_", Self::VT_F32_, false)?
     .visit_field::<f64>(&"f64_", Self::VT_F64_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i8>>>(&"v8", Self::VT_V8, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"vf64", Self::VT_VF64, false)?
     .finish();
    Ok(())
  }
}
pub struct TypeAliasesArgs<'a> {
    pub i8_: i8,
    pub u8_: u8,
    pub i16_: i16,
    pub u16_: u16,
    pub i32_: i32,
    pub u32_: u32,
    pub i64_: i64,
    pub u64_: u64,
    pub f32_: f32,
    pub f64_: f64,
    pub v8: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i8>>>,
    pub vf64: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
}
impl<'a> Default for TypeAliasesArgs<'a> {
    #[inline]
    fn default() -> Self {
        TypeAliasesArgs {
            i8_: 0,
            u8_: 0,
            i16_: 0,
            u16_: 0,
            i32_: 0,
            u32_: 0,
            i64_: 0,
            u64_: 0,
            f32_: 0.0,
            f64_: 0.0,
            v8: None,
            vf64: None,
        }
    }
}
pub struct TypeAliasesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TypeAliasesBuilder<'a, 'b> {
  #[inline]
  pub fn add_i8_(&mut self, i8_: i8) {
    self.fbb_.push_slot::<i8>(TypeAliases::VT_I8_, i8_, 0);
  }
  #[inline]
  pub fn add_u8_(&mut self, u8_: u8) {
    self.fbb_.push_slot::<u8>(TypeAliases::VT_U8_, u8_, 0);
  }
  #[inline]
  pub fn add_i16_(&mut self, i16_: i16) {
    self.fbb_.push_slot::<i16>(TypeAliases::VT_I16_, i16_, 0);
  }
  #[inline]
  pub fn add_u16_(&mut self, u16_: u16) {
    self.fbb_.push_slot::<u16>(TypeAliases::VT_U16_, u16_, 0);
  }
  #[inline]
  pub fn add_i32_(&mut self, i32_: i32) {
    self.fbb_.push_slot::<i32>(TypeAliases::VT_I32_, i32_, 0);
  }
  #[inline]
  pub fn add_u32_(&mut self, u32_: u32) {
    self.fbb_.push_slot::<u32>(TypeAliases::VT_U32_, u32_, 0);
  }
  #[inline]
  pub fn add_i64_(&mut self, i64_: i64) {
    self.fbb_.push_slot::<i64>(TypeAliases::VT_I64_, i64_, 0);
  }
  #[inline]
  pub fn add_u64_(&mut self, u64_: u64) {
    self.fbb_.push_slot::<u64>(TypeAliases::VT_U64_, u64_, 0);
  }
  #[inline]
  pub fn add_f32_(&mut self, f32_: f32) {
    self.fbb_.push_slot::<f32>(TypeAliases::VT_F32_, f32_, 0.0);
  }
  #[inline]
  pub fn add_f64_(&mut self, f64_: f64) {
    self.fbb_.push_slot::<f64>(TypeAliases::VT_F64_, f64_, 0.0);
  }
  #[inline]
  pub fn add_v8(&mut self, v8: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TypeAliases::VT_V8, v8);
  }
  #[inline]
  pub fn add_vf64(&mut self, vf64: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TypeAliases::VT_VF64, vf64);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TypeAliasesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TypeAliasesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TypeAliases<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for TypeAliases<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("TypeAliases");
      ds.field("i8_", &self.i8_());
      ds.field("u8_", &self.u8_());
      ds.field("i16_", &self.i16_());
      ds.field("u16_", &self.u16_());
      ds.field("i32_", &self.i32_());
      ds.field("u32_", &self.u32_());
      ds.field("i64_", &self.i64_());
      ds.field("u64_", &self.u64_());
      ds.field("f32_", &self.f32_());
      ds.field("f64_", &self.f64_());
      ds.field("v8", &self.v8());
      ds.field("vf64", &self.vf64());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TypeAliasesT {
  pub i8_: i8,
  pub u8_: u8,
  pub i16_: i16,
  pub u16_: u16,
  pub i32_: i32,
  pub u32_: u32,
  pub i64_: i64,
  pub u64_: u64,
  pub f32_: f32,
  pub f64_: f64,
  pub v8: Option<Vec<i8>>,
  pub vf64: Option<Vec<f64>>,
}
impl Default for TypeAliasesT {
  fn default() -> Self {
    Self {
      i8_: 0,
      u8_: 0,
      i16_: 0,
      u16_: 0,
      i32_: 0,
      u32_: 0,
      i64_: 0,
      u64_: 0,
      f32_: 0.0,
      f64_: 0.0,
      v8: None,
      vf64: None,
    }
  }
}
impl TypeAliasesT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<TypeAliases<'b>> {
    let i8_ = self.i8_;
    let u8_ = self.u8_;
    let i16_ = self.i16_;
    let u16_ = self.u16_;
    let i32_ = self.i32_;
    let u32_ = self.u32_;
    let i64_ = self.i64_;
    let u64_ = self.u64_;
    let f32_ = self.f32_;
    let f64_ = self.f64_;
    let v8 = self.v8.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let vf64 = self.vf64.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    TypeAliases::create(_fbb, &TypeAliasesArgs{
      i8_,
      u8_,
      i16_,
      u16_,
      i32_,
      u32_,
      i64_,
      u64_,
      f32_,
      f64_,
      v8,
      vf64,
    })
  }
}
#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_monster<'a>(buf: &'a [u8]) -> Monster<'a> {
  unsafe { flatbuffers::root_unchecked::<Monster<'a>>(buf) }
}

#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_monster<'a>(buf: &'a [u8]) -> Monster<'a> {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<Monster<'a>>(buf) }
}

#[inline]
/// Verifies that a buffer of bytes contains a `Monster`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_monster_unchecked`.
pub fn root_as_monster(buf: &[u8]) -> Result<Monster, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Monster>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Monster` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_monster_unchecked`.
pub fn size_prefixed_root_as_monster(buf: &[u8]) -> Result<Monster, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Monster>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Monster` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_monster_unchecked`.
pub fn root_as_monster_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Monster<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Monster<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Monster` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_monster_unchecked`.
pub fn size_prefixed_root_as_monster_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Monster<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Monster<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Monster and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Monster`.
pub unsafe fn root_as_monster_unchecked(buf: &[u8]) -> Monster {
  flatbuffers::root_unchecked::<Monster>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Monster and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Monster`.
pub unsafe fn size_prefixed_root_as_monster_unchecked(buf: &[u8]) -> Monster {
  flatbuffers::size_prefixed_root_unchecked::<Monster>(buf)
}
pub const MONSTER_IDENTIFIER: &str = "MONS";

#[inline]
pub fn monster_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MONSTER_IDENTIFIER, false)
}

#[inline]
pub fn monster_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MONSTER_IDENTIFIER, true)
}

pub const MONSTER_EXTENSION: &str = "mon";

#[inline]
pub fn finish_monster_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Monster<'a>>) {
  fbb.finish(root, Some(MONSTER_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_monster_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Monster<'a>>) {
  fbb.finish_size_prefixed(root, Some(MONSTER_IDENTIFIER));
}
}  // pub mod Example
}  // pub mod MyGame

