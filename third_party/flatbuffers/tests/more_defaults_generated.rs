// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ABC: i32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ABC: i32 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ABC: [ABC; 3] = [
  ABC::A,
  ABC::B,
  ABC::C,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ABC(pub i32);
#[allow(non_upper_case_globals)]
impl ABC {
  pub const A: Self = Self(0);
  pub const B: Self = Self(1);
  pub const C: Self = Self(2);

  pub const ENUM_MIN: i32 = 0;
  pub const ENUM_MAX: i32 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::A,
    Self::B,
    Self::C,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::A => Some("A"),
      Self::B => Some("B"),
      Self::C => Some("C"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for ABC {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ABC {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<i32>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for ABC {
    type Output = ABC;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<i32>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for ABC {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = i32::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = i32::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ABC {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ABC {}
pub enum MoreDefaultsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MoreDefaults<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MoreDefaults<'a> {
    type Inner = MoreDefaults<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> MoreDefaults<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MoreDefaults { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MoreDefaultsArgs<'args>) -> flatbuffers::WIPOffset<MoreDefaults<'bldr>> {
      let mut builder = MoreDefaultsBuilder::new(_fbb);
      if let Some(x) = args.bools { builder.add_bools(x); }
      if let Some(x) = args.abcs { builder.add_abcs(x); }
      if let Some(x) = args.some_string { builder.add_some_string(x); }
      if let Some(x) = args.empty_string { builder.add_empty_string(x); }
      if let Some(x) = args.floats { builder.add_floats(x); }
      if let Some(x) = args.ints { builder.add_ints(x); }
      builder.finish()
    }

    pub fn unpack(&self) -> MoreDefaultsT {
      let ints = {
        let x = self.ints();
        x.into_iter().collect()
      };
      let floats = {
        let x = self.floats();
        x.into_iter().collect()
      };
      let empty_string = {
        let x = self.empty_string();
        x.to_string()
      };
      let some_string = {
        let x = self.some_string();
        x.to_string()
      };
      let abcs = {
        let x = self.abcs();
        x.into_iter().collect()
      };
      let bools = {
        let x = self.bools();
        x.to_vec()
      };
      MoreDefaultsT {
        ints,
        floats,
        empty_string,
        some_string,
        abcs,
        bools,
      }
    }
    pub const VT_INTS: flatbuffers::VOffsetT = 4;
    pub const VT_FLOATS: flatbuffers::VOffsetT = 6;
    pub const VT_EMPTY_STRING: flatbuffers::VOffsetT = 8;
    pub const VT_SOME_STRING: flatbuffers::VOffsetT = 10;
    pub const VT_ABCS: flatbuffers::VOffsetT = 12;
    pub const VT_BOOLS: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn ints(&self) -> flatbuffers::Vector<'a, i32> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(MoreDefaults::VT_INTS, Some(Default::default())).unwrap()
  }
  #[inline]
  pub fn floats(&self) -> flatbuffers::Vector<'a, f32> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(MoreDefaults::VT_FLOATS, Some(Default::default())).unwrap()
  }
  #[inline]
  pub fn empty_string(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MoreDefaults::VT_EMPTY_STRING, Some(&"")).unwrap()
  }
  #[inline]
  pub fn some_string(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MoreDefaults::VT_SOME_STRING, Some(&"some")).unwrap()
  }
  #[inline]
  pub fn abcs(&self) -> flatbuffers::Vector<'a, ABC> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ABC>>>(MoreDefaults::VT_ABCS, Some(Default::default())).unwrap()
  }
  #[inline]
  pub fn bools(&self) -> &'a [bool] {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, bool>>>(MoreDefaults::VT_BOOLS, Some(Default::default())).map(|v| v.safe_slice()).unwrap()
  }
}

impl flatbuffers::Verifiable for MoreDefaults<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(&"ints", Self::VT_INTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(&"floats", Self::VT_FLOATS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"empty_string", Self::VT_EMPTY_STRING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"some_string", Self::VT_SOME_STRING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ABC>>>(&"abcs", Self::VT_ABCS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, bool>>>(&"bools", Self::VT_BOOLS, false)?
     .finish();
    Ok(())
  }
}
pub struct MoreDefaultsArgs<'a> {
    pub ints: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub floats: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub empty_string: Option<flatbuffers::WIPOffset<&'a str>>,
    pub some_string: Option<flatbuffers::WIPOffset<&'a str>>,
    pub abcs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ABC>>>,
    pub bools: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, bool>>>,
}
impl<'a> Default for MoreDefaultsArgs<'a> {
    #[inline]
    fn default() -> Self {
        MoreDefaultsArgs {
            ints: None,
            floats: None,
            empty_string: None,
            some_string: None,
            abcs: None,
            bools: None,
        }
    }
}
pub struct MoreDefaultsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MoreDefaultsBuilder<'a, 'b> {
  #[inline]
  pub fn add_ints(&mut self, ints: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MoreDefaults::VT_INTS, ints);
  }
  #[inline]
  pub fn add_floats(&mut self, floats: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MoreDefaults::VT_FLOATS, floats);
  }
  #[inline]
  pub fn add_empty_string(&mut self, empty_string: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MoreDefaults::VT_EMPTY_STRING, empty_string);
  }
  #[inline]
  pub fn add_some_string(&mut self, some_string: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MoreDefaults::VT_SOME_STRING, some_string);
  }
  #[inline]
  pub fn add_abcs(&mut self, abcs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , ABC>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MoreDefaults::VT_ABCS, abcs);
  }
  #[inline]
  pub fn add_bools(&mut self, bools: flatbuffers::WIPOffset<flatbuffers::Vector<'b , bool>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MoreDefaults::VT_BOOLS, bools);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MoreDefaultsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MoreDefaultsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MoreDefaults<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for MoreDefaults<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("MoreDefaults");
      ds.field("ints", &self.ints());
      ds.field("floats", &self.floats());
      ds.field("empty_string", &self.empty_string());
      ds.field("some_string", &self.some_string());
      ds.field("abcs", &self.abcs());
      ds.field("bools", &self.bools());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MoreDefaultsT {
  pub ints: Vec<i32>,
  pub floats: Vec<f32>,
  pub empty_string: String,
  pub some_string: String,
  pub abcs: Vec<ABC>,
  pub bools: Vec<bool>,
}
impl Default for MoreDefaultsT {
  fn default() -> Self {
    Self {
      ints: Default::default(),
      floats: Default::default(),
      empty_string: "".to_string(),
      some_string: "some".to_string(),
      abcs: Default::default(),
      bools: Default::default(),
    }
  }
}
impl MoreDefaultsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<MoreDefaults<'b>> {
    let ints = Some({
      let x = &self.ints;
      _fbb.create_vector(x)
    });
    let floats = Some({
      let x = &self.floats;
      _fbb.create_vector(x)
    });
    let empty_string = Some({
      let x = &self.empty_string;
      _fbb.create_string(x)
    });
    let some_string = Some({
      let x = &self.some_string;
      _fbb.create_string(x)
    });
    let abcs = Some({
      let x = &self.abcs;
      _fbb.create_vector(x)
    });
    let bools = Some({
      let x = &self.bools;
      _fbb.create_vector(x)
    });
    MoreDefaults::create(_fbb, &MoreDefaultsArgs{
      ints,
      floats,
      empty_string,
      some_string,
      abcs,
      bools,
    })
  }
}
