// automatically generated by the FlatBuffers compiler, do not modify

import FlatBuffers

public enum MyGame {
public enum Example {

/// Composite components of Monster color.
public enum Color: UInt8, Enum { 
	public typealias T = UInt8
	public static var byteSize: Int { return MemoryLayout<UInt8>.size }
	public var value: UInt8 { return self.rawValue }
	case red = 1
	/// \brief color Green
	/// Green is bit_flag with value (1u << 1)
	case green = 2
	/// \brief color Blue (1u << 3)
	case blue = 8


	public static var max: Color { return .blue }
	public static var min: Color { return .red }
}

public enum Race: Int8, Enum { 
	public typealias T = Int8
	public static var byteSize: Int { return MemoryLayout<Int8>.size }
	public var value: Int8 { return self.rawValue }
	case none = -1
	case human = 0
	case dwarf = 1
	case elf = 2


	public static var max: Race { return .elf }
	public static var min: Race { return .none }
}

public enum Any_: UInt8, Enum { 
	public typealias T = UInt8
	public static var byteSize: Int { return MemoryLayout<UInt8>.size }
	public var value: UInt8 { return self.rawValue }
	case none = 0
	case monster = 1
	case testsimpletablewithenum = 2
	case mygame_example2_monster = 3


	public static var max: Any_ { return .mygame_example2_monster }
	public static var min: Any_ { return .none }
}

public enum AnyUniqueAliases: UInt8, Enum { 
	public typealias T = UInt8
	public static var byteSize: Int { return MemoryLayout<UInt8>.size }
	public var value: UInt8 { return self.rawValue }
	case none = 0
	case m = 1
	case ts = 2
	case m2 = 3


	public static var max: AnyUniqueAliases { return .m2 }
	public static var min: AnyUniqueAliases { return .none }
}

public enum AnyAmbiguousAliases: UInt8, Enum { 
	public typealias T = UInt8
	public static var byteSize: Int { return MemoryLayout<UInt8>.size }
	public var value: UInt8 { return self.rawValue }
	case none = 0
	case m1 = 1
	case m2 = 2
	case m3 = 3


	public static var max: AnyAmbiguousAliases { return .m3 }
	public static var min: AnyAmbiguousAliases { return .none }
}

public struct Test: Readable {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Struct
	public static var size = 4
	public static var alignment = 2	
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

	public var a: Int16 { return _accessor.readBuffer(of: Int16.self, at: 0) }
	public func mutate(a: Int16) -> Bool { return _accessor.mutate(a, index: 0) }
	public var b: Int8 { return _accessor.readBuffer(of: Int8.self, at: 2) }
	public func mutate(b: Int8) -> Bool { return _accessor.mutate(b, index: 2) }
}

public struct Vec3: Readable {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Struct
	public static var size = 32
	public static var alignment = 8	
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

	public var x: Float32 { return _accessor.readBuffer(of: Float32.self, at: 0) }
	public func mutate(x: Float32) -> Bool { return _accessor.mutate(x, index: 0) }
	public var y: Float32 { return _accessor.readBuffer(of: Float32.self, at: 4) }
	public func mutate(y: Float32) -> Bool { return _accessor.mutate(y, index: 4) }
	public var z: Float32 { return _accessor.readBuffer(of: Float32.self, at: 8) }
	public func mutate(z: Float32) -> Bool { return _accessor.mutate(z, index: 8) }
	public var test1: Double { return _accessor.readBuffer(of: Double.self, at: 16) }
	public func mutate(test1: Double) -> Bool { return _accessor.mutate(test1, index: 16) }
	public var test2: MyGame.Example.Color { return MyGame.Example.Color(rawValue: _accessor.readBuffer(of: UInt8.self, at: 24)) ?? .red }
	public var test3: MyGame.Example.Test { return MyGame.Example.Test(_accessor.bb, o: _accessor.postion + 26) }
}

public struct Ability: Readable {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Struct
	public static var size = 8
	public static var alignment = 4	
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

	public var id: UInt32 { return _accessor.readBuffer(of: UInt32.self, at: 0) }
	public func mutate(id: UInt32) -> Bool { return _accessor.mutate(id, index: 0) }
	public var distance: UInt32 { return _accessor.readBuffer(of: UInt32.self, at: 4) }
	public func mutate(distance: UInt32) -> Bool { return _accessor.mutate(distance, index: 4) }
}

public static func createTest(a: Int16, b: Int8) -> UnsafeMutableRawPointer {
	let memory = UnsafeMutableRawPointer.allocate(byteCount: Test.size, alignment: Test.alignment)
	memory.initializeMemory(as: UInt8.self, repeating: 0, count: Test.size)
	memory.storeBytes(of: a, toByteOffset: 0, as: Int16.self)
	memory.storeBytes(of: b, toByteOffset: 2, as: Int8.self)
	return memory
}

public static func createVec3(x: Float32, y: Float32, z: Float32, test1: Double, test2: MyGame.Example.Color, test3a: Int16, test3b: Int8) -> UnsafeMutableRawPointer {
	let memory = UnsafeMutableRawPointer.allocate(byteCount: Vec3.size, alignment: Vec3.alignment)
	memory.initializeMemory(as: UInt8.self, repeating: 0, count: Vec3.size)
	memory.storeBytes(of: x, toByteOffset: 0, as: Float32.self)
	memory.storeBytes(of: y, toByteOffset: 4, as: Float32.self)
	memory.storeBytes(of: z, toByteOffset: 8, as: Float32.self)
	memory.storeBytes(of: test1, toByteOffset: 16, as: Double.self)
	memory.storeBytes(of: test2.rawValue, toByteOffset: 24, as: UInt8.self)
	memory.storeBytes(of: test3a, toByteOffset: 26, as: Int16.self)
	memory.storeBytes(of: test3b, toByteOffset: 28, as: Int8.self)
	return memory
}

public static func createAbility(id: UInt32, distance: UInt32) -> UnsafeMutableRawPointer {
	let memory = UnsafeMutableRawPointer.allocate(byteCount: Ability.size, alignment: Ability.alignment)
	memory.initializeMemory(as: UInt8.self, repeating: 0, count: Ability.size)
	memory.storeBytes(of: id, toByteOffset: 0, as: UInt32.self)
	memory.storeBytes(of: distance, toByteOffset: 4, as: UInt32.self)
	return memory
}

}

// MARK: - Example


public struct InParentNamespace: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "MONS", addPrefix: prefix) }
	public static func getRootAsInParentNamespace(bb: ByteBuffer) -> InParentNamespace { return InParentNamespace(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public static func startInParentNamespace(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
	public static func endInParentNamespace(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createInParentNamespace(_ fbb: FlatBufferBuilder) -> Offset<UOffset> {
		let __start = InParentNamespace.startInParentNamespace(fbb)
		return InParentNamespace.endInParentNamespace(fbb, start: __start)
	}
}

public enum Example2 {

public struct Monster: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "MONS", addPrefix: prefix) }
	public static func getRootAsMonster(bb: ByteBuffer) -> Monster { return Monster(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public static func startMonster(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
	public static func endMonster(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createMonster(_ fbb: FlatBufferBuilder) -> Offset<UOffset> {
		let __start = Monster.startMonster(fbb)
		return Monster.endMonster(fbb, start: __start)
	}
}

}

// MARK: - Example2


}
extension MyGame.Example {

public struct TestSimpleTableWithEnum: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "MONS", addPrefix: prefix) }
	public static func getRootAsTestSimpleTableWithEnum(bb: ByteBuffer) -> TestSimpleTableWithEnum { return TestSimpleTableWithEnum(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var color: MyGame.Example.Color { let o = _accessor.offset(4); return o == 0 ? .green : MyGame.Example.Color(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .green }
	public func mutate(color: MyGame.Example.Color) -> Bool {let o = _accessor.offset(4);  return _accessor.mutate(color.rawValue, index: o) }
	public static func startTestSimpleTableWithEnum(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
	public static func add(color: MyGame.Example.Color, _ fbb: FlatBufferBuilder) { fbb.add(element: color.rawValue, def: 2, at: 0) }
	public static func endTestSimpleTableWithEnum(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createTestSimpleTableWithEnum(_ fbb: FlatBufferBuilder,
		color: MyGame.Example.Color = .green) -> Offset<UOffset> {
		let __start = TestSimpleTableWithEnum.startTestSimpleTableWithEnum(fbb)
		TestSimpleTableWithEnum.add(color: color, fbb)
		return TestSimpleTableWithEnum.endTestSimpleTableWithEnum(fbb, start: __start)
	}
}

public struct Stat: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "MONS", addPrefix: prefix) }
	public static func getRootAsStat(bb: ByteBuffer) -> Stat { return Stat(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var id: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public var val: Int64 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
	public func mutate(val: Int64) -> Bool {let o = _accessor.offset(6);  return _accessor.mutate(val, index: o) }
	public var count: UInt16 { let o = _accessor.offset(8); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
	public func mutate(count: UInt16) -> Bool {let o = _accessor.offset(8);  return _accessor.mutate(count, index: o) }
	public static func startStat(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
	public static func add(id: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: id, at: 0)  }
	public static func add(val: Int64, _ fbb: FlatBufferBuilder) { fbb.add(element: val, def: 0, at: 1) }
	public static func add(count: UInt16, _ fbb: FlatBufferBuilder) { fbb.add(element: count, def: 0, at: 2) }
	public static func endStat(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createStat(_ fbb: FlatBufferBuilder,
		offsetOfId id: Offset<String> = Offset(),
		val: Int64 = 0,
		count: UInt16 = 0) -> Offset<UOffset> {
		let __start = Stat.startStat(fbb)
		Stat.add(id: id, fbb)
		Stat.add(val: val, fbb)
		Stat.add(count: count, fbb)
		return Stat.endStat(fbb, start: __start)
	}
}

public struct Referrable: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "MONS", addPrefix: prefix) }
	public static func getRootAsReferrable(bb: ByteBuffer) -> Referrable { return Referrable(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var id: UInt64 { let o = _accessor.offset(4); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
	public func mutate(id: UInt64) -> Bool {let o = _accessor.offset(4);  return _accessor.mutate(id, index: o) }
	public static func startReferrable(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
	public static func add(id: UInt64, _ fbb: FlatBufferBuilder) { fbb.add(element: id, def: 0, at: 0) }
	public static func endReferrable(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createReferrable(_ fbb: FlatBufferBuilder,
		id: UInt64 = 0) -> Offset<UOffset> {
		let __start = Referrable.startReferrable(fbb)
		Referrable.add(id: id, fbb)
		return Referrable.endReferrable(fbb, start: __start)
	}
	public static func sortVectorOfReferrable(offsets:[Offset<UOffset>], _ fbb: FlatBufferBuilder) -> Offset<UOffset> {
		var off = offsets
		off.sort { Table.compare(Table.offset(Int32($1.o), vOffset: 4, fbb: fbb.buffer), Table.offset(Int32($0.o), vOffset: 4, fbb: fbb.buffer), fbb: fbb.buffer) < 0 } 
		return fbb.createVector(ofOffsets: off)
	}
	fileprivate static func lookupByKey(vector: Int32, key: UInt64, fbb: ByteBuffer) -> Referrable? {
		var span = fbb.read(def: Int32.self, position: Int(vector - 4))
		var start: Int32 = 0
		while span != 0 {
			var middle = span / 2
			let tableOffset = Table.indirect(vector + 4 * (start + middle), fbb)
			let comp = fbb.read(def: UInt64.self, position: Int(Table.offset(Int32(fbb.capacity) - tableOffset, vOffset: 4, fbb: fbb)))
			if comp > 0 {
				span = middle
			} else if comp < 0 {
				middle += 1
				start += middle
				span -= middle
			} else {
				return Referrable(fbb, o: tableOffset)
			}
		}
		return nil
	}
}

/// an example documentation comment: "monster object"
public struct Monster: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "MONS", addPrefix: prefix) }
	public static func getRootAsMonster(bb: ByteBuffer) -> Monster { return Monster(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var pos: MyGame.Example.Vec3? { let o = _accessor.offset(4); return o == 0 ? nil : MyGame.Example.Vec3(_accessor.bb, o: o + _accessor.postion) }
	public var mana: Int16 { let o = _accessor.offset(6); return o == 0 ? 150 : _accessor.readBuffer(of: Int16.self, at: o) }
	public func mutate(mana: Int16) -> Bool {let o = _accessor.offset(6);  return _accessor.mutate(mana, index: o) }
	public var hp: Int16 { let o = _accessor.offset(8); return o == 0 ? 100 : _accessor.readBuffer(of: Int16.self, at: o) }
	public func mutate(hp: Int16) -> Bool {let o = _accessor.offset(8);  return _accessor.mutate(hp, index: o) }
	public var name: String? { let o = _accessor.offset(10); return o == 0 ? nil : _accessor.string(at: o) }
	public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: 10) }
	public var inventoryCount: Int32 { let o = _accessor.offset(14); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func inventory(at index: Int32) -> UInt8 { let o = _accessor.offset(14); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
	public var inventory: [UInt8] { return _accessor.getVector(at: 14) ?? [] }
	public func mutate(inventory: UInt8, at index: Int32) -> Bool { let o = _accessor.offset(14); return _accessor.directMutate(inventory, index: _accessor.vector(at: o) + index * 1) }
	public var color: MyGame.Example.Color { let o = _accessor.offset(16); return o == 0 ? .blue : MyGame.Example.Color(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .blue }
	public func mutate(color: MyGame.Example.Color) -> Bool {let o = _accessor.offset(16);  return _accessor.mutate(color.rawValue, index: o) }
	public var testType: MyGame.Example.Any_ { let o = _accessor.offset(18); return o == 0 ? .none : MyGame.Example.Any_(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none }
	public func test<T: FlatBufferObject>(type: T.Type) -> T? { let o = _accessor.offset(20); return o == 0 ? nil : _accessor.union(o) }
	public var test4Count: Int32 { let o = _accessor.offset(22); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func test4(at index: Int32) -> MyGame.Example.Test? { let o = _accessor.offset(22); return o == 0 ? nil : MyGame.Example.Test(_accessor.bb, o: _accessor.vector(at: o) + index * 4) }
	public var testarrayofstringCount: Int32 { let o = _accessor.offset(24); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func testarrayofstring(at index: Int32) -> String? { let o = _accessor.offset(24); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
	/// an example documentation comment: this will end up in the generated code
	/// multiline too
	public var testarrayoftablesCount: Int32 { let o = _accessor.offset(26); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func testarrayoftables(at index: Int32) -> MyGame.Example.Monster? { let o = _accessor.offset(26); return o == 0 ? nil : MyGame.Example.Monster(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public func testarrayoftablesBy(key: String) -> MyGame.Example.Monster? { let o = _accessor.offset(26); return o == 0 ? nil : MyGame.Example.Monster.lookupByKey(vector: _accessor.vector(at: o), key: key, fbb: _accessor.bb) }
	public var enemy: MyGame.Example.Monster? { let o = _accessor.offset(28); return o == 0 ? nil : MyGame.Example.Monster(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
	public var testnestedflatbufferCount: Int32 { let o = _accessor.offset(30); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func testnestedflatbuffer(at index: Int32) -> UInt8 { let o = _accessor.offset(30); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
	public var testnestedflatbuffer: [UInt8] { return _accessor.getVector(at: 30) ?? [] }
	public func mutate(testnestedflatbuffer: UInt8, at index: Int32) -> Bool { let o = _accessor.offset(30); return _accessor.directMutate(testnestedflatbuffer, index: _accessor.vector(at: o) + index * 1) }
	public var testempty: MyGame.Example.Stat? { let o = _accessor.offset(32); return o == 0 ? nil : MyGame.Example.Stat(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
	public var testbool: Bool { let o = _accessor.offset(34); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
	public func mutate(testbool: Byte) -> Bool {let o = _accessor.offset(34);  return _accessor.mutate(testbool, index: o) }
	public var testhashs32Fnv1: Int32 { let o = _accessor.offset(36); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public func mutate(testhashs32Fnv1: Int32) -> Bool {let o = _accessor.offset(36);  return _accessor.mutate(testhashs32Fnv1, index: o) }
	public var testhashu32Fnv1: UInt32 { let o = _accessor.offset(38); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
	public func mutate(testhashu32Fnv1: UInt32) -> Bool {let o = _accessor.offset(38);  return _accessor.mutate(testhashu32Fnv1, index: o) }
	public var testhashs64Fnv1: Int64 { let o = _accessor.offset(40); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
	public func mutate(testhashs64Fnv1: Int64) -> Bool {let o = _accessor.offset(40);  return _accessor.mutate(testhashs64Fnv1, index: o) }
	public var testhashu64Fnv1: UInt64 { let o = _accessor.offset(42); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
	public func mutate(testhashu64Fnv1: UInt64) -> Bool {let o = _accessor.offset(42);  return _accessor.mutate(testhashu64Fnv1, index: o) }
	public var testhashs32Fnv1a: Int32 { let o = _accessor.offset(44); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public func mutate(testhashs32Fnv1a: Int32) -> Bool {let o = _accessor.offset(44);  return _accessor.mutate(testhashs32Fnv1a, index: o) }
	public var testhashu32Fnv1a: UInt32 { let o = _accessor.offset(46); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
	public func mutate(testhashu32Fnv1a: UInt32) -> Bool {let o = _accessor.offset(46);  return _accessor.mutate(testhashu32Fnv1a, index: o) }
	public var testhashs64Fnv1a: Int64 { let o = _accessor.offset(48); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
	public func mutate(testhashs64Fnv1a: Int64) -> Bool {let o = _accessor.offset(48);  return _accessor.mutate(testhashs64Fnv1a, index: o) }
	public var testhashu64Fnv1a: UInt64 { let o = _accessor.offset(50); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
	public func mutate(testhashu64Fnv1a: UInt64) -> Bool {let o = _accessor.offset(50);  return _accessor.mutate(testhashu64Fnv1a, index: o) }
	public var testarrayofboolsCount: Int32 { let o = _accessor.offset(52); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func testarrayofbools(at index: Int32) -> Bool { let o = _accessor.offset(52); return o == 0 ? true : 0 != _accessor.directRead(of: Byte.self, offset: _accessor.vector(at: o) + index * 1) }
	public var testarrayofbools: [Byte] { return _accessor.getVector(at: 52) ?? [] }
	public func mutate(testarrayofbools: Byte, at index: Int32) -> Bool { let o = _accessor.offset(52); return _accessor.directMutate(testarrayofbools, index: _accessor.vector(at: o) + index * 1) }
	public var testf: Float32 { let o = _accessor.offset(54); return o == 0 ? 3.14159 : _accessor.readBuffer(of: Float32.self, at: o) }
	public func mutate(testf: Float32) -> Bool {let o = _accessor.offset(54);  return _accessor.mutate(testf, index: o) }
	public var testf2: Float32 { let o = _accessor.offset(56); return o == 0 ? 3.0 : _accessor.readBuffer(of: Float32.self, at: o) }
	public func mutate(testf2: Float32) -> Bool {let o = _accessor.offset(56);  return _accessor.mutate(testf2, index: o) }
	public var testf3: Float32 { let o = _accessor.offset(58); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
	public func mutate(testf3: Float32) -> Bool {let o = _accessor.offset(58);  return _accessor.mutate(testf3, index: o) }
	public var testarrayofstring2Count: Int32 { let o = _accessor.offset(60); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func testarrayofstring2(at index: Int32) -> String? { let o = _accessor.offset(60); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
	public var testarrayofsortedstructCount: Int32 { let o = _accessor.offset(62); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func testarrayofsortedstruct(at index: Int32) -> MyGame.Example.Ability? { let o = _accessor.offset(62); return o == 0 ? nil : MyGame.Example.Ability(_accessor.bb, o: _accessor.vector(at: o) + index * 8) }
	public var flexCount: Int32 { let o = _accessor.offset(64); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func flex(at index: Int32) -> UInt8 { let o = _accessor.offset(64); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
	public var flex: [UInt8] { return _accessor.getVector(at: 64) ?? [] }
	public func mutate(flex: UInt8, at index: Int32) -> Bool { let o = _accessor.offset(64); return _accessor.directMutate(flex, index: _accessor.vector(at: o) + index * 1) }
	public var test5Count: Int32 { let o = _accessor.offset(66); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func test5(at index: Int32) -> MyGame.Example.Test? { let o = _accessor.offset(66); return o == 0 ? nil : MyGame.Example.Test(_accessor.bb, o: _accessor.vector(at: o) + index * 4) }
	public var vectorOfLongsCount: Int32 { let o = _accessor.offset(68); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func vectorOfLongs(at index: Int32) -> Int64 { let o = _accessor.offset(68); return o == 0 ? 0 : _accessor.directRead(of: Int64.self, offset: _accessor.vector(at: o) + index * 8) }
	public var vectorOfLongs: [Int64] { return _accessor.getVector(at: 68) ?? [] }
	public func mutate(vectorOfLongs: Int64, at index: Int32) -> Bool { let o = _accessor.offset(68); return _accessor.directMutate(vectorOfLongs, index: _accessor.vector(at: o) + index * 8) }
	public var vectorOfDoublesCount: Int32 { let o = _accessor.offset(70); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func vectorOfDoubles(at index: Int32) -> Double { let o = _accessor.offset(70); return o == 0 ? 0 : _accessor.directRead(of: Double.self, offset: _accessor.vector(at: o) + index * 8) }
	public var vectorOfDoubles: [Double] { return _accessor.getVector(at: 70) ?? [] }
	public func mutate(vectorOfDoubles: Double, at index: Int32) -> Bool { let o = _accessor.offset(70); return _accessor.directMutate(vectorOfDoubles, index: _accessor.vector(at: o) + index * 8) }
	public var parentNamespaceTest: MyGame.InParentNamespace? { let o = _accessor.offset(72); return o == 0 ? nil : MyGame.InParentNamespace(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
	public var vectorOfReferrablesCount: Int32 { let o = _accessor.offset(74); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func vectorOfReferrables(at index: Int32) -> MyGame.Example.Referrable? { let o = _accessor.offset(74); return o == 0 ? nil : MyGame.Example.Referrable(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public func vectorOfReferrablesBy(key: UInt64) -> MyGame.Example.Referrable? { let o = _accessor.offset(74); return o == 0 ? nil : MyGame.Example.Referrable.lookupByKey(vector: _accessor.vector(at: o), key: key, fbb: _accessor.bb) }
	public var singleWeakReference: UInt64 { let o = _accessor.offset(76); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
	public func mutate(singleWeakReference: UInt64) -> Bool {let o = _accessor.offset(76);  return _accessor.mutate(singleWeakReference, index: o) }
	public var vectorOfWeakReferencesCount: Int32 { let o = _accessor.offset(78); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func vectorOfWeakReferences(at index: Int32) -> UInt64 { let o = _accessor.offset(78); return o == 0 ? 0 : _accessor.directRead(of: UInt64.self, offset: _accessor.vector(at: o) + index * 8) }
	public var vectorOfWeakReferences: [UInt64] { return _accessor.getVector(at: 78) ?? [] }
	public func mutate(vectorOfWeakReferences: UInt64, at index: Int32) -> Bool { let o = _accessor.offset(78); return _accessor.directMutate(vectorOfWeakReferences, index: _accessor.vector(at: o) + index * 8) }
	public var vectorOfStrongReferrablesCount: Int32 { let o = _accessor.offset(80); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func vectorOfStrongReferrables(at index: Int32) -> MyGame.Example.Referrable? { let o = _accessor.offset(80); return o == 0 ? nil : MyGame.Example.Referrable(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public func vectorOfStrongReferrablesBy(key: UInt64) -> MyGame.Example.Referrable? { let o = _accessor.offset(80); return o == 0 ? nil : MyGame.Example.Referrable.lookupByKey(vector: _accessor.vector(at: o), key: key, fbb: _accessor.bb) }
	public var coOwningReference: UInt64 { let o = _accessor.offset(82); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
	public func mutate(coOwningReference: UInt64) -> Bool {let o = _accessor.offset(82);  return _accessor.mutate(coOwningReference, index: o) }
	public var vectorOfCoOwningReferencesCount: Int32 { let o = _accessor.offset(84); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func vectorOfCoOwningReferences(at index: Int32) -> UInt64 { let o = _accessor.offset(84); return o == 0 ? 0 : _accessor.directRead(of: UInt64.self, offset: _accessor.vector(at: o) + index * 8) }
	public var vectorOfCoOwningReferences: [UInt64] { return _accessor.getVector(at: 84) ?? [] }
	public func mutate(vectorOfCoOwningReferences: UInt64, at index: Int32) -> Bool { let o = _accessor.offset(84); return _accessor.directMutate(vectorOfCoOwningReferences, index: _accessor.vector(at: o) + index * 8) }
	public var nonOwningReference: UInt64 { let o = _accessor.offset(86); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
	public func mutate(nonOwningReference: UInt64) -> Bool {let o = _accessor.offset(86);  return _accessor.mutate(nonOwningReference, index: o) }
	public var vectorOfNonOwningReferencesCount: Int32 { let o = _accessor.offset(88); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func vectorOfNonOwningReferences(at index: Int32) -> UInt64 { let o = _accessor.offset(88); return o == 0 ? 0 : _accessor.directRead(of: UInt64.self, offset: _accessor.vector(at: o) + index * 8) }
	public var vectorOfNonOwningReferences: [UInt64] { return _accessor.getVector(at: 88) ?? [] }
	public func mutate(vectorOfNonOwningReferences: UInt64, at index: Int32) -> Bool { let o = _accessor.offset(88); return _accessor.directMutate(vectorOfNonOwningReferences, index: _accessor.vector(at: o) + index * 8) }
	public var anyUniqueType: MyGame.Example.AnyUniqueAliases { let o = _accessor.offset(90); return o == 0 ? .none : MyGame.Example.AnyUniqueAliases(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none }
	public func anyUnique<T: FlatBufferObject>(type: T.Type) -> T? { let o = _accessor.offset(92); return o == 0 ? nil : _accessor.union(o) }
	public var anyAmbiguousType: MyGame.Example.AnyAmbiguousAliases { let o = _accessor.offset(94); return o == 0 ? .none : MyGame.Example.AnyAmbiguousAliases(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none }
	public func anyAmbiguous<T: FlatBufferObject>(type: T.Type) -> T? { let o = _accessor.offset(96); return o == 0 ? nil : _accessor.union(o) }
	public var vectorOfEnumsCount: Int32 { let o = _accessor.offset(98); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func vectorOfEnums(at index: Int32) -> MyGame.Example.Color? { let o = _accessor.offset(98); return o == 0 ? MyGame.Example.Color.red : MyGame.Example.Color(rawValue: _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1)) }
	public var signedEnum: MyGame.Example.Race { let o = _accessor.offset(100); return o == 0 ? .none : MyGame.Example.Race(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none }
	public func mutate(signedEnum: MyGame.Example.Race) -> Bool {let o = _accessor.offset(100);  return _accessor.mutate(signedEnum.rawValue, index: o) }
	public static func startMonster(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 49) }
	public static func add(pos: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(structOffset: 0) }
	public static func add(mana: Int16, _ fbb: FlatBufferBuilder) { fbb.add(element: mana, def: 150, at: 1) }
	public static func add(hp: Int16, _ fbb: FlatBufferBuilder) { fbb.add(element: hp, def: 100, at: 2) }
	public static func add(name: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: name, at: 3)  }
	public static func addVectorOf(inventory: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: inventory, at: 5)  }
	public static func add(color: MyGame.Example.Color, _ fbb: FlatBufferBuilder) { fbb.add(element: color.rawValue, def: 8, at: 6) }
	public static func add(testType: MyGame.Example.Any_, _ fbb: FlatBufferBuilder) { fbb.add(element: testType.rawValue, def: 0, at: 7) }
	public static func add(test: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: test, at: 8)  }
	public static func addVectorOf(test4: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: test4, at: 9)  }
	public static func addVectorOf(testarrayofstring: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: testarrayofstring, at: 10)  }
	public static func addVectorOf(testarrayoftables: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: testarrayoftables, at: 11)  }
	public static func add(enemy: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: enemy, at: 12)  }
	public static func addVectorOf(testnestedflatbuffer: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: testnestedflatbuffer, at: 13)  }
	public static func add(testempty: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: testempty, at: 14)  }
	public static func add(testbool: Bool, _ fbb: FlatBufferBuilder) { fbb.add(condition: testbool, def: false, at: 15) }
	public static func add(testhashs32Fnv1: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: testhashs32Fnv1, def: 0, at: 16) }
	public static func add(testhashu32Fnv1: UInt32, _ fbb: FlatBufferBuilder) { fbb.add(element: testhashu32Fnv1, def: 0, at: 17) }
	public static func add(testhashs64Fnv1: Int64, _ fbb: FlatBufferBuilder) { fbb.add(element: testhashs64Fnv1, def: 0, at: 18) }
	public static func add(testhashu64Fnv1: UInt64, _ fbb: FlatBufferBuilder) { fbb.add(element: testhashu64Fnv1, def: 0, at: 19) }
	public static func add(testhashs32Fnv1a: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: testhashs32Fnv1a, def: 0, at: 20) }
	public static func add(testhashu32Fnv1a: UInt32, _ fbb: FlatBufferBuilder) { fbb.add(element: testhashu32Fnv1a, def: 0, at: 21) }
	public static func add(testhashs64Fnv1a: Int64, _ fbb: FlatBufferBuilder) { fbb.add(element: testhashs64Fnv1a, def: 0, at: 22) }
	public static func add(testhashu64Fnv1a: UInt64, _ fbb: FlatBufferBuilder) { fbb.add(element: testhashu64Fnv1a, def: 0, at: 23) }
	public static func addVectorOf(testarrayofbools: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: testarrayofbools, at: 24)  }
	public static func add(testf: Float32, _ fbb: FlatBufferBuilder) { fbb.add(element: testf, def: 3.14159, at: 25) }
	public static func add(testf2: Float32, _ fbb: FlatBufferBuilder) { fbb.add(element: testf2, def: 3.0, at: 26) }
	public static func add(testf3: Float32, _ fbb: FlatBufferBuilder) { fbb.add(element: testf3, def: 0.0, at: 27) }
	public static func addVectorOf(testarrayofstring2: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: testarrayofstring2, at: 28)  }
	public static func addVectorOf(testarrayofsortedstruct: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: testarrayofsortedstruct, at: 29)  }
	public static func addVectorOf(flex: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: flex, at: 30)  }
	public static func addVectorOf(test5: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: test5, at: 31)  }
	public static func addVectorOf(vectorOfLongs: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: vectorOfLongs, at: 32)  }
	public static func addVectorOf(vectorOfDoubles: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: vectorOfDoubles, at: 33)  }
	public static func add(parentNamespaceTest: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: parentNamespaceTest, at: 34)  }
	public static func addVectorOf(vectorOfReferrables: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: vectorOfReferrables, at: 35)  }
	public static func add(singleWeakReference: UInt64, _ fbb: FlatBufferBuilder) { fbb.add(element: singleWeakReference, def: 0, at: 36) }
	public static func addVectorOf(vectorOfWeakReferences: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: vectorOfWeakReferences, at: 37)  }
	public static func addVectorOf(vectorOfStrongReferrables: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: vectorOfStrongReferrables, at: 38)  }
	public static func add(coOwningReference: UInt64, _ fbb: FlatBufferBuilder) { fbb.add(element: coOwningReference, def: 0, at: 39) }
	public static func addVectorOf(vectorOfCoOwningReferences: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: vectorOfCoOwningReferences, at: 40)  }
	public static func add(nonOwningReference: UInt64, _ fbb: FlatBufferBuilder) { fbb.add(element: nonOwningReference, def: 0, at: 41) }
	public static func addVectorOf(vectorOfNonOwningReferences: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: vectorOfNonOwningReferences, at: 42)  }
	public static func add(anyUniqueType: MyGame.Example.AnyUniqueAliases, _ fbb: FlatBufferBuilder) { fbb.add(element: anyUniqueType.rawValue, def: 0, at: 43) }
	public static func add(anyUnique: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: anyUnique, at: 44)  }
	public static func add(anyAmbiguousType: MyGame.Example.AnyAmbiguousAliases, _ fbb: FlatBufferBuilder) { fbb.add(element: anyAmbiguousType.rawValue, def: 0, at: 45) }
	public static func add(anyAmbiguous: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: anyAmbiguous, at: 46)  }
	public static func addVectorOf(vectorOfEnums: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: vectorOfEnums, at: 47)  }
	public static func add(signedEnum: MyGame.Example.Race, _ fbb: FlatBufferBuilder) { fbb.add(element: signedEnum.rawValue, def: -1, at: 48) }
	public static func endMonster(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [10]); return end }
	public static func createMonster(_ fbb: FlatBufferBuilder,
		offsetOfPos pos: Offset<UOffset> = Offset(),
		mana: Int16 = 150,
		hp: Int16 = 100,
		offsetOfName name: Offset<String> = Offset(),
		vectorOfInventory inventory: Offset<UOffset> = Offset(),
		color: MyGame.Example.Color = .blue,
		testType: MyGame.Example.Any_ = .none,
		offsetOfTest test: Offset<UOffset> = Offset(),
		vectorOfTest4 test4: Offset<UOffset> = Offset(),
		vectorOfTestarrayofstring testarrayofstring: Offset<UOffset> = Offset(),
		vectorOfTestarrayoftables testarrayoftables: Offset<UOffset> = Offset(),
		offsetOfEnemy enemy: Offset<UOffset> = Offset(),
		vectorOfTestnestedflatbuffer testnestedflatbuffer: Offset<UOffset> = Offset(),
		offsetOfTestempty testempty: Offset<UOffset> = Offset(),
		testbool: Bool = false,
		testhashs32Fnv1: Int32 = 0,
		testhashu32Fnv1: UInt32 = 0,
		testhashs64Fnv1: Int64 = 0,
		testhashu64Fnv1: UInt64 = 0,
		testhashs32Fnv1a: Int32 = 0,
		testhashu32Fnv1a: UInt32 = 0,
		testhashs64Fnv1a: Int64 = 0,
		testhashu64Fnv1a: UInt64 = 0,
		vectorOfTestarrayofbools testarrayofbools: Offset<UOffset> = Offset(),
		testf: Float32 = 3.14159,
		testf2: Float32 = 3.0,
		testf3: Float32 = 0.0,
		vectorOfTestarrayofstring2 testarrayofstring2: Offset<UOffset> = Offset(),
		vectorOfTestarrayofsortedstruct testarrayofsortedstruct: Offset<UOffset> = Offset(),
		vectorOfFlex flex: Offset<UOffset> = Offset(),
		vectorOfTest5 test5: Offset<UOffset> = Offset(),
		vectorOfVectorOfLongs vectorOfLongs: Offset<UOffset> = Offset(),
		vectorOfVectorOfDoubles vectorOfDoubles: Offset<UOffset> = Offset(),
		offsetOfParentNamespaceTest parentNamespaceTest: Offset<UOffset> = Offset(),
		vectorOfVectorOfReferrables vectorOfReferrables: Offset<UOffset> = Offset(),
		singleWeakReference: UInt64 = 0,
		vectorOfVectorOfWeakReferences vectorOfWeakReferences: Offset<UOffset> = Offset(),
		vectorOfVectorOfStrongReferrables vectorOfStrongReferrables: Offset<UOffset> = Offset(),
		coOwningReference: UInt64 = 0,
		vectorOfVectorOfCoOwningReferences vectorOfCoOwningReferences: Offset<UOffset> = Offset(),
		nonOwningReference: UInt64 = 0,
		vectorOfVectorOfNonOwningReferences vectorOfNonOwningReferences: Offset<UOffset> = Offset(),
		anyUniqueType: MyGame.Example.AnyUniqueAliases = .none,
		offsetOfAnyUnique anyUnique: Offset<UOffset> = Offset(),
		anyAmbiguousType: MyGame.Example.AnyAmbiguousAliases = .none,
		offsetOfAnyAmbiguous anyAmbiguous: Offset<UOffset> = Offset(),
		vectorOfVectorOfEnums vectorOfEnums: Offset<UOffset> = Offset(),
		signedEnum: MyGame.Example.Race = .none) -> Offset<UOffset> {
		let __start = Monster.startMonster(fbb)
		Monster.add(pos: pos, fbb)
		Monster.add(mana: mana, fbb)
		Monster.add(hp: hp, fbb)
		Monster.add(name: name, fbb)
		Monster.addVectorOf(inventory: inventory, fbb)
		Monster.add(color: color, fbb)
		Monster.add(testType: testType, fbb)
		Monster.add(test: test, fbb)
		Monster.addVectorOf(test4: test4, fbb)
		Monster.addVectorOf(testarrayofstring: testarrayofstring, fbb)
		Monster.addVectorOf(testarrayoftables: testarrayoftables, fbb)
		Monster.add(enemy: enemy, fbb)
		Monster.addVectorOf(testnestedflatbuffer: testnestedflatbuffer, fbb)
		Monster.add(testempty: testempty, fbb)
		Monster.add(testbool: testbool, fbb)
		Monster.add(testhashs32Fnv1: testhashs32Fnv1, fbb)
		Monster.add(testhashu32Fnv1: testhashu32Fnv1, fbb)
		Monster.add(testhashs64Fnv1: testhashs64Fnv1, fbb)
		Monster.add(testhashu64Fnv1: testhashu64Fnv1, fbb)
		Monster.add(testhashs32Fnv1a: testhashs32Fnv1a, fbb)
		Monster.add(testhashu32Fnv1a: testhashu32Fnv1a, fbb)
		Monster.add(testhashs64Fnv1a: testhashs64Fnv1a, fbb)
		Monster.add(testhashu64Fnv1a: testhashu64Fnv1a, fbb)
		Monster.addVectorOf(testarrayofbools: testarrayofbools, fbb)
		Monster.add(testf: testf, fbb)
		Monster.add(testf2: testf2, fbb)
		Monster.add(testf3: testf3, fbb)
		Monster.addVectorOf(testarrayofstring2: testarrayofstring2, fbb)
		Monster.addVectorOf(testarrayofsortedstruct: testarrayofsortedstruct, fbb)
		Monster.addVectorOf(flex: flex, fbb)
		Monster.addVectorOf(test5: test5, fbb)
		Monster.addVectorOf(vectorOfLongs: vectorOfLongs, fbb)
		Monster.addVectorOf(vectorOfDoubles: vectorOfDoubles, fbb)
		Monster.add(parentNamespaceTest: parentNamespaceTest, fbb)
		Monster.addVectorOf(vectorOfReferrables: vectorOfReferrables, fbb)
		Monster.add(singleWeakReference: singleWeakReference, fbb)
		Monster.addVectorOf(vectorOfWeakReferences: vectorOfWeakReferences, fbb)
		Monster.addVectorOf(vectorOfStrongReferrables: vectorOfStrongReferrables, fbb)
		Monster.add(coOwningReference: coOwningReference, fbb)
		Monster.addVectorOf(vectorOfCoOwningReferences: vectorOfCoOwningReferences, fbb)
		Monster.add(nonOwningReference: nonOwningReference, fbb)
		Monster.addVectorOf(vectorOfNonOwningReferences: vectorOfNonOwningReferences, fbb)
		Monster.add(anyUniqueType: anyUniqueType, fbb)
		Monster.add(anyUnique: anyUnique, fbb)
		Monster.add(anyAmbiguousType: anyAmbiguousType, fbb)
		Monster.add(anyAmbiguous: anyAmbiguous, fbb)
		Monster.addVectorOf(vectorOfEnums: vectorOfEnums, fbb)
		Monster.add(signedEnum: signedEnum, fbb)
		return Monster.endMonster(fbb, start: __start)
	}
	public static func sortVectorOfMonster(offsets:[Offset<UOffset>], _ fbb: FlatBufferBuilder) -> Offset<UOffset> {
		var off = offsets
		off.sort { Table.compare(Table.offset(Int32($1.o), vOffset: 10, fbb: fbb.buffer), Table.offset(Int32($0.o), vOffset: 10, fbb: fbb.buffer), fbb: fbb.buffer) < 0 } 
		return fbb.createVector(ofOffsets: off)
	}
	fileprivate static func lookupByKey(vector: Int32, key: String, fbb: ByteBuffer) -> Monster? {
		let key = key.utf8.map { $0 }
		var span = fbb.read(def: Int32.self, position: Int(vector - 4))
		var start: Int32 = 0
		while span != 0 {
			var middle = span / 2
			let tableOffset = Table.indirect(vector + 4 * (start + middle), fbb)
			let comp = Table.compare(Table.offset(Int32(fbb.capacity) - tableOffset, vOffset: 10, fbb: fbb), key, fbb: fbb)
			if comp > 0 {
				span = middle
			} else if comp < 0 {
				middle += 1
				start += middle
				span -= middle
			} else {
				return Monster(fbb, o: tableOffset)
			}
		}
		return nil
	}
}

public struct TypeAliases: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "MONS", addPrefix: prefix) }
	public static func getRootAsTypeAliases(bb: ByteBuffer) -> TypeAliases { return TypeAliases(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var i8: Int8 { let o = _accessor.offset(4); return o == 0 ? 0 : _accessor.readBuffer(of: Int8.self, at: o) }
	public func mutate(i8: Int8) -> Bool {let o = _accessor.offset(4);  return _accessor.mutate(i8, index: o) }
	public var u8: UInt8 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
	public func mutate(u8: UInt8) -> Bool {let o = _accessor.offset(6);  return _accessor.mutate(u8, index: o) }
	public var i16: Int16 { let o = _accessor.offset(8); return o == 0 ? 0 : _accessor.readBuffer(of: Int16.self, at: o) }
	public func mutate(i16: Int16) -> Bool {let o = _accessor.offset(8);  return _accessor.mutate(i16, index: o) }
	public var u16: UInt16 { let o = _accessor.offset(10); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
	public func mutate(u16: UInt16) -> Bool {let o = _accessor.offset(10);  return _accessor.mutate(u16, index: o) }
	public var i32: Int32 { let o = _accessor.offset(12); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
	public func mutate(i32: Int32) -> Bool {let o = _accessor.offset(12);  return _accessor.mutate(i32, index: o) }
	public var u32: UInt32 { let o = _accessor.offset(14); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
	public func mutate(u32: UInt32) -> Bool {let o = _accessor.offset(14);  return _accessor.mutate(u32, index: o) }
	public var i64: Int64 { let o = _accessor.offset(16); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
	public func mutate(i64: Int64) -> Bool {let o = _accessor.offset(16);  return _accessor.mutate(i64, index: o) }
	public var u64: UInt64 { let o = _accessor.offset(18); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
	public func mutate(u64: UInt64) -> Bool {let o = _accessor.offset(18);  return _accessor.mutate(u64, index: o) }
	public var f32: Float32 { let o = _accessor.offset(20); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
	public func mutate(f32: Float32) -> Bool {let o = _accessor.offset(20);  return _accessor.mutate(f32, index: o) }
	public var f64: Double { let o = _accessor.offset(22); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
	public func mutate(f64: Double) -> Bool {let o = _accessor.offset(22);  return _accessor.mutate(f64, index: o) }
	public var v8Count: Int32 { let o = _accessor.offset(24); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func v8(at index: Int32) -> Int8 { let o = _accessor.offset(24); return o == 0 ? 0 : _accessor.directRead(of: Int8.self, offset: _accessor.vector(at: o) + index * 1) }
	public var v8: [Int8] { return _accessor.getVector(at: 24) ?? [] }
	public func mutate(v8: Int8, at index: Int32) -> Bool { let o = _accessor.offset(24); return _accessor.directMutate(v8, index: _accessor.vector(at: o) + index * 1) }
	public var vf64Count: Int32 { let o = _accessor.offset(26); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func vf64(at index: Int32) -> Double { let o = _accessor.offset(26); return o == 0 ? 0 : _accessor.directRead(of: Double.self, offset: _accessor.vector(at: o) + index * 8) }
	public var vf64: [Double] { return _accessor.getVector(at: 26) ?? [] }
	public func mutate(vf64: Double, at index: Int32) -> Bool { let o = _accessor.offset(26); return _accessor.directMutate(vf64, index: _accessor.vector(at: o) + index * 8) }
	public static func startTypeAliases(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 12) }
	public static func add(i8: Int8, _ fbb: FlatBufferBuilder) { fbb.add(element: i8, def: 0, at: 0) }
	public static func add(u8: UInt8, _ fbb: FlatBufferBuilder) { fbb.add(element: u8, def: 0, at: 1) }
	public static func add(i16: Int16, _ fbb: FlatBufferBuilder) { fbb.add(element: i16, def: 0, at: 2) }
	public static func add(u16: UInt16, _ fbb: FlatBufferBuilder) { fbb.add(element: u16, def: 0, at: 3) }
	public static func add(i32: Int32, _ fbb: FlatBufferBuilder) { fbb.add(element: i32, def: 0, at: 4) }
	public static func add(u32: UInt32, _ fbb: FlatBufferBuilder) { fbb.add(element: u32, def: 0, at: 5) }
	public static func add(i64: Int64, _ fbb: FlatBufferBuilder) { fbb.add(element: i64, def: 0, at: 6) }
	public static func add(u64: UInt64, _ fbb: FlatBufferBuilder) { fbb.add(element: u64, def: 0, at: 7) }
	public static func add(f32: Float32, _ fbb: FlatBufferBuilder) { fbb.add(element: f32, def: 0.0, at: 8) }
	public static func add(f64: Double, _ fbb: FlatBufferBuilder) { fbb.add(element: f64, def: 0.0, at: 9) }
	public static func addVectorOf(v8: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: v8, at: 10)  }
	public static func addVectorOf(vf64: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: vf64, at: 11)  }
	public static func endTypeAliases(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createTypeAliases(_ fbb: FlatBufferBuilder,
		i8: Int8 = 0,
		u8: UInt8 = 0,
		i16: Int16 = 0,
		u16: UInt16 = 0,
		i32: Int32 = 0,
		u32: UInt32 = 0,
		i64: Int64 = 0,
		u64: UInt64 = 0,
		f32: Float32 = 0.0,
		f64: Double = 0.0,
		vectorOfV8 v8: Offset<UOffset> = Offset(),
		vectorOfVf64 vf64: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = TypeAliases.startTypeAliases(fbb)
		TypeAliases.add(i8: i8, fbb)
		TypeAliases.add(u8: u8, fbb)
		TypeAliases.add(i16: i16, fbb)
		TypeAliases.add(u16: u16, fbb)
		TypeAliases.add(i32: i32, fbb)
		TypeAliases.add(u32: u32, fbb)
		TypeAliases.add(i64: i64, fbb)
		TypeAliases.add(u64: u64, fbb)
		TypeAliases.add(f32: f32, fbb)
		TypeAliases.add(f64: f64, fbb)
		TypeAliases.addVectorOf(v8: v8, fbb)
		TypeAliases.addVectorOf(vf64: vf64, fbb)
		return TypeAliases.endTypeAliases(fbb, start: __start)
	}
}

}

// MARK: - Example


// MARK: - MyGame


