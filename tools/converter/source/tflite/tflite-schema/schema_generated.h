// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_SCHEMA_TFLITE_H_
#define FLATBUFFERS_GENERATED_SCHEMA_TFLITE_H_

#include "flatbuffers/flatbuffers.h"

namespace tflite {

struct CustomQuantization;
struct CustomQuantizationBuilder;
struct CustomQuantizationT;

struct QuantizationParameters;
struct QuantizationParametersBuilder;
struct QuantizationParametersT;

struct Int32Vector;
struct Int32VectorBuilder;
struct Int32VectorT;

struct Uint16Vector;
struct Uint16VectorBuilder;
struct Uint16VectorT;

struct Uint8Vector;
struct Uint8VectorBuilder;
struct Uint8VectorT;

struct DimensionMetadata;
struct DimensionMetadataBuilder;
struct DimensionMetadataT;

struct SparsityParameters;
struct SparsityParametersBuilder;
struct SparsityParametersT;

struct Tensor;
struct TensorBuilder;
struct TensorT;

struct Conv2DOptions;
struct Conv2DOptionsBuilder;
struct Conv2DOptionsT;

struct Pool2DOptions;
struct Pool2DOptionsBuilder;
struct Pool2DOptionsT;

struct DepthwiseConv2DOptions;
struct DepthwiseConv2DOptionsBuilder;
struct DepthwiseConv2DOptionsT;

struct ConcatEmbeddingsOptions;
struct ConcatEmbeddingsOptionsBuilder;
struct ConcatEmbeddingsOptionsT;

struct LSHProjectionOptions;
struct LSHProjectionOptionsBuilder;
struct LSHProjectionOptionsT;

struct SVDFOptions;
struct SVDFOptionsBuilder;
struct SVDFOptionsT;

struct RNNOptions;
struct RNNOptionsBuilder;
struct RNNOptionsT;

struct SequenceRNNOptions;
struct SequenceRNNOptionsBuilder;
struct SequenceRNNOptionsT;

struct BidirectionalSequenceRNNOptions;
struct BidirectionalSequenceRNNOptionsBuilder;
struct BidirectionalSequenceRNNOptionsT;

struct FullyConnectedOptions;
struct FullyConnectedOptionsBuilder;
struct FullyConnectedOptionsT;

struct SoftmaxOptions;
struct SoftmaxOptionsBuilder;
struct SoftmaxOptionsT;

struct ConcatenationOptions;
struct ConcatenationOptionsBuilder;
struct ConcatenationOptionsT;

struct AddOptions;
struct AddOptionsBuilder;
struct AddOptionsT;

struct MulOptions;
struct MulOptionsBuilder;
struct MulOptionsT;

struct L2NormOptions;
struct L2NormOptionsBuilder;
struct L2NormOptionsT;

struct LocalResponseNormalizationOptions;
struct LocalResponseNormalizationOptionsBuilder;
struct LocalResponseNormalizationOptionsT;

struct LSTMOptions;
struct LSTMOptionsBuilder;
struct LSTMOptionsT;

struct UnidirectionalSequenceLSTMOptions;
struct UnidirectionalSequenceLSTMOptionsBuilder;
struct UnidirectionalSequenceLSTMOptionsT;

struct BidirectionalSequenceLSTMOptions;
struct BidirectionalSequenceLSTMOptionsBuilder;
struct BidirectionalSequenceLSTMOptionsT;

struct ResizeBilinearOptions;
struct ResizeBilinearOptionsBuilder;
struct ResizeBilinearOptionsT;

struct ResizeNearestNeighborOptions;
struct ResizeNearestNeighborOptionsBuilder;
struct ResizeNearestNeighborOptionsT;

struct CallOptions;
struct CallOptionsBuilder;
struct CallOptionsT;

struct PadOptions;
struct PadOptionsBuilder;
struct PadOptionsT;

struct PadV2Options;
struct PadV2OptionsBuilder;
struct PadV2OptionsT;

struct ReshapeOptions;
struct ReshapeOptionsBuilder;
struct ReshapeOptionsT;

struct SpaceToBatchNDOptions;
struct SpaceToBatchNDOptionsBuilder;
struct SpaceToBatchNDOptionsT;

struct BatchToSpaceNDOptions;
struct BatchToSpaceNDOptionsBuilder;
struct BatchToSpaceNDOptionsT;

struct SkipGramOptions;
struct SkipGramOptionsBuilder;
struct SkipGramOptionsT;

struct SpaceToDepthOptions;
struct SpaceToDepthOptionsBuilder;
struct SpaceToDepthOptionsT;

struct DepthToSpaceOptions;
struct DepthToSpaceOptionsBuilder;
struct DepthToSpaceOptionsT;

struct SubOptions;
struct SubOptionsBuilder;
struct SubOptionsT;

struct DivOptions;
struct DivOptionsBuilder;
struct DivOptionsT;

struct TopKV2Options;
struct TopKV2OptionsBuilder;
struct TopKV2OptionsT;

struct EmbeddingLookupSparseOptions;
struct EmbeddingLookupSparseOptionsBuilder;
struct EmbeddingLookupSparseOptionsT;

struct GatherOptions;
struct GatherOptionsBuilder;
struct GatherOptionsT;

struct TransposeOptions;
struct TransposeOptionsBuilder;
struct TransposeOptionsT;

struct ExpOptions;
struct ExpOptionsBuilder;
struct ExpOptionsT;

struct CosOptions;
struct CosOptionsBuilder;
struct CosOptionsT;

struct ReducerOptions;
struct ReducerOptionsBuilder;
struct ReducerOptionsT;

struct SqueezeOptions;
struct SqueezeOptionsBuilder;
struct SqueezeOptionsT;

struct SplitOptions;
struct SplitOptionsBuilder;
struct SplitOptionsT;

struct SplitVOptions;
struct SplitVOptionsBuilder;
struct SplitVOptionsT;

struct StridedSliceOptions;
struct StridedSliceOptionsBuilder;
struct StridedSliceOptionsT;

struct LogSoftmaxOptions;
struct LogSoftmaxOptionsBuilder;
struct LogSoftmaxOptionsT;

struct CastOptions;
struct CastOptionsBuilder;
struct CastOptionsT;

struct DequantizeOptions;
struct DequantizeOptionsBuilder;
struct DequantizeOptionsT;

struct MaximumMinimumOptions;
struct MaximumMinimumOptionsBuilder;
struct MaximumMinimumOptionsT;

struct TileOptions;
struct TileOptionsBuilder;
struct TileOptionsT;

struct ArgMaxOptions;
struct ArgMaxOptionsBuilder;
struct ArgMaxOptionsT;

struct ArgMinOptions;
struct ArgMinOptionsBuilder;
struct ArgMinOptionsT;

struct GreaterOptions;
struct GreaterOptionsBuilder;
struct GreaterOptionsT;

struct GreaterEqualOptions;
struct GreaterEqualOptionsBuilder;
struct GreaterEqualOptionsT;

struct LessOptions;
struct LessOptionsBuilder;
struct LessOptionsT;

struct LessEqualOptions;
struct LessEqualOptionsBuilder;
struct LessEqualOptionsT;

struct NegOptions;
struct NegOptionsBuilder;
struct NegOptionsT;

struct SelectOptions;
struct SelectOptionsBuilder;
struct SelectOptionsT;

struct SliceOptions;
struct SliceOptionsBuilder;
struct SliceOptionsT;

struct TransposeConvOptions;
struct TransposeConvOptionsBuilder;
struct TransposeConvOptionsT;

struct ExpandDimsOptions;
struct ExpandDimsOptionsBuilder;
struct ExpandDimsOptionsT;

struct SparseToDenseOptions;
struct SparseToDenseOptionsBuilder;
struct SparseToDenseOptionsT;

struct EqualOptions;
struct EqualOptionsBuilder;
struct EqualOptionsT;

struct NotEqualOptions;
struct NotEqualOptionsBuilder;
struct NotEqualOptionsT;

struct ShapeOptions;
struct ShapeOptionsBuilder;
struct ShapeOptionsT;

struct RankOptions;
struct RankOptionsBuilder;
struct RankOptionsT;

struct PowOptions;
struct PowOptionsBuilder;
struct PowOptionsT;

struct FakeQuantOptions;
struct FakeQuantOptionsBuilder;
struct FakeQuantOptionsT;

struct PackOptions;
struct PackOptionsBuilder;
struct PackOptionsT;

struct LogicalOrOptions;
struct LogicalOrOptionsBuilder;
struct LogicalOrOptionsT;

struct OneHotOptions;
struct OneHotOptionsBuilder;
struct OneHotOptionsT;

struct AbsOptions;
struct AbsOptionsBuilder;
struct AbsOptionsT;

struct HardSwishOptions;
struct HardSwishOptionsBuilder;
struct HardSwishOptionsT;

struct LogicalAndOptions;
struct LogicalAndOptionsBuilder;
struct LogicalAndOptionsT;

struct LogicalNotOptions;
struct LogicalNotOptionsBuilder;
struct LogicalNotOptionsT;

struct UnpackOptions;
struct UnpackOptionsBuilder;
struct UnpackOptionsT;

struct FloorDivOptions;
struct FloorDivOptionsBuilder;
struct FloorDivOptionsT;

struct SquareOptions;
struct SquareOptionsBuilder;
struct SquareOptionsT;

struct ZerosLikeOptions;
struct ZerosLikeOptionsBuilder;
struct ZerosLikeOptionsT;

struct FillOptions;
struct FillOptionsBuilder;
struct FillOptionsT;

struct FloorModOptions;
struct FloorModOptionsBuilder;
struct FloorModOptionsT;

struct RangeOptions;
struct RangeOptionsBuilder;
struct RangeOptionsT;

struct LeakyReluOptions;
struct LeakyReluOptionsBuilder;
struct LeakyReluOptionsT;

struct SquaredDifferenceOptions;
struct SquaredDifferenceOptionsBuilder;
struct SquaredDifferenceOptionsT;

struct MirrorPadOptions;
struct MirrorPadOptionsBuilder;
struct MirrorPadOptionsT;

struct UniqueOptions;
struct UniqueOptionsBuilder;
struct UniqueOptionsT;

struct ReverseV2Options;
struct ReverseV2OptionsBuilder;
struct ReverseV2OptionsT;

struct AddNOptions;
struct AddNOptionsBuilder;
struct AddNOptionsT;

struct GatherNdOptions;
struct GatherNdOptionsBuilder;
struct GatherNdOptionsT;

struct WhereOptions;
struct WhereOptionsBuilder;
struct WhereOptionsT;

struct ReverseSequenceOptions;
struct ReverseSequenceOptionsBuilder;
struct ReverseSequenceOptionsT;

struct MatrixDiagOptions;
struct MatrixDiagOptionsBuilder;
struct MatrixDiagOptionsT;

struct QuantizeOptions;
struct QuantizeOptionsBuilder;
struct QuantizeOptionsT;

struct MatrixSetDiagOptions;
struct MatrixSetDiagOptionsBuilder;
struct MatrixSetDiagOptionsT;

struct IfOptions;
struct IfOptionsBuilder;
struct IfOptionsT;

struct WhileOptions;
struct WhileOptionsBuilder;
struct WhileOptionsT;

struct NonMaxSuppressionV4Options;
struct NonMaxSuppressionV4OptionsBuilder;
struct NonMaxSuppressionV4OptionsT;

struct NonMaxSuppressionV5Options;
struct NonMaxSuppressionV5OptionsBuilder;
struct NonMaxSuppressionV5OptionsT;

struct ScatterNdOptions;
struct ScatterNdOptionsBuilder;
struct ScatterNdOptionsT;

struct SelectV2Options;
struct SelectV2OptionsBuilder;
struct SelectV2OptionsT;

struct DensifyOptions;
struct DensifyOptionsBuilder;
struct DensifyOptionsT;

struct SegmentSumOptions;
struct SegmentSumOptionsBuilder;
struct SegmentSumOptionsT;

struct BatchMatMulOptions;
struct BatchMatMulOptionsBuilder;
struct BatchMatMulOptionsT;

struct OperatorCode;
struct OperatorCodeBuilder;
struct OperatorCodeT;

struct Operator;
struct OperatorBuilder;
struct OperatorT;

struct SubGraph;
struct SubGraphBuilder;
struct SubGraphT;

struct Buffer;
struct BufferBuilder;
struct BufferT;

struct Metadata;
struct MetadataBuilder;
struct MetadataT;

struct Model;
struct ModelBuilder;
struct ModelT;

inline const flatbuffers::TypeTable *CustomQuantizationTypeTable();

inline const flatbuffers::TypeTable *QuantizationParametersTypeTable();

inline const flatbuffers::TypeTable *Int32VectorTypeTable();

inline const flatbuffers::TypeTable *Uint16VectorTypeTable();

inline const flatbuffers::TypeTable *Uint8VectorTypeTable();

inline const flatbuffers::TypeTable *DimensionMetadataTypeTable();

inline const flatbuffers::TypeTable *SparsityParametersTypeTable();

inline const flatbuffers::TypeTable *TensorTypeTable();

inline const flatbuffers::TypeTable *Conv2DOptionsTypeTable();

inline const flatbuffers::TypeTable *Pool2DOptionsTypeTable();

inline const flatbuffers::TypeTable *DepthwiseConv2DOptionsTypeTable();

inline const flatbuffers::TypeTable *ConcatEmbeddingsOptionsTypeTable();

inline const flatbuffers::TypeTable *LSHProjectionOptionsTypeTable();

inline const flatbuffers::TypeTable *SVDFOptionsTypeTable();

inline const flatbuffers::TypeTable *RNNOptionsTypeTable();

inline const flatbuffers::TypeTable *SequenceRNNOptionsTypeTable();

inline const flatbuffers::TypeTable *BidirectionalSequenceRNNOptionsTypeTable();

inline const flatbuffers::TypeTable *FullyConnectedOptionsTypeTable();

inline const flatbuffers::TypeTable *SoftmaxOptionsTypeTable();

inline const flatbuffers::TypeTable *ConcatenationOptionsTypeTable();

inline const flatbuffers::TypeTable *AddOptionsTypeTable();

inline const flatbuffers::TypeTable *MulOptionsTypeTable();

inline const flatbuffers::TypeTable *L2NormOptionsTypeTable();

inline const flatbuffers::TypeTable *LocalResponseNormalizationOptionsTypeTable();

inline const flatbuffers::TypeTable *LSTMOptionsTypeTable();

inline const flatbuffers::TypeTable *UnidirectionalSequenceLSTMOptionsTypeTable();

inline const flatbuffers::TypeTable *BidirectionalSequenceLSTMOptionsTypeTable();

inline const flatbuffers::TypeTable *ResizeBilinearOptionsTypeTable();

inline const flatbuffers::TypeTable *ResizeNearestNeighborOptionsTypeTable();

inline const flatbuffers::TypeTable *CallOptionsTypeTable();

inline const flatbuffers::TypeTable *PadOptionsTypeTable();

inline const flatbuffers::TypeTable *PadV2OptionsTypeTable();

inline const flatbuffers::TypeTable *ReshapeOptionsTypeTable();

inline const flatbuffers::TypeTable *SpaceToBatchNDOptionsTypeTable();

inline const flatbuffers::TypeTable *BatchToSpaceNDOptionsTypeTable();

inline const flatbuffers::TypeTable *SkipGramOptionsTypeTable();

inline const flatbuffers::TypeTable *SpaceToDepthOptionsTypeTable();

inline const flatbuffers::TypeTable *DepthToSpaceOptionsTypeTable();

inline const flatbuffers::TypeTable *SubOptionsTypeTable();

inline const flatbuffers::TypeTable *DivOptionsTypeTable();

inline const flatbuffers::TypeTable *TopKV2OptionsTypeTable();

inline const flatbuffers::TypeTable *EmbeddingLookupSparseOptionsTypeTable();

inline const flatbuffers::TypeTable *GatherOptionsTypeTable();

inline const flatbuffers::TypeTable *TransposeOptionsTypeTable();

inline const flatbuffers::TypeTable *ExpOptionsTypeTable();

inline const flatbuffers::TypeTable *CosOptionsTypeTable();

inline const flatbuffers::TypeTable *ReducerOptionsTypeTable();

inline const flatbuffers::TypeTable *SqueezeOptionsTypeTable();

inline const flatbuffers::TypeTable *SplitOptionsTypeTable();

inline const flatbuffers::TypeTable *SplitVOptionsTypeTable();

inline const flatbuffers::TypeTable *StridedSliceOptionsTypeTable();

inline const flatbuffers::TypeTable *LogSoftmaxOptionsTypeTable();

inline const flatbuffers::TypeTable *CastOptionsTypeTable();

inline const flatbuffers::TypeTable *DequantizeOptionsTypeTable();

inline const flatbuffers::TypeTable *MaximumMinimumOptionsTypeTable();

inline const flatbuffers::TypeTable *TileOptionsTypeTable();

inline const flatbuffers::TypeTable *ArgMaxOptionsTypeTable();

inline const flatbuffers::TypeTable *ArgMinOptionsTypeTable();

inline const flatbuffers::TypeTable *GreaterOptionsTypeTable();

inline const flatbuffers::TypeTable *GreaterEqualOptionsTypeTable();

inline const flatbuffers::TypeTable *LessOptionsTypeTable();

inline const flatbuffers::TypeTable *LessEqualOptionsTypeTable();

inline const flatbuffers::TypeTable *NegOptionsTypeTable();

inline const flatbuffers::TypeTable *SelectOptionsTypeTable();

inline const flatbuffers::TypeTable *SliceOptionsTypeTable();

inline const flatbuffers::TypeTable *TransposeConvOptionsTypeTable();

inline const flatbuffers::TypeTable *ExpandDimsOptionsTypeTable();

inline const flatbuffers::TypeTable *SparseToDenseOptionsTypeTable();

inline const flatbuffers::TypeTable *EqualOptionsTypeTable();

inline const flatbuffers::TypeTable *NotEqualOptionsTypeTable();

inline const flatbuffers::TypeTable *ShapeOptionsTypeTable();

inline const flatbuffers::TypeTable *RankOptionsTypeTable();

inline const flatbuffers::TypeTable *PowOptionsTypeTable();

inline const flatbuffers::TypeTable *FakeQuantOptionsTypeTable();

inline const flatbuffers::TypeTable *PackOptionsTypeTable();

inline const flatbuffers::TypeTable *LogicalOrOptionsTypeTable();

inline const flatbuffers::TypeTable *OneHotOptionsTypeTable();

inline const flatbuffers::TypeTable *AbsOptionsTypeTable();

inline const flatbuffers::TypeTable *HardSwishOptionsTypeTable();

inline const flatbuffers::TypeTable *LogicalAndOptionsTypeTable();

inline const flatbuffers::TypeTable *LogicalNotOptionsTypeTable();

inline const flatbuffers::TypeTable *UnpackOptionsTypeTable();

inline const flatbuffers::TypeTable *FloorDivOptionsTypeTable();

inline const flatbuffers::TypeTable *SquareOptionsTypeTable();

inline const flatbuffers::TypeTable *ZerosLikeOptionsTypeTable();

inline const flatbuffers::TypeTable *FillOptionsTypeTable();

inline const flatbuffers::TypeTable *FloorModOptionsTypeTable();

inline const flatbuffers::TypeTable *RangeOptionsTypeTable();

inline const flatbuffers::TypeTable *LeakyReluOptionsTypeTable();

inline const flatbuffers::TypeTable *SquaredDifferenceOptionsTypeTable();

inline const flatbuffers::TypeTable *MirrorPadOptionsTypeTable();

inline const flatbuffers::TypeTable *UniqueOptionsTypeTable();

inline const flatbuffers::TypeTable *ReverseV2OptionsTypeTable();

inline const flatbuffers::TypeTable *AddNOptionsTypeTable();

inline const flatbuffers::TypeTable *GatherNdOptionsTypeTable();

inline const flatbuffers::TypeTable *WhereOptionsTypeTable();

inline const flatbuffers::TypeTable *ReverseSequenceOptionsTypeTable();

inline const flatbuffers::TypeTable *MatrixDiagOptionsTypeTable();

inline const flatbuffers::TypeTable *QuantizeOptionsTypeTable();

inline const flatbuffers::TypeTable *MatrixSetDiagOptionsTypeTable();

inline const flatbuffers::TypeTable *IfOptionsTypeTable();

inline const flatbuffers::TypeTable *WhileOptionsTypeTable();

inline const flatbuffers::TypeTable *NonMaxSuppressionV4OptionsTypeTable();

inline const flatbuffers::TypeTable *NonMaxSuppressionV5OptionsTypeTable();

inline const flatbuffers::TypeTable *ScatterNdOptionsTypeTable();

inline const flatbuffers::TypeTable *SelectV2OptionsTypeTable();

inline const flatbuffers::TypeTable *DensifyOptionsTypeTable();

inline const flatbuffers::TypeTable *SegmentSumOptionsTypeTable();

inline const flatbuffers::TypeTable *BatchMatMulOptionsTypeTable();

inline const flatbuffers::TypeTable *OperatorCodeTypeTable();

inline const flatbuffers::TypeTable *OperatorTypeTable();

inline const flatbuffers::TypeTable *SubGraphTypeTable();

inline const flatbuffers::TypeTable *BufferTypeTable();

inline const flatbuffers::TypeTable *MetadataTypeTable();

inline const flatbuffers::TypeTable *ModelTypeTable();

enum TensorType {
    TensorType_FLOAT32    = 0,
    TensorType_FLOAT16    = 1,
    TensorType_INT32      = 2,
    TensorType_UINT8      = 3,
    TensorType_INT64      = 4,
    TensorType_STRING     = 5,
    TensorType_BOOL       = 6,
    TensorType_INT16      = 7,
    TensorType_COMPLEX64  = 8,
    TensorType_INT8       = 9,
    TensorType_FLOAT64    = 10,
    TensorType_COMPLEX128 = 11,
    TensorType_MIN        = TensorType_FLOAT32,
    TensorType_MAX        = TensorType_COMPLEX128
};

inline const TensorType (&EnumValuesTensorType())[12] {
    static const TensorType values[] = {TensorType_FLOAT32, TensorType_FLOAT16, TensorType_INT32,
                                        TensorType_UINT8,   TensorType_INT64,   TensorType_STRING,
                                        TensorType_BOOL,    TensorType_INT16,   TensorType_COMPLEX64,
                                        TensorType_INT8,    TensorType_FLOAT64, TensorType_COMPLEX128};
    return values;
}

inline const char *const *EnumNamesTensorType() {
    static const char *const names[13] = {"FLOAT32", "FLOAT16",   "INT32", "UINT8",   "INT64",      "STRING", "BOOL",
                                          "INT16",   "COMPLEX64", "INT8",  "FLOAT64", "COMPLEX128", nullptr};
    return names;
}

inline const char *EnumNameTensorType(TensorType e) {
    if (flatbuffers::IsOutRange(e, TensorType_FLOAT32, TensorType_COMPLEX128))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesTensorType()[index];
}

enum QuantizationDetails {
    QuantizationDetails_NONE               = 0,
    QuantizationDetails_CustomQuantization = 1,
    QuantizationDetails_MIN                = QuantizationDetails_NONE,
    QuantizationDetails_MAX                = QuantizationDetails_CustomQuantization
};

inline const QuantizationDetails (&EnumValuesQuantizationDetails())[2] {
    static const QuantizationDetails values[] = {QuantizationDetails_NONE, QuantizationDetails_CustomQuantization};
    return values;
}

inline const char *const *EnumNamesQuantizationDetails() {
    static const char *const names[3] = {"NONE", "CustomQuantization", nullptr};
    return names;
}

inline const char *EnumNameQuantizationDetails(QuantizationDetails e) {
    if (flatbuffers::IsOutRange(e, QuantizationDetails_NONE, QuantizationDetails_CustomQuantization))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesQuantizationDetails()[index];
}

template <typename T>
struct QuantizationDetailsTraits {
    static const QuantizationDetails enum_value = QuantizationDetails_NONE;
};

template <>
struct QuantizationDetailsTraits<tflite::CustomQuantization> {
    static const QuantizationDetails enum_value = QuantizationDetails_CustomQuantization;
};

struct QuantizationDetailsUnion {
    QuantizationDetails type;
    void *value;

    QuantizationDetailsUnion() : type(QuantizationDetails_NONE), value(nullptr) {}
    QuantizationDetailsUnion(QuantizationDetailsUnion &&u) FLATBUFFERS_NOEXCEPT : type(QuantizationDetails_NONE),
                                                                                  value(nullptr) {
        std::swap(type, u.type);
        std::swap(value, u.value);
    }
    QuantizationDetailsUnion(const QuantizationDetailsUnion &);
    QuantizationDetailsUnion &operator=(const QuantizationDetailsUnion &u) {
        QuantizationDetailsUnion t(u);
        std::swap(type, t.type);
        std::swap(value, t.value);
        return *this;
    }
    QuantizationDetailsUnion &operator=(QuantizationDetailsUnion &&u) FLATBUFFERS_NOEXCEPT {
        std::swap(type, u.type);
        std::swap(value, u.value);
        return *this;
    }
    ~QuantizationDetailsUnion() {
        Reset();
    }

    void Reset();

#ifndef FLATBUFFERS_CPP98_STL
    template <typename T>
    void Set(T &&val) {
        using RT = typename std::remove_reference<T>::type;
        Reset();
        type = QuantizationDetailsTraits<typename RT::TableType>::enum_value;
        if (type != QuantizationDetails_NONE) {
            value = new RT(std::forward<T>(val));
        }
    }
#endif  // FLATBUFFERS_CPP98_STL

    static void *UnPack(const void *obj, QuantizationDetails type, const flatbuffers::resolver_function_t *resolver);
    flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

    tflite::CustomQuantizationT *AsCustomQuantization() {
        return type == QuantizationDetails_CustomQuantization ? reinterpret_cast<tflite::CustomQuantizationT *>(value)
                                                              : nullptr;
    }
    const tflite::CustomQuantizationT *AsCustomQuantization() const {
        return type == QuantizationDetails_CustomQuantization
                   ? reinterpret_cast<const tflite::CustomQuantizationT *>(value)
                   : nullptr;
    }
};

bool VerifyQuantizationDetails(flatbuffers::Verifier &verifier, const void *obj, QuantizationDetails type);
bool VerifyQuantizationDetailsVector(flatbuffers::Verifier &verifier,
                                     const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                                     const flatbuffers::Vector<uint8_t> *types);

enum DimensionType {
    DimensionType_DENSE      = 0,
    DimensionType_SPARSE_CSR = 1,
    DimensionType_MIN        = DimensionType_DENSE,
    DimensionType_MAX        = DimensionType_SPARSE_CSR
};

inline const DimensionType (&EnumValuesDimensionType())[2] {
    static const DimensionType values[] = {DimensionType_DENSE, DimensionType_SPARSE_CSR};
    return values;
}

inline const char *const *EnumNamesDimensionType() {
    static const char *const names[3] = {"DENSE", "SPARSE_CSR", nullptr};
    return names;
}

inline const char *EnumNameDimensionType(DimensionType e) {
    if (flatbuffers::IsOutRange(e, DimensionType_DENSE, DimensionType_SPARSE_CSR))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesDimensionType()[index];
}

enum SparseIndexVector {
    SparseIndexVector_NONE         = 0,
    SparseIndexVector_Int32Vector  = 1,
    SparseIndexVector_Uint16Vector = 2,
    SparseIndexVector_Uint8Vector  = 3,
    SparseIndexVector_MIN          = SparseIndexVector_NONE,
    SparseIndexVector_MAX          = SparseIndexVector_Uint8Vector
};

inline const SparseIndexVector (&EnumValuesSparseIndexVector())[4] {
    static const SparseIndexVector values[] = {SparseIndexVector_NONE, SparseIndexVector_Int32Vector,
                                               SparseIndexVector_Uint16Vector, SparseIndexVector_Uint8Vector};
    return values;
}

inline const char *const *EnumNamesSparseIndexVector() {
    static const char *const names[5] = {"NONE", "Int32Vector", "Uint16Vector", "Uint8Vector", nullptr};
    return names;
}

inline const char *EnumNameSparseIndexVector(SparseIndexVector e) {
    if (flatbuffers::IsOutRange(e, SparseIndexVector_NONE, SparseIndexVector_Uint8Vector))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesSparseIndexVector()[index];
}

template <typename T>
struct SparseIndexVectorTraits {
    static const SparseIndexVector enum_value = SparseIndexVector_NONE;
};

template <>
struct SparseIndexVectorTraits<tflite::Int32Vector> {
    static const SparseIndexVector enum_value = SparseIndexVector_Int32Vector;
};

template <>
struct SparseIndexVectorTraits<tflite::Uint16Vector> {
    static const SparseIndexVector enum_value = SparseIndexVector_Uint16Vector;
};

template <>
struct SparseIndexVectorTraits<tflite::Uint8Vector> {
    static const SparseIndexVector enum_value = SparseIndexVector_Uint8Vector;
};

struct SparseIndexVectorUnion {
    SparseIndexVector type;
    void *value;

    SparseIndexVectorUnion() : type(SparseIndexVector_NONE), value(nullptr) {}
    SparseIndexVectorUnion(SparseIndexVectorUnion &&u) FLATBUFFERS_NOEXCEPT : type(SparseIndexVector_NONE),
                                                                              value(nullptr) {
        std::swap(type, u.type);
        std::swap(value, u.value);
    }
    SparseIndexVectorUnion(const SparseIndexVectorUnion &);
    SparseIndexVectorUnion &operator=(const SparseIndexVectorUnion &u) {
        SparseIndexVectorUnion t(u);
        std::swap(type, t.type);
        std::swap(value, t.value);
        return *this;
    }
    SparseIndexVectorUnion &operator=(SparseIndexVectorUnion &&u) FLATBUFFERS_NOEXCEPT {
        std::swap(type, u.type);
        std::swap(value, u.value);
        return *this;
    }
    ~SparseIndexVectorUnion() {
        Reset();
    }

    void Reset();

#ifndef FLATBUFFERS_CPP98_STL
    template <typename T>
    void Set(T &&val) {
        using RT = typename std::remove_reference<T>::type;
        Reset();
        type = SparseIndexVectorTraits<typename RT::TableType>::enum_value;
        if (type != SparseIndexVector_NONE) {
            value = new RT(std::forward<T>(val));
        }
    }
#endif  // FLATBUFFERS_CPP98_STL

    static void *UnPack(const void *obj, SparseIndexVector type, const flatbuffers::resolver_function_t *resolver);
    flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

    tflite::Int32VectorT *AsInt32Vector() {
        return type == SparseIndexVector_Int32Vector ? reinterpret_cast<tflite::Int32VectorT *>(value) : nullptr;
    }
    const tflite::Int32VectorT *AsInt32Vector() const {
        return type == SparseIndexVector_Int32Vector ? reinterpret_cast<const tflite::Int32VectorT *>(value) : nullptr;
    }
    tflite::Uint16VectorT *AsUint16Vector() {
        return type == SparseIndexVector_Uint16Vector ? reinterpret_cast<tflite::Uint16VectorT *>(value) : nullptr;
    }
    const tflite::Uint16VectorT *AsUint16Vector() const {
        return type == SparseIndexVector_Uint16Vector ? reinterpret_cast<const tflite::Uint16VectorT *>(value)
                                                      : nullptr;
    }
    tflite::Uint8VectorT *AsUint8Vector() {
        return type == SparseIndexVector_Uint8Vector ? reinterpret_cast<tflite::Uint8VectorT *>(value) : nullptr;
    }
    const tflite::Uint8VectorT *AsUint8Vector() const {
        return type == SparseIndexVector_Uint8Vector ? reinterpret_cast<const tflite::Uint8VectorT *>(value) : nullptr;
    }
};

bool VerifySparseIndexVector(flatbuffers::Verifier &verifier, const void *obj, SparseIndexVector type);
bool VerifySparseIndexVectorVector(flatbuffers::Verifier &verifier,
                                   const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                                   const flatbuffers::Vector<uint8_t> *types);

enum BuiltinOperator {
    BuiltinOperator_ADD                          = 0,
    BuiltinOperator_AVERAGE_POOL_2D              = 1,
    BuiltinOperator_CONCATENATION                = 2,
    BuiltinOperator_CONV_2D                      = 3,
    BuiltinOperator_DEPTHWISE_CONV_2D            = 4,
    BuiltinOperator_DEPTH_TO_SPACE               = 5,
    BuiltinOperator_DEQUANTIZE                   = 6,
    BuiltinOperator_EMBEDDING_LOOKUP             = 7,
    BuiltinOperator_FLOOR                        = 8,
    BuiltinOperator_FULLY_CONNECTED              = 9,
    BuiltinOperator_HASHTABLE_LOOKUP             = 10,
    BuiltinOperator_L2_NORMALIZATION             = 11,
    BuiltinOperator_L2_POOL_2D                   = 12,
    BuiltinOperator_LOCAL_RESPONSE_NORMALIZATION = 13,
    BuiltinOperator_LOGISTIC                     = 14,
    BuiltinOperator_LSH_PROJECTION               = 15,
    BuiltinOperator_LSTM                         = 16,
    BuiltinOperator_MAX_POOL_2D                  = 17,
    BuiltinOperator_MUL                          = 18,
    BuiltinOperator_RELU                         = 19,
    BuiltinOperator_RELU_N1_TO_1                 = 20,
    BuiltinOperator_RELU6                        = 21,
    BuiltinOperator_RESHAPE                      = 22,
    BuiltinOperator_RESIZE_BILINEAR              = 23,
    BuiltinOperator_RNN                          = 24,
    BuiltinOperator_SOFTMAX                      = 25,
    BuiltinOperator_SPACE_TO_DEPTH               = 26,
    BuiltinOperator_SVDF                         = 27,
    BuiltinOperator_TANH                         = 28,
    BuiltinOperator_CONCAT_EMBEDDINGS            = 29,
    BuiltinOperator_SKIP_GRAM                    = 30,
    BuiltinOperator_CALL                         = 31,
    BuiltinOperator_CUSTOM                       = 32,
    BuiltinOperator_EMBEDDING_LOOKUP_SPARSE      = 33,
    BuiltinOperator_PAD                          = 34,
    BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_RNN  = 35,
    BuiltinOperator_GATHER                       = 36,
    BuiltinOperator_BATCH_TO_SPACE_ND            = 37,
    BuiltinOperator_SPACE_TO_BATCH_ND            = 38,
    BuiltinOperator_TRANSPOSE                    = 39,
    BuiltinOperator_MEAN                         = 40,
    BuiltinOperator_SUB                          = 41,
    BuiltinOperator_DIV                          = 42,
    BuiltinOperator_SQUEEZE                      = 43,
    BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_LSTM = 44,
    BuiltinOperator_STRIDED_SLICE                = 45,
    BuiltinOperator_BIDIRECTIONAL_SEQUENCE_RNN   = 46,
    BuiltinOperator_EXP                          = 47,
    BuiltinOperator_TOPK_V2                      = 48,
    BuiltinOperator_SPLIT                        = 49,
    BuiltinOperator_LOG_SOFTMAX                  = 50,
    BuiltinOperator_DELEGATE                     = 51,
    BuiltinOperator_BIDIRECTIONAL_SEQUENCE_LSTM  = 52,
    BuiltinOperator_CAST                         = 53,
    BuiltinOperator_PRELU                        = 54,
    BuiltinOperator_MAXIMUM                      = 55,
    BuiltinOperator_ARG_MAX                      = 56,
    BuiltinOperator_MINIMUM                      = 57,
    BuiltinOperator_LESS                         = 58,
    BuiltinOperator_NEG                          = 59,
    BuiltinOperator_PADV2                        = 60,
    BuiltinOperator_GREATER                      = 61,
    BuiltinOperator_GREATER_EQUAL                = 62,
    BuiltinOperator_LESS_EQUAL                   = 63,
    BuiltinOperator_SELECT                       = 64,
    BuiltinOperator_SLICE                        = 65,
    BuiltinOperator_SIN                          = 66,
    BuiltinOperator_TRANSPOSE_CONV               = 67,
    BuiltinOperator_SPARSE_TO_DENSE              = 68,
    BuiltinOperator_TILE                         = 69,
    BuiltinOperator_EXPAND_DIMS                  = 70,
    BuiltinOperator_EQUAL                        = 71,
    BuiltinOperator_NOT_EQUAL                    = 72,
    BuiltinOperator_LOG                          = 73,
    BuiltinOperator_SUM                          = 74,
    BuiltinOperator_SQRT                         = 75,
    BuiltinOperator_RSQRT                        = 76,
    BuiltinOperator_SHAPE                        = 77,
    BuiltinOperator_POW                          = 78,
    BuiltinOperator_ARG_MIN                      = 79,
    BuiltinOperator_FAKE_QUANT                   = 80,
    BuiltinOperator_REDUCE_PROD                  = 81,
    BuiltinOperator_REDUCE_MAX                   = 82,
    BuiltinOperator_PACK                         = 83,
    BuiltinOperator_LOGICAL_OR                   = 84,
    BuiltinOperator_ONE_HOT                      = 85,
    BuiltinOperator_LOGICAL_AND                  = 86,
    BuiltinOperator_LOGICAL_NOT                  = 87,
    BuiltinOperator_UNPACK                       = 88,
    BuiltinOperator_REDUCE_MIN                   = 89,
    BuiltinOperator_FLOOR_DIV                    = 90,
    BuiltinOperator_REDUCE_ANY                   = 91,
    BuiltinOperator_SQUARE                       = 92,
    BuiltinOperator_ZEROS_LIKE                   = 93,
    BuiltinOperator_FILL                         = 94,
    BuiltinOperator_FLOOR_MOD                    = 95,
    BuiltinOperator_RANGE                        = 96,
    BuiltinOperator_RESIZE_NEAREST_NEIGHBOR      = 97,
    BuiltinOperator_LEAKY_RELU                   = 98,
    BuiltinOperator_SQUARED_DIFFERENCE           = 99,
    BuiltinOperator_MIRROR_PAD                   = 100,
    BuiltinOperator_ABS                          = 101,
    BuiltinOperator_SPLIT_V                      = 102,
    BuiltinOperator_UNIQUE                       = 103,
    BuiltinOperator_CEIL                         = 104,
    BuiltinOperator_REVERSE_V2                   = 105,
    BuiltinOperator_ADD_N                        = 106,
    BuiltinOperator_GATHER_ND                    = 107,
    BuiltinOperator_COS                          = 108,
    BuiltinOperator_WHERE                        = 109,
    BuiltinOperator_RANK                         = 110,
    BuiltinOperator_ELU                          = 111,
    BuiltinOperator_REVERSE_SEQUENCE             = 112,
    BuiltinOperator_MATRIX_DIAG                  = 113,
    BuiltinOperator_QUANTIZE                     = 114,
    BuiltinOperator_MATRIX_SET_DIAG              = 115,
    BuiltinOperator_ROUND                        = 116,
    BuiltinOperator_HARD_SWISH                   = 117,
    BuiltinOperator_IF                           = 118,
    BuiltinOperator_WHILE                        = 119,
    BuiltinOperator_NON_MAX_SUPPRESSION_V4       = 120,
    BuiltinOperator_NON_MAX_SUPPRESSION_V5       = 121,
    BuiltinOperator_SCATTER_ND                   = 122,
    BuiltinOperator_SELECT_V2                    = 123,
    BuiltinOperator_DENSIFY                      = 124,
    BuiltinOperator_SEGMENT_SUM                  = 125,
    BuiltinOperator_BATCH_MATMUL                 = 126,
    BuiltinOperator_MIN                          = BuiltinOperator_ADD,
    BuiltinOperator_MAX                          = BuiltinOperator_BATCH_MATMUL
};

inline const BuiltinOperator (&EnumValuesBuiltinOperator())[127] {
    static const BuiltinOperator values[] = {BuiltinOperator_ADD,
                                             BuiltinOperator_AVERAGE_POOL_2D,
                                             BuiltinOperator_CONCATENATION,
                                             BuiltinOperator_CONV_2D,
                                             BuiltinOperator_DEPTHWISE_CONV_2D,
                                             BuiltinOperator_DEPTH_TO_SPACE,
                                             BuiltinOperator_DEQUANTIZE,
                                             BuiltinOperator_EMBEDDING_LOOKUP,
                                             BuiltinOperator_FLOOR,
                                             BuiltinOperator_FULLY_CONNECTED,
                                             BuiltinOperator_HASHTABLE_LOOKUP,
                                             BuiltinOperator_L2_NORMALIZATION,
                                             BuiltinOperator_L2_POOL_2D,
                                             BuiltinOperator_LOCAL_RESPONSE_NORMALIZATION,
                                             BuiltinOperator_LOGISTIC,
                                             BuiltinOperator_LSH_PROJECTION,
                                             BuiltinOperator_LSTM,
                                             BuiltinOperator_MAX_POOL_2D,
                                             BuiltinOperator_MUL,
                                             BuiltinOperator_RELU,
                                             BuiltinOperator_RELU_N1_TO_1,
                                             BuiltinOperator_RELU6,
                                             BuiltinOperator_RESHAPE,
                                             BuiltinOperator_RESIZE_BILINEAR,
                                             BuiltinOperator_RNN,
                                             BuiltinOperator_SOFTMAX,
                                             BuiltinOperator_SPACE_TO_DEPTH,
                                             BuiltinOperator_SVDF,
                                             BuiltinOperator_TANH,
                                             BuiltinOperator_CONCAT_EMBEDDINGS,
                                             BuiltinOperator_SKIP_GRAM,
                                             BuiltinOperator_CALL,
                                             BuiltinOperator_CUSTOM,
                                             BuiltinOperator_EMBEDDING_LOOKUP_SPARSE,
                                             BuiltinOperator_PAD,
                                             BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_RNN,
                                             BuiltinOperator_GATHER,
                                             BuiltinOperator_BATCH_TO_SPACE_ND,
                                             BuiltinOperator_SPACE_TO_BATCH_ND,
                                             BuiltinOperator_TRANSPOSE,
                                             BuiltinOperator_MEAN,
                                             BuiltinOperator_SUB,
                                             BuiltinOperator_DIV,
                                             BuiltinOperator_SQUEEZE,
                                             BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_LSTM,
                                             BuiltinOperator_STRIDED_SLICE,
                                             BuiltinOperator_BIDIRECTIONAL_SEQUENCE_RNN,
                                             BuiltinOperator_EXP,
                                             BuiltinOperator_TOPK_V2,
                                             BuiltinOperator_SPLIT,
                                             BuiltinOperator_LOG_SOFTMAX,
                                             BuiltinOperator_DELEGATE,
                                             BuiltinOperator_BIDIRECTIONAL_SEQUENCE_LSTM,
                                             BuiltinOperator_CAST,
                                             BuiltinOperator_PRELU,
                                             BuiltinOperator_MAXIMUM,
                                             BuiltinOperator_ARG_MAX,
                                             BuiltinOperator_MINIMUM,
                                             BuiltinOperator_LESS,
                                             BuiltinOperator_NEG,
                                             BuiltinOperator_PADV2,
                                             BuiltinOperator_GREATER,
                                             BuiltinOperator_GREATER_EQUAL,
                                             BuiltinOperator_LESS_EQUAL,
                                             BuiltinOperator_SELECT,
                                             BuiltinOperator_SLICE,
                                             BuiltinOperator_SIN,
                                             BuiltinOperator_TRANSPOSE_CONV,
                                             BuiltinOperator_SPARSE_TO_DENSE,
                                             BuiltinOperator_TILE,
                                             BuiltinOperator_EXPAND_DIMS,
                                             BuiltinOperator_EQUAL,
                                             BuiltinOperator_NOT_EQUAL,
                                             BuiltinOperator_LOG,
                                             BuiltinOperator_SUM,
                                             BuiltinOperator_SQRT,
                                             BuiltinOperator_RSQRT,
                                             BuiltinOperator_SHAPE,
                                             BuiltinOperator_POW,
                                             BuiltinOperator_ARG_MIN,
                                             BuiltinOperator_FAKE_QUANT,
                                             BuiltinOperator_REDUCE_PROD,
                                             BuiltinOperator_REDUCE_MAX,
                                             BuiltinOperator_PACK,
                                             BuiltinOperator_LOGICAL_OR,
                                             BuiltinOperator_ONE_HOT,
                                             BuiltinOperator_LOGICAL_AND,
                                             BuiltinOperator_LOGICAL_NOT,
                                             BuiltinOperator_UNPACK,
                                             BuiltinOperator_REDUCE_MIN,
                                             BuiltinOperator_FLOOR_DIV,
                                             BuiltinOperator_REDUCE_ANY,
                                             BuiltinOperator_SQUARE,
                                             BuiltinOperator_ZEROS_LIKE,
                                             BuiltinOperator_FILL,
                                             BuiltinOperator_FLOOR_MOD,
                                             BuiltinOperator_RANGE,
                                             BuiltinOperator_RESIZE_NEAREST_NEIGHBOR,
                                             BuiltinOperator_LEAKY_RELU,
                                             BuiltinOperator_SQUARED_DIFFERENCE,
                                             BuiltinOperator_MIRROR_PAD,
                                             BuiltinOperator_ABS,
                                             BuiltinOperator_SPLIT_V,
                                             BuiltinOperator_UNIQUE,
                                             BuiltinOperator_CEIL,
                                             BuiltinOperator_REVERSE_V2,
                                             BuiltinOperator_ADD_N,
                                             BuiltinOperator_GATHER_ND,
                                             BuiltinOperator_COS,
                                             BuiltinOperator_WHERE,
                                             BuiltinOperator_RANK,
                                             BuiltinOperator_ELU,
                                             BuiltinOperator_REVERSE_SEQUENCE,
                                             BuiltinOperator_MATRIX_DIAG,
                                             BuiltinOperator_QUANTIZE,
                                             BuiltinOperator_MATRIX_SET_DIAG,
                                             BuiltinOperator_ROUND,
                                             BuiltinOperator_HARD_SWISH,
                                             BuiltinOperator_IF,
                                             BuiltinOperator_WHILE,
                                             BuiltinOperator_NON_MAX_SUPPRESSION_V4,
                                             BuiltinOperator_NON_MAX_SUPPRESSION_V5,
                                             BuiltinOperator_SCATTER_ND,
                                             BuiltinOperator_SELECT_V2,
                                             BuiltinOperator_DENSIFY,
                                             BuiltinOperator_SEGMENT_SUM,
                                             BuiltinOperator_BATCH_MATMUL};
    return values;
}

inline const char *const *EnumNamesBuiltinOperator() {
    static const char *const names[128] = {"ADD",
                                           "AVERAGE_POOL_2D",
                                           "CONCATENATION",
                                           "CONV_2D",
                                           "DEPTHWISE_CONV_2D",
                                           "DEPTH_TO_SPACE",
                                           "DEQUANTIZE",
                                           "EMBEDDING_LOOKUP",
                                           "FLOOR",
                                           "FULLY_CONNECTED",
                                           "HASHTABLE_LOOKUP",
                                           "L2_NORMALIZATION",
                                           "L2_POOL_2D",
                                           "LOCAL_RESPONSE_NORMALIZATION",
                                           "LOGISTIC",
                                           "LSH_PROJECTION",
                                           "LSTM",
                                           "MAX_POOL_2D",
                                           "MUL",
                                           "RELU",
                                           "RELU_N1_TO_1",
                                           "RELU6",
                                           "RESHAPE",
                                           "RESIZE_BILINEAR",
                                           "RNN",
                                           "SOFTMAX",
                                           "SPACE_TO_DEPTH",
                                           "SVDF",
                                           "TANH",
                                           "CONCAT_EMBEDDINGS",
                                           "SKIP_GRAM",
                                           "CALL",
                                           "CUSTOM",
                                           "EMBEDDING_LOOKUP_SPARSE",
                                           "PAD",
                                           "UNIDIRECTIONAL_SEQUENCE_RNN",
                                           "GATHER",
                                           "BATCH_TO_SPACE_ND",
                                           "SPACE_TO_BATCH_ND",
                                           "TRANSPOSE",
                                           "MEAN",
                                           "SUB",
                                           "DIV",
                                           "SQUEEZE",
                                           "UNIDIRECTIONAL_SEQUENCE_LSTM",
                                           "STRIDED_SLICE",
                                           "BIDIRECTIONAL_SEQUENCE_RNN",
                                           "EXP",
                                           "TOPK_V2",
                                           "SPLIT",
                                           "LOG_SOFTMAX",
                                           "DELEGATE",
                                           "BIDIRECTIONAL_SEQUENCE_LSTM",
                                           "CAST",
                                           "PRELU",
                                           "MAXIMUM",
                                           "ARG_MAX",
                                           "MINIMUM",
                                           "LESS",
                                           "NEG",
                                           "PADV2",
                                           "GREATER",
                                           "GREATER_EQUAL",
                                           "LESS_EQUAL",
                                           "SELECT",
                                           "SLICE",
                                           "SIN",
                                           "TRANSPOSE_CONV",
                                           "SPARSE_TO_DENSE",
                                           "TILE",
                                           "EXPAND_DIMS",
                                           "EQUAL",
                                           "NOT_EQUAL",
                                           "LOG",
                                           "SUM",
                                           "SQRT",
                                           "RSQRT",
                                           "SHAPE",
                                           "POW",
                                           "ARG_MIN",
                                           "FAKE_QUANT",
                                           "REDUCE_PROD",
                                           "REDUCE_MAX",
                                           "PACK",
                                           "LOGICAL_OR",
                                           "ONE_HOT",
                                           "LOGICAL_AND",
                                           "LOGICAL_NOT",
                                           "UNPACK",
                                           "REDUCE_MIN",
                                           "FLOOR_DIV",
                                           "REDUCE_ANY",
                                           "SQUARE",
                                           "ZEROS_LIKE",
                                           "FILL",
                                           "FLOOR_MOD",
                                           "RANGE",
                                           "RESIZE_NEAREST_NEIGHBOR",
                                           "LEAKY_RELU",
                                           "SQUARED_DIFFERENCE",
                                           "MIRROR_PAD",
                                           "ABS",
                                           "SPLIT_V",
                                           "UNIQUE",
                                           "CEIL",
                                           "REVERSE_V2",
                                           "ADD_N",
                                           "GATHER_ND",
                                           "COS",
                                           "WHERE",
                                           "RANK",
                                           "ELU",
                                           "REVERSE_SEQUENCE",
                                           "MATRIX_DIAG",
                                           "QUANTIZE",
                                           "MATRIX_SET_DIAG",
                                           "ROUND",
                                           "HARD_SWISH",
                                           "IF",
                                           "WHILE",
                                           "NON_MAX_SUPPRESSION_V4",
                                           "NON_MAX_SUPPRESSION_V5",
                                           "SCATTER_ND",
                                           "SELECT_V2",
                                           "DENSIFY",
                                           "SEGMENT_SUM",
                                           "BATCH_MATMUL",
                                           nullptr};
    return names;
}

inline const char *EnumNameBuiltinOperator(BuiltinOperator e) {
    if (flatbuffers::IsOutRange(e, BuiltinOperator_ADD, BuiltinOperator_BATCH_MATMUL))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesBuiltinOperator()[index];
}

enum BuiltinOptions {
    BuiltinOptions_NONE                              = 0,
    BuiltinOptions_Conv2DOptions                     = 1,
    BuiltinOptions_DepthwiseConv2DOptions            = 2,
    BuiltinOptions_ConcatEmbeddingsOptions           = 3,
    BuiltinOptions_LSHProjectionOptions              = 4,
    BuiltinOptions_Pool2DOptions                     = 5,
    BuiltinOptions_SVDFOptions                       = 6,
    BuiltinOptions_RNNOptions                        = 7,
    BuiltinOptions_FullyConnectedOptions             = 8,
    BuiltinOptions_SoftmaxOptions                    = 9,
    BuiltinOptions_ConcatenationOptions              = 10,
    BuiltinOptions_AddOptions                        = 11,
    BuiltinOptions_L2NormOptions                     = 12,
    BuiltinOptions_LocalResponseNormalizationOptions = 13,
    BuiltinOptions_LSTMOptions                       = 14,
    BuiltinOptions_ResizeBilinearOptions             = 15,
    BuiltinOptions_CallOptions                       = 16,
    BuiltinOptions_ReshapeOptions                    = 17,
    BuiltinOptions_SkipGramOptions                   = 18,
    BuiltinOptions_SpaceToDepthOptions               = 19,
    BuiltinOptions_EmbeddingLookupSparseOptions      = 20,
    BuiltinOptions_MulOptions                        = 21,
    BuiltinOptions_PadOptions                        = 22,
    BuiltinOptions_GatherOptions                     = 23,
    BuiltinOptions_BatchToSpaceNDOptions             = 24,
    BuiltinOptions_SpaceToBatchNDOptions             = 25,
    BuiltinOptions_TransposeOptions                  = 26,
    BuiltinOptions_ReducerOptions                    = 27,
    BuiltinOptions_SubOptions                        = 28,
    BuiltinOptions_DivOptions                        = 29,
    BuiltinOptions_SqueezeOptions                    = 30,
    BuiltinOptions_SequenceRNNOptions                = 31,
    BuiltinOptions_StridedSliceOptions               = 32,
    BuiltinOptions_ExpOptions                        = 33,
    BuiltinOptions_TopKV2Options                     = 34,
    BuiltinOptions_SplitOptions                      = 35,
    BuiltinOptions_LogSoftmaxOptions                 = 36,
    BuiltinOptions_CastOptions                       = 37,
    BuiltinOptions_DequantizeOptions                 = 38,
    BuiltinOptions_MaximumMinimumOptions             = 39,
    BuiltinOptions_ArgMaxOptions                     = 40,
    BuiltinOptions_LessOptions                       = 41,
    BuiltinOptions_NegOptions                        = 42,
    BuiltinOptions_PadV2Options                      = 43,
    BuiltinOptions_GreaterOptions                    = 44,
    BuiltinOptions_GreaterEqualOptions               = 45,
    BuiltinOptions_LessEqualOptions                  = 46,
    BuiltinOptions_SelectOptions                     = 47,
    BuiltinOptions_SliceOptions                      = 48,
    BuiltinOptions_TransposeConvOptions              = 49,
    BuiltinOptions_SparseToDenseOptions              = 50,
    BuiltinOptions_TileOptions                       = 51,
    BuiltinOptions_ExpandDimsOptions                 = 52,
    BuiltinOptions_EqualOptions                      = 53,
    BuiltinOptions_NotEqualOptions                   = 54,
    BuiltinOptions_ShapeOptions                      = 55,
    BuiltinOptions_PowOptions                        = 56,
    BuiltinOptions_ArgMinOptions                     = 57,
    BuiltinOptions_FakeQuantOptions                  = 58,
    BuiltinOptions_PackOptions                       = 59,
    BuiltinOptions_LogicalOrOptions                  = 60,
    BuiltinOptions_OneHotOptions                     = 61,
    BuiltinOptions_LogicalAndOptions                 = 62,
    BuiltinOptions_LogicalNotOptions                 = 63,
    BuiltinOptions_UnpackOptions                     = 64,
    BuiltinOptions_FloorDivOptions                   = 65,
    BuiltinOptions_SquareOptions                     = 66,
    BuiltinOptions_ZerosLikeOptions                  = 67,
    BuiltinOptions_FillOptions                       = 68,
    BuiltinOptions_BidirectionalSequenceLSTMOptions  = 69,
    BuiltinOptions_BidirectionalSequenceRNNOptions   = 70,
    BuiltinOptions_UnidirectionalSequenceLSTMOptions = 71,
    BuiltinOptions_FloorModOptions                   = 72,
    BuiltinOptions_RangeOptions                      = 73,
    BuiltinOptions_ResizeNearestNeighborOptions      = 74,
    BuiltinOptions_LeakyReluOptions                  = 75,
    BuiltinOptions_SquaredDifferenceOptions          = 76,
    BuiltinOptions_MirrorPadOptions                  = 77,
    BuiltinOptions_AbsOptions                        = 78,
    BuiltinOptions_SplitVOptions                     = 79,
    BuiltinOptions_UniqueOptions                     = 80,
    BuiltinOptions_ReverseV2Options                  = 81,
    BuiltinOptions_AddNOptions                       = 82,
    BuiltinOptions_GatherNdOptions                   = 83,
    BuiltinOptions_CosOptions                        = 84,
    BuiltinOptions_WhereOptions                      = 85,
    BuiltinOptions_RankOptions                       = 86,
    BuiltinOptions_ReverseSequenceOptions            = 87,
    BuiltinOptions_MatrixDiagOptions                 = 88,
    BuiltinOptions_QuantizeOptions                   = 89,
    BuiltinOptions_MatrixSetDiagOptions              = 90,
    BuiltinOptions_HardSwishOptions                  = 91,
    BuiltinOptions_IfOptions                         = 92,
    BuiltinOptions_WhileOptions                      = 93,
    BuiltinOptions_DepthToSpaceOptions               = 94,
    BuiltinOptions_NonMaxSuppressionV4Options        = 95,
    BuiltinOptions_NonMaxSuppressionV5Options        = 96,
    BuiltinOptions_ScatterNdOptions                  = 97,
    BuiltinOptions_SelectV2Options                   = 98,
    BuiltinOptions_DensifyOptions                    = 99,
    BuiltinOptions_SegmentSumOptions                 = 100,
    BuiltinOptions_BatchMatMulOptions                = 101,
    BuiltinOptions_MIN                               = BuiltinOptions_NONE,
    BuiltinOptions_MAX                               = BuiltinOptions_BatchMatMulOptions
};

inline const BuiltinOptions (&EnumValuesBuiltinOptions())[102] {
    static const BuiltinOptions values[] = {BuiltinOptions_NONE,
                                            BuiltinOptions_Conv2DOptions,
                                            BuiltinOptions_DepthwiseConv2DOptions,
                                            BuiltinOptions_ConcatEmbeddingsOptions,
                                            BuiltinOptions_LSHProjectionOptions,
                                            BuiltinOptions_Pool2DOptions,
                                            BuiltinOptions_SVDFOptions,
                                            BuiltinOptions_RNNOptions,
                                            BuiltinOptions_FullyConnectedOptions,
                                            BuiltinOptions_SoftmaxOptions,
                                            BuiltinOptions_ConcatenationOptions,
                                            BuiltinOptions_AddOptions,
                                            BuiltinOptions_L2NormOptions,
                                            BuiltinOptions_LocalResponseNormalizationOptions,
                                            BuiltinOptions_LSTMOptions,
                                            BuiltinOptions_ResizeBilinearOptions,
                                            BuiltinOptions_CallOptions,
                                            BuiltinOptions_ReshapeOptions,
                                            BuiltinOptions_SkipGramOptions,
                                            BuiltinOptions_SpaceToDepthOptions,
                                            BuiltinOptions_EmbeddingLookupSparseOptions,
                                            BuiltinOptions_MulOptions,
                                            BuiltinOptions_PadOptions,
                                            BuiltinOptions_GatherOptions,
                                            BuiltinOptions_BatchToSpaceNDOptions,
                                            BuiltinOptions_SpaceToBatchNDOptions,
                                            BuiltinOptions_TransposeOptions,
                                            BuiltinOptions_ReducerOptions,
                                            BuiltinOptions_SubOptions,
                                            BuiltinOptions_DivOptions,
                                            BuiltinOptions_SqueezeOptions,
                                            BuiltinOptions_SequenceRNNOptions,
                                            BuiltinOptions_StridedSliceOptions,
                                            BuiltinOptions_ExpOptions,
                                            BuiltinOptions_TopKV2Options,
                                            BuiltinOptions_SplitOptions,
                                            BuiltinOptions_LogSoftmaxOptions,
                                            BuiltinOptions_CastOptions,
                                            BuiltinOptions_DequantizeOptions,
                                            BuiltinOptions_MaximumMinimumOptions,
                                            BuiltinOptions_ArgMaxOptions,
                                            BuiltinOptions_LessOptions,
                                            BuiltinOptions_NegOptions,
                                            BuiltinOptions_PadV2Options,
                                            BuiltinOptions_GreaterOptions,
                                            BuiltinOptions_GreaterEqualOptions,
                                            BuiltinOptions_LessEqualOptions,
                                            BuiltinOptions_SelectOptions,
                                            BuiltinOptions_SliceOptions,
                                            BuiltinOptions_TransposeConvOptions,
                                            BuiltinOptions_SparseToDenseOptions,
                                            BuiltinOptions_TileOptions,
                                            BuiltinOptions_ExpandDimsOptions,
                                            BuiltinOptions_EqualOptions,
                                            BuiltinOptions_NotEqualOptions,
                                            BuiltinOptions_ShapeOptions,
                                            BuiltinOptions_PowOptions,
                                            BuiltinOptions_ArgMinOptions,
                                            BuiltinOptions_FakeQuantOptions,
                                            BuiltinOptions_PackOptions,
                                            BuiltinOptions_LogicalOrOptions,
                                            BuiltinOptions_OneHotOptions,
                                            BuiltinOptions_LogicalAndOptions,
                                            BuiltinOptions_LogicalNotOptions,
                                            BuiltinOptions_UnpackOptions,
                                            BuiltinOptions_FloorDivOptions,
                                            BuiltinOptions_SquareOptions,
                                            BuiltinOptions_ZerosLikeOptions,
                                            BuiltinOptions_FillOptions,
                                            BuiltinOptions_BidirectionalSequenceLSTMOptions,
                                            BuiltinOptions_BidirectionalSequenceRNNOptions,
                                            BuiltinOptions_UnidirectionalSequenceLSTMOptions,
                                            BuiltinOptions_FloorModOptions,
                                            BuiltinOptions_RangeOptions,
                                            BuiltinOptions_ResizeNearestNeighborOptions,
                                            BuiltinOptions_LeakyReluOptions,
                                            BuiltinOptions_SquaredDifferenceOptions,
                                            BuiltinOptions_MirrorPadOptions,
                                            BuiltinOptions_AbsOptions,
                                            BuiltinOptions_SplitVOptions,
                                            BuiltinOptions_UniqueOptions,
                                            BuiltinOptions_ReverseV2Options,
                                            BuiltinOptions_AddNOptions,
                                            BuiltinOptions_GatherNdOptions,
                                            BuiltinOptions_CosOptions,
                                            BuiltinOptions_WhereOptions,
                                            BuiltinOptions_RankOptions,
                                            BuiltinOptions_ReverseSequenceOptions,
                                            BuiltinOptions_MatrixDiagOptions,
                                            BuiltinOptions_QuantizeOptions,
                                            BuiltinOptions_MatrixSetDiagOptions,
                                            BuiltinOptions_HardSwishOptions,
                                            BuiltinOptions_IfOptions,
                                            BuiltinOptions_WhileOptions,
                                            BuiltinOptions_DepthToSpaceOptions,
                                            BuiltinOptions_NonMaxSuppressionV4Options,
                                            BuiltinOptions_NonMaxSuppressionV5Options,
                                            BuiltinOptions_ScatterNdOptions,
                                            BuiltinOptions_SelectV2Options,
                                            BuiltinOptions_DensifyOptions,
                                            BuiltinOptions_SegmentSumOptions,
                                            BuiltinOptions_BatchMatMulOptions};
    return values;
}

inline const char *const *EnumNamesBuiltinOptions() {
    static const char *const names[103] = {"NONE",
                                           "Conv2DOptions",
                                           "DepthwiseConv2DOptions",
                                           "ConcatEmbeddingsOptions",
                                           "LSHProjectionOptions",
                                           "Pool2DOptions",
                                           "SVDFOptions",
                                           "RNNOptions",
                                           "FullyConnectedOptions",
                                           "SoftmaxOptions",
                                           "ConcatenationOptions",
                                           "AddOptions",
                                           "L2NormOptions",
                                           "LocalResponseNormalizationOptions",
                                           "LSTMOptions",
                                           "ResizeBilinearOptions",
                                           "CallOptions",
                                           "ReshapeOptions",
                                           "SkipGramOptions",
                                           "SpaceToDepthOptions",
                                           "EmbeddingLookupSparseOptions",
                                           "MulOptions",
                                           "PadOptions",
                                           "GatherOptions",
                                           "BatchToSpaceNDOptions",
                                           "SpaceToBatchNDOptions",
                                           "TransposeOptions",
                                           "ReducerOptions",
                                           "SubOptions",
                                           "DivOptions",
                                           "SqueezeOptions",
                                           "SequenceRNNOptions",
                                           "StridedSliceOptions",
                                           "ExpOptions",
                                           "TopKV2Options",
                                           "SplitOptions",
                                           "LogSoftmaxOptions",
                                           "CastOptions",
                                           "DequantizeOptions",
                                           "MaximumMinimumOptions",
                                           "ArgMaxOptions",
                                           "LessOptions",
                                           "NegOptions",
                                           "PadV2Options",
                                           "GreaterOptions",
                                           "GreaterEqualOptions",
                                           "LessEqualOptions",
                                           "SelectOptions",
                                           "SliceOptions",
                                           "TransposeConvOptions",
                                           "SparseToDenseOptions",
                                           "TileOptions",
                                           "ExpandDimsOptions",
                                           "EqualOptions",
                                           "NotEqualOptions",
                                           "ShapeOptions",
                                           "PowOptions",
                                           "ArgMinOptions",
                                           "FakeQuantOptions",
                                           "PackOptions",
                                           "LogicalOrOptions",
                                           "OneHotOptions",
                                           "LogicalAndOptions",
                                           "LogicalNotOptions",
                                           "UnpackOptions",
                                           "FloorDivOptions",
                                           "SquareOptions",
                                           "ZerosLikeOptions",
                                           "FillOptions",
                                           "BidirectionalSequenceLSTMOptions",
                                           "BidirectionalSequenceRNNOptions",
                                           "UnidirectionalSequenceLSTMOptions",
                                           "FloorModOptions",
                                           "RangeOptions",
                                           "ResizeNearestNeighborOptions",
                                           "LeakyReluOptions",
                                           "SquaredDifferenceOptions",
                                           "MirrorPadOptions",
                                           "AbsOptions",
                                           "SplitVOptions",
                                           "UniqueOptions",
                                           "ReverseV2Options",
                                           "AddNOptions",
                                           "GatherNdOptions",
                                           "CosOptions",
                                           "WhereOptions",
                                           "RankOptions",
                                           "ReverseSequenceOptions",
                                           "MatrixDiagOptions",
                                           "QuantizeOptions",
                                           "MatrixSetDiagOptions",
                                           "HardSwishOptions",
                                           "IfOptions",
                                           "WhileOptions",
                                           "DepthToSpaceOptions",
                                           "NonMaxSuppressionV4Options",
                                           "NonMaxSuppressionV5Options",
                                           "ScatterNdOptions",
                                           "SelectV2Options",
                                           "DensifyOptions",
                                           "SegmentSumOptions",
                                           "BatchMatMulOptions",
                                           nullptr};
    return names;
}

inline const char *EnumNameBuiltinOptions(BuiltinOptions e) {
    if (flatbuffers::IsOutRange(e, BuiltinOptions_NONE, BuiltinOptions_BatchMatMulOptions))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesBuiltinOptions()[index];
}

template <typename T>
struct BuiltinOptionsTraits {
    static const BuiltinOptions enum_value = BuiltinOptions_NONE;
};

template <>
struct BuiltinOptionsTraits<tflite::Conv2DOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_Conv2DOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::DepthwiseConv2DOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_DepthwiseConv2DOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ConcatEmbeddingsOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_ConcatEmbeddingsOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LSHProjectionOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_LSHProjectionOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::Pool2DOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_Pool2DOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SVDFOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SVDFOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::RNNOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_RNNOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::FullyConnectedOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_FullyConnectedOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SoftmaxOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SoftmaxOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ConcatenationOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_ConcatenationOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::AddOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_AddOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::L2NormOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_L2NormOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LocalResponseNormalizationOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_LocalResponseNormalizationOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LSTMOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_LSTMOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ResizeBilinearOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_ResizeBilinearOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::CallOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_CallOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ReshapeOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_ReshapeOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SkipGramOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SkipGramOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SpaceToDepthOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SpaceToDepthOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::EmbeddingLookupSparseOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_EmbeddingLookupSparseOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::MulOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_MulOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::PadOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_PadOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::GatherOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_GatherOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::BatchToSpaceNDOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_BatchToSpaceNDOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SpaceToBatchNDOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SpaceToBatchNDOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::TransposeOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_TransposeOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ReducerOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_ReducerOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SubOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SubOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::DivOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_DivOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SqueezeOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SqueezeOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SequenceRNNOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SequenceRNNOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::StridedSliceOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_StridedSliceOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ExpOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_ExpOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::TopKV2Options> {
    static const BuiltinOptions enum_value = BuiltinOptions_TopKV2Options;
};

template <>
struct BuiltinOptionsTraits<tflite::SplitOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SplitOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LogSoftmaxOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_LogSoftmaxOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::CastOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_CastOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::DequantizeOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_DequantizeOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::MaximumMinimumOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_MaximumMinimumOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ArgMaxOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_ArgMaxOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LessOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_LessOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::NegOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_NegOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::PadV2Options> {
    static const BuiltinOptions enum_value = BuiltinOptions_PadV2Options;
};

template <>
struct BuiltinOptionsTraits<tflite::GreaterOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_GreaterOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::GreaterEqualOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_GreaterEqualOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LessEqualOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_LessEqualOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SelectOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SelectOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SliceOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SliceOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::TransposeConvOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_TransposeConvOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SparseToDenseOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SparseToDenseOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::TileOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_TileOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ExpandDimsOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_ExpandDimsOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::EqualOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_EqualOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::NotEqualOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_NotEqualOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ShapeOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_ShapeOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::PowOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_PowOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ArgMinOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_ArgMinOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::FakeQuantOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_FakeQuantOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::PackOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_PackOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LogicalOrOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_LogicalOrOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::OneHotOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_OneHotOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LogicalAndOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_LogicalAndOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LogicalNotOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_LogicalNotOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::UnpackOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_UnpackOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::FloorDivOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_FloorDivOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SquareOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SquareOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ZerosLikeOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_ZerosLikeOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::FillOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_FillOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::BidirectionalSequenceLSTMOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_BidirectionalSequenceLSTMOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::BidirectionalSequenceRNNOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_BidirectionalSequenceRNNOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::UnidirectionalSequenceLSTMOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_UnidirectionalSequenceLSTMOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::FloorModOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_FloorModOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::RangeOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_RangeOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ResizeNearestNeighborOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_ResizeNearestNeighborOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LeakyReluOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_LeakyReluOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SquaredDifferenceOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SquaredDifferenceOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::MirrorPadOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_MirrorPadOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::AbsOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_AbsOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SplitVOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SplitVOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::UniqueOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_UniqueOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ReverseV2Options> {
    static const BuiltinOptions enum_value = BuiltinOptions_ReverseV2Options;
};

template <>
struct BuiltinOptionsTraits<tflite::AddNOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_AddNOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::GatherNdOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_GatherNdOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::CosOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_CosOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::WhereOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_WhereOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::RankOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_RankOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ReverseSequenceOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_ReverseSequenceOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::MatrixDiagOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_MatrixDiagOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::QuantizeOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_QuantizeOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::MatrixSetDiagOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_MatrixSetDiagOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::HardSwishOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_HardSwishOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::IfOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_IfOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::WhileOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_WhileOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::DepthToSpaceOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_DepthToSpaceOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::NonMaxSuppressionV4Options> {
    static const BuiltinOptions enum_value = BuiltinOptions_NonMaxSuppressionV4Options;
};

template <>
struct BuiltinOptionsTraits<tflite::NonMaxSuppressionV5Options> {
    static const BuiltinOptions enum_value = BuiltinOptions_NonMaxSuppressionV5Options;
};

template <>
struct BuiltinOptionsTraits<tflite::ScatterNdOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_ScatterNdOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SelectV2Options> {
    static const BuiltinOptions enum_value = BuiltinOptions_SelectV2Options;
};

template <>
struct BuiltinOptionsTraits<tflite::DensifyOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_DensifyOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SegmentSumOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SegmentSumOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::BatchMatMulOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_BatchMatMulOptions;
};

struct BuiltinOptionsUnion {
    BuiltinOptions type;
    void *value;

    BuiltinOptionsUnion() : type(BuiltinOptions_NONE), value(nullptr) {}
    BuiltinOptionsUnion(BuiltinOptionsUnion &&u) FLATBUFFERS_NOEXCEPT : type(BuiltinOptions_NONE), value(nullptr) {
        std::swap(type, u.type);
        std::swap(value, u.value);
    }
    BuiltinOptionsUnion(const BuiltinOptionsUnion &);
    BuiltinOptionsUnion &operator=(const BuiltinOptionsUnion &u) {
        BuiltinOptionsUnion t(u);
        std::swap(type, t.type);
        std::swap(value, t.value);
        return *this;
    }
    BuiltinOptionsUnion &operator=(BuiltinOptionsUnion &&u) FLATBUFFERS_NOEXCEPT {
        std::swap(type, u.type);
        std::swap(value, u.value);
        return *this;
    }
    ~BuiltinOptionsUnion() {
        Reset();
    }

    void Reset();

#ifndef FLATBUFFERS_CPP98_STL
    template <typename T>
    void Set(T &&val) {
        using RT = typename std::remove_reference<T>::type;
        Reset();
        type = BuiltinOptionsTraits<typename RT::TableType>::enum_value;
        if (type != BuiltinOptions_NONE) {
            value = new RT(std::forward<T>(val));
        }
    }
#endif  // FLATBUFFERS_CPP98_STL

    static void *UnPack(const void *obj, BuiltinOptions type, const flatbuffers::resolver_function_t *resolver);
    flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

    tflite::Conv2DOptionsT *AsConv2DOptions() {
        return type == BuiltinOptions_Conv2DOptions ? reinterpret_cast<tflite::Conv2DOptionsT *>(value) : nullptr;
    }
    const tflite::Conv2DOptionsT *AsConv2DOptions() const {
        return type == BuiltinOptions_Conv2DOptions ? reinterpret_cast<const tflite::Conv2DOptionsT *>(value) : nullptr;
    }
    tflite::DepthwiseConv2DOptionsT *AsDepthwiseConv2DOptions() {
        return type == BuiltinOptions_DepthwiseConv2DOptions
                   ? reinterpret_cast<tflite::DepthwiseConv2DOptionsT *>(value)
                   : nullptr;
    }
    const tflite::DepthwiseConv2DOptionsT *AsDepthwiseConv2DOptions() const {
        return type == BuiltinOptions_DepthwiseConv2DOptions
                   ? reinterpret_cast<const tflite::DepthwiseConv2DOptionsT *>(value)
                   : nullptr;
    }
    tflite::ConcatEmbeddingsOptionsT *AsConcatEmbeddingsOptions() {
        return type == BuiltinOptions_ConcatEmbeddingsOptions
                   ? reinterpret_cast<tflite::ConcatEmbeddingsOptionsT *>(value)
                   : nullptr;
    }
    const tflite::ConcatEmbeddingsOptionsT *AsConcatEmbeddingsOptions() const {
        return type == BuiltinOptions_ConcatEmbeddingsOptions
                   ? reinterpret_cast<const tflite::ConcatEmbeddingsOptionsT *>(value)
                   : nullptr;
    }
    tflite::LSHProjectionOptionsT *AsLSHProjectionOptions() {
        return type == BuiltinOptions_LSHProjectionOptions ? reinterpret_cast<tflite::LSHProjectionOptionsT *>(value)
                                                           : nullptr;
    }
    const tflite::LSHProjectionOptionsT *AsLSHProjectionOptions() const {
        return type == BuiltinOptions_LSHProjectionOptions
                   ? reinterpret_cast<const tflite::LSHProjectionOptionsT *>(value)
                   : nullptr;
    }
    tflite::Pool2DOptionsT *AsPool2DOptions() {
        return type == BuiltinOptions_Pool2DOptions ? reinterpret_cast<tflite::Pool2DOptionsT *>(value) : nullptr;
    }
    const tflite::Pool2DOptionsT *AsPool2DOptions() const {
        return type == BuiltinOptions_Pool2DOptions ? reinterpret_cast<const tflite::Pool2DOptionsT *>(value) : nullptr;
    }
    tflite::SVDFOptionsT *AsSVDFOptions() {
        return type == BuiltinOptions_SVDFOptions ? reinterpret_cast<tflite::SVDFOptionsT *>(value) : nullptr;
    }
    const tflite::SVDFOptionsT *AsSVDFOptions() const {
        return type == BuiltinOptions_SVDFOptions ? reinterpret_cast<const tflite::SVDFOptionsT *>(value) : nullptr;
    }
    tflite::RNNOptionsT *AsRNNOptions() {
        return type == BuiltinOptions_RNNOptions ? reinterpret_cast<tflite::RNNOptionsT *>(value) : nullptr;
    }
    const tflite::RNNOptionsT *AsRNNOptions() const {
        return type == BuiltinOptions_RNNOptions ? reinterpret_cast<const tflite::RNNOptionsT *>(value) : nullptr;
    }
    tflite::FullyConnectedOptionsT *AsFullyConnectedOptions() {
        return type == BuiltinOptions_FullyConnectedOptions ? reinterpret_cast<tflite::FullyConnectedOptionsT *>(value)
                                                            : nullptr;
    }
    const tflite::FullyConnectedOptionsT *AsFullyConnectedOptions() const {
        return type == BuiltinOptions_FullyConnectedOptions
                   ? reinterpret_cast<const tflite::FullyConnectedOptionsT *>(value)
                   : nullptr;
    }
    tflite::SoftmaxOptionsT *AsSoftmaxOptions() {
        return type == BuiltinOptions_SoftmaxOptions ? reinterpret_cast<tflite::SoftmaxOptionsT *>(value) : nullptr;
    }
    const tflite::SoftmaxOptionsT *AsSoftmaxOptions() const {
        return type == BuiltinOptions_SoftmaxOptions ? reinterpret_cast<const tflite::SoftmaxOptionsT *>(value)
                                                     : nullptr;
    }
    tflite::ConcatenationOptionsT *AsConcatenationOptions() {
        return type == BuiltinOptions_ConcatenationOptions ? reinterpret_cast<tflite::ConcatenationOptionsT *>(value)
                                                           : nullptr;
    }
    const tflite::ConcatenationOptionsT *AsConcatenationOptions() const {
        return type == BuiltinOptions_ConcatenationOptions
                   ? reinterpret_cast<const tflite::ConcatenationOptionsT *>(value)
                   : nullptr;
    }
    tflite::AddOptionsT *AsAddOptions() {
        return type == BuiltinOptions_AddOptions ? reinterpret_cast<tflite::AddOptionsT *>(value) : nullptr;
    }
    const tflite::AddOptionsT *AsAddOptions() const {
        return type == BuiltinOptions_AddOptions ? reinterpret_cast<const tflite::AddOptionsT *>(value) : nullptr;
    }
    tflite::L2NormOptionsT *AsL2NormOptions() {
        return type == BuiltinOptions_L2NormOptions ? reinterpret_cast<tflite::L2NormOptionsT *>(value) : nullptr;
    }
    const tflite::L2NormOptionsT *AsL2NormOptions() const {
        return type == BuiltinOptions_L2NormOptions ? reinterpret_cast<const tflite::L2NormOptionsT *>(value) : nullptr;
    }
    tflite::LocalResponseNormalizationOptionsT *AsLocalResponseNormalizationOptions() {
        return type == BuiltinOptions_LocalResponseNormalizationOptions
                   ? reinterpret_cast<tflite::LocalResponseNormalizationOptionsT *>(value)
                   : nullptr;
    }
    const tflite::LocalResponseNormalizationOptionsT *AsLocalResponseNormalizationOptions() const {
        return type == BuiltinOptions_LocalResponseNormalizationOptions
                   ? reinterpret_cast<const tflite::LocalResponseNormalizationOptionsT *>(value)
                   : nullptr;
    }
    tflite::LSTMOptionsT *AsLSTMOptions() {
        return type == BuiltinOptions_LSTMOptions ? reinterpret_cast<tflite::LSTMOptionsT *>(value) : nullptr;
    }
    const tflite::LSTMOptionsT *AsLSTMOptions() const {
        return type == BuiltinOptions_LSTMOptions ? reinterpret_cast<const tflite::LSTMOptionsT *>(value) : nullptr;
    }
    tflite::ResizeBilinearOptionsT *AsResizeBilinearOptions() {
        return type == BuiltinOptions_ResizeBilinearOptions ? reinterpret_cast<tflite::ResizeBilinearOptionsT *>(value)
                                                            : nullptr;
    }
    const tflite::ResizeBilinearOptionsT *AsResizeBilinearOptions() const {
        return type == BuiltinOptions_ResizeBilinearOptions
                   ? reinterpret_cast<const tflite::ResizeBilinearOptionsT *>(value)
                   : nullptr;
    }
    tflite::CallOptionsT *AsCallOptions() {
        return type == BuiltinOptions_CallOptions ? reinterpret_cast<tflite::CallOptionsT *>(value) : nullptr;
    }
    const tflite::CallOptionsT *AsCallOptions() const {
        return type == BuiltinOptions_CallOptions ? reinterpret_cast<const tflite::CallOptionsT *>(value) : nullptr;
    }
    tflite::ReshapeOptionsT *AsReshapeOptions() {
        return type == BuiltinOptions_ReshapeOptions ? reinterpret_cast<tflite::ReshapeOptionsT *>(value) : nullptr;
    }
    const tflite::ReshapeOptionsT *AsReshapeOptions() const {
        return type == BuiltinOptions_ReshapeOptions ? reinterpret_cast<const tflite::ReshapeOptionsT *>(value)
                                                     : nullptr;
    }
    tflite::SkipGramOptionsT *AsSkipGramOptions() {
        return type == BuiltinOptions_SkipGramOptions ? reinterpret_cast<tflite::SkipGramOptionsT *>(value) : nullptr;
    }
    const tflite::SkipGramOptionsT *AsSkipGramOptions() const {
        return type == BuiltinOptions_SkipGramOptions ? reinterpret_cast<const tflite::SkipGramOptionsT *>(value)
                                                      : nullptr;
    }
    tflite::SpaceToDepthOptionsT *AsSpaceToDepthOptions() {
        return type == BuiltinOptions_SpaceToDepthOptions ? reinterpret_cast<tflite::SpaceToDepthOptionsT *>(value)
                                                          : nullptr;
    }
    const tflite::SpaceToDepthOptionsT *AsSpaceToDepthOptions() const {
        return type == BuiltinOptions_SpaceToDepthOptions
                   ? reinterpret_cast<const tflite::SpaceToDepthOptionsT *>(value)
                   : nullptr;
    }
    tflite::EmbeddingLookupSparseOptionsT *AsEmbeddingLookupSparseOptions() {
        return type == BuiltinOptions_EmbeddingLookupSparseOptions
                   ? reinterpret_cast<tflite::EmbeddingLookupSparseOptionsT *>(value)
                   : nullptr;
    }
    const tflite::EmbeddingLookupSparseOptionsT *AsEmbeddingLookupSparseOptions() const {
        return type == BuiltinOptions_EmbeddingLookupSparseOptions
                   ? reinterpret_cast<const tflite::EmbeddingLookupSparseOptionsT *>(value)
                   : nullptr;
    }
    tflite::MulOptionsT *AsMulOptions() {
        return type == BuiltinOptions_MulOptions ? reinterpret_cast<tflite::MulOptionsT *>(value) : nullptr;
    }
    const tflite::MulOptionsT *AsMulOptions() const {
        return type == BuiltinOptions_MulOptions ? reinterpret_cast<const tflite::MulOptionsT *>(value) : nullptr;
    }
    tflite::PadOptionsT *AsPadOptions() {
        return type == BuiltinOptions_PadOptions ? reinterpret_cast<tflite::PadOptionsT *>(value) : nullptr;
    }
    const tflite::PadOptionsT *AsPadOptions() const {
        return type == BuiltinOptions_PadOptions ? reinterpret_cast<const tflite::PadOptionsT *>(value) : nullptr;
    }
    tflite::GatherOptionsT *AsGatherOptions() {
        return type == BuiltinOptions_GatherOptions ? reinterpret_cast<tflite::GatherOptionsT *>(value) : nullptr;
    }
    const tflite::GatherOptionsT *AsGatherOptions() const {
        return type == BuiltinOptions_GatherOptions ? reinterpret_cast<const tflite::GatherOptionsT *>(value) : nullptr;
    }
    tflite::BatchToSpaceNDOptionsT *AsBatchToSpaceNDOptions() {
        return type == BuiltinOptions_BatchToSpaceNDOptions ? reinterpret_cast<tflite::BatchToSpaceNDOptionsT *>(value)
                                                            : nullptr;
    }
    const tflite::BatchToSpaceNDOptionsT *AsBatchToSpaceNDOptions() const {
        return type == BuiltinOptions_BatchToSpaceNDOptions
                   ? reinterpret_cast<const tflite::BatchToSpaceNDOptionsT *>(value)
                   : nullptr;
    }
    tflite::SpaceToBatchNDOptionsT *AsSpaceToBatchNDOptions() {
        return type == BuiltinOptions_SpaceToBatchNDOptions ? reinterpret_cast<tflite::SpaceToBatchNDOptionsT *>(value)
                                                            : nullptr;
    }
    const tflite::SpaceToBatchNDOptionsT *AsSpaceToBatchNDOptions() const {
        return type == BuiltinOptions_SpaceToBatchNDOptions
                   ? reinterpret_cast<const tflite::SpaceToBatchNDOptionsT *>(value)
                   : nullptr;
    }
    tflite::TransposeOptionsT *AsTransposeOptions() {
        return type == BuiltinOptions_TransposeOptions ? reinterpret_cast<tflite::TransposeOptionsT *>(value) : nullptr;
    }
    const tflite::TransposeOptionsT *AsTransposeOptions() const {
        return type == BuiltinOptions_TransposeOptions ? reinterpret_cast<const tflite::TransposeOptionsT *>(value)
                                                       : nullptr;
    }
    tflite::ReducerOptionsT *AsReducerOptions() {
        return type == BuiltinOptions_ReducerOptions ? reinterpret_cast<tflite::ReducerOptionsT *>(value) : nullptr;
    }
    const tflite::ReducerOptionsT *AsReducerOptions() const {
        return type == BuiltinOptions_ReducerOptions ? reinterpret_cast<const tflite::ReducerOptionsT *>(value)
                                                     : nullptr;
    }
    tflite::SubOptionsT *AsSubOptions() {
        return type == BuiltinOptions_SubOptions ? reinterpret_cast<tflite::SubOptionsT *>(value) : nullptr;
    }
    const tflite::SubOptionsT *AsSubOptions() const {
        return type == BuiltinOptions_SubOptions ? reinterpret_cast<const tflite::SubOptionsT *>(value) : nullptr;
    }
    tflite::DivOptionsT *AsDivOptions() {
        return type == BuiltinOptions_DivOptions ? reinterpret_cast<tflite::DivOptionsT *>(value) : nullptr;
    }
    const tflite::DivOptionsT *AsDivOptions() const {
        return type == BuiltinOptions_DivOptions ? reinterpret_cast<const tflite::DivOptionsT *>(value) : nullptr;
    }
    tflite::SqueezeOptionsT *AsSqueezeOptions() {
        return type == BuiltinOptions_SqueezeOptions ? reinterpret_cast<tflite::SqueezeOptionsT *>(value) : nullptr;
    }
    const tflite::SqueezeOptionsT *AsSqueezeOptions() const {
        return type == BuiltinOptions_SqueezeOptions ? reinterpret_cast<const tflite::SqueezeOptionsT *>(value)
                                                     : nullptr;
    }
    tflite::SequenceRNNOptionsT *AsSequenceRNNOptions() {
        return type == BuiltinOptions_SequenceRNNOptions ? reinterpret_cast<tflite::SequenceRNNOptionsT *>(value)
                                                         : nullptr;
    }
    const tflite::SequenceRNNOptionsT *AsSequenceRNNOptions() const {
        return type == BuiltinOptions_SequenceRNNOptions ? reinterpret_cast<const tflite::SequenceRNNOptionsT *>(value)
                                                         : nullptr;
    }
    tflite::StridedSliceOptionsT *AsStridedSliceOptions() {
        return type == BuiltinOptions_StridedSliceOptions ? reinterpret_cast<tflite::StridedSliceOptionsT *>(value)
                                                          : nullptr;
    }
    const tflite::StridedSliceOptionsT *AsStridedSliceOptions() const {
        return type == BuiltinOptions_StridedSliceOptions
                   ? reinterpret_cast<const tflite::StridedSliceOptionsT *>(value)
                   : nullptr;
    }
    tflite::ExpOptionsT *AsExpOptions() {
        return type == BuiltinOptions_ExpOptions ? reinterpret_cast<tflite::ExpOptionsT *>(value) : nullptr;
    }
    const tflite::ExpOptionsT *AsExpOptions() const {
        return type == BuiltinOptions_ExpOptions ? reinterpret_cast<const tflite::ExpOptionsT *>(value) : nullptr;
    }
    tflite::TopKV2OptionsT *AsTopKV2Options() {
        return type == BuiltinOptions_TopKV2Options ? reinterpret_cast<tflite::TopKV2OptionsT *>(value) : nullptr;
    }
    const tflite::TopKV2OptionsT *AsTopKV2Options() const {
        return type == BuiltinOptions_TopKV2Options ? reinterpret_cast<const tflite::TopKV2OptionsT *>(value) : nullptr;
    }
    tflite::SplitOptionsT *AsSplitOptions() {
        return type == BuiltinOptions_SplitOptions ? reinterpret_cast<tflite::SplitOptionsT *>(value) : nullptr;
    }
    const tflite::SplitOptionsT *AsSplitOptions() const {
        return type == BuiltinOptions_SplitOptions ? reinterpret_cast<const tflite::SplitOptionsT *>(value) : nullptr;
    }
    tflite::LogSoftmaxOptionsT *AsLogSoftmaxOptions() {
        return type == BuiltinOptions_LogSoftmaxOptions ? reinterpret_cast<tflite::LogSoftmaxOptionsT *>(value)
                                                        : nullptr;
    }
    const tflite::LogSoftmaxOptionsT *AsLogSoftmaxOptions() const {
        return type == BuiltinOptions_LogSoftmaxOptions ? reinterpret_cast<const tflite::LogSoftmaxOptionsT *>(value)
                                                        : nullptr;
    }
    tflite::CastOptionsT *AsCastOptions() {
        return type == BuiltinOptions_CastOptions ? reinterpret_cast<tflite::CastOptionsT *>(value) : nullptr;
    }
    const tflite::CastOptionsT *AsCastOptions() const {
        return type == BuiltinOptions_CastOptions ? reinterpret_cast<const tflite::CastOptionsT *>(value) : nullptr;
    }
    tflite::DequantizeOptionsT *AsDequantizeOptions() {
        return type == BuiltinOptions_DequantizeOptions ? reinterpret_cast<tflite::DequantizeOptionsT *>(value)
                                                        : nullptr;
    }
    const tflite::DequantizeOptionsT *AsDequantizeOptions() const {
        return type == BuiltinOptions_DequantizeOptions ? reinterpret_cast<const tflite::DequantizeOptionsT *>(value)
                                                        : nullptr;
    }
    tflite::MaximumMinimumOptionsT *AsMaximumMinimumOptions() {
        return type == BuiltinOptions_MaximumMinimumOptions ? reinterpret_cast<tflite::MaximumMinimumOptionsT *>(value)
                                                            : nullptr;
    }
    const tflite::MaximumMinimumOptionsT *AsMaximumMinimumOptions() const {
        return type == BuiltinOptions_MaximumMinimumOptions
                   ? reinterpret_cast<const tflite::MaximumMinimumOptionsT *>(value)
                   : nullptr;
    }
    tflite::ArgMaxOptionsT *AsArgMaxOptions() {
        return type == BuiltinOptions_ArgMaxOptions ? reinterpret_cast<tflite::ArgMaxOptionsT *>(value) : nullptr;
    }
    const tflite::ArgMaxOptionsT *AsArgMaxOptions() const {
        return type == BuiltinOptions_ArgMaxOptions ? reinterpret_cast<const tflite::ArgMaxOptionsT *>(value) : nullptr;
    }
    tflite::LessOptionsT *AsLessOptions() {
        return type == BuiltinOptions_LessOptions ? reinterpret_cast<tflite::LessOptionsT *>(value) : nullptr;
    }
    const tflite::LessOptionsT *AsLessOptions() const {
        return type == BuiltinOptions_LessOptions ? reinterpret_cast<const tflite::LessOptionsT *>(value) : nullptr;
    }
    tflite::NegOptionsT *AsNegOptions() {
        return type == BuiltinOptions_NegOptions ? reinterpret_cast<tflite::NegOptionsT *>(value) : nullptr;
    }
    const tflite::NegOptionsT *AsNegOptions() const {
        return type == BuiltinOptions_NegOptions ? reinterpret_cast<const tflite::NegOptionsT *>(value) : nullptr;
    }
    tflite::PadV2OptionsT *AsPadV2Options() {
        return type == BuiltinOptions_PadV2Options ? reinterpret_cast<tflite::PadV2OptionsT *>(value) : nullptr;
    }
    const tflite::PadV2OptionsT *AsPadV2Options() const {
        return type == BuiltinOptions_PadV2Options ? reinterpret_cast<const tflite::PadV2OptionsT *>(value) : nullptr;
    }
    tflite::GreaterOptionsT *AsGreaterOptions() {
        return type == BuiltinOptions_GreaterOptions ? reinterpret_cast<tflite::GreaterOptionsT *>(value) : nullptr;
    }
    const tflite::GreaterOptionsT *AsGreaterOptions() const {
        return type == BuiltinOptions_GreaterOptions ? reinterpret_cast<const tflite::GreaterOptionsT *>(value)
                                                     : nullptr;
    }
    tflite::GreaterEqualOptionsT *AsGreaterEqualOptions() {
        return type == BuiltinOptions_GreaterEqualOptions ? reinterpret_cast<tflite::GreaterEqualOptionsT *>(value)
                                                          : nullptr;
    }
    const tflite::GreaterEqualOptionsT *AsGreaterEqualOptions() const {
        return type == BuiltinOptions_GreaterEqualOptions
                   ? reinterpret_cast<const tflite::GreaterEqualOptionsT *>(value)
                   : nullptr;
    }
    tflite::LessEqualOptionsT *AsLessEqualOptions() {
        return type == BuiltinOptions_LessEqualOptions ? reinterpret_cast<tflite::LessEqualOptionsT *>(value) : nullptr;
    }
    const tflite::LessEqualOptionsT *AsLessEqualOptions() const {
        return type == BuiltinOptions_LessEqualOptions ? reinterpret_cast<const tflite::LessEqualOptionsT *>(value)
                                                       : nullptr;
    }
    tflite::SelectOptionsT *AsSelectOptions() {
        return type == BuiltinOptions_SelectOptions ? reinterpret_cast<tflite::SelectOptionsT *>(value) : nullptr;
    }
    const tflite::SelectOptionsT *AsSelectOptions() const {
        return type == BuiltinOptions_SelectOptions ? reinterpret_cast<const tflite::SelectOptionsT *>(value) : nullptr;
    }
    tflite::SliceOptionsT *AsSliceOptions() {
        return type == BuiltinOptions_SliceOptions ? reinterpret_cast<tflite::SliceOptionsT *>(value) : nullptr;
    }
    const tflite::SliceOptionsT *AsSliceOptions() const {
        return type == BuiltinOptions_SliceOptions ? reinterpret_cast<const tflite::SliceOptionsT *>(value) : nullptr;
    }
    tflite::TransposeConvOptionsT *AsTransposeConvOptions() {
        return type == BuiltinOptions_TransposeConvOptions ? reinterpret_cast<tflite::TransposeConvOptionsT *>(value)
                                                           : nullptr;
    }
    const tflite::TransposeConvOptionsT *AsTransposeConvOptions() const {
        return type == BuiltinOptions_TransposeConvOptions
                   ? reinterpret_cast<const tflite::TransposeConvOptionsT *>(value)
                   : nullptr;
    }
    tflite::SparseToDenseOptionsT *AsSparseToDenseOptions() {
        return type == BuiltinOptions_SparseToDenseOptions ? reinterpret_cast<tflite::SparseToDenseOptionsT *>(value)
                                                           : nullptr;
    }
    const tflite::SparseToDenseOptionsT *AsSparseToDenseOptions() const {
        return type == BuiltinOptions_SparseToDenseOptions
                   ? reinterpret_cast<const tflite::SparseToDenseOptionsT *>(value)
                   : nullptr;
    }
    tflite::TileOptionsT *AsTileOptions() {
        return type == BuiltinOptions_TileOptions ? reinterpret_cast<tflite::TileOptionsT *>(value) : nullptr;
    }
    const tflite::TileOptionsT *AsTileOptions() const {
        return type == BuiltinOptions_TileOptions ? reinterpret_cast<const tflite::TileOptionsT *>(value) : nullptr;
    }
    tflite::ExpandDimsOptionsT *AsExpandDimsOptions() {
        return type == BuiltinOptions_ExpandDimsOptions ? reinterpret_cast<tflite::ExpandDimsOptionsT *>(value)
                                                        : nullptr;
    }
    const tflite::ExpandDimsOptionsT *AsExpandDimsOptions() const {
        return type == BuiltinOptions_ExpandDimsOptions ? reinterpret_cast<const tflite::ExpandDimsOptionsT *>(value)
                                                        : nullptr;
    }
    tflite::EqualOptionsT *AsEqualOptions() {
        return type == BuiltinOptions_EqualOptions ? reinterpret_cast<tflite::EqualOptionsT *>(value) : nullptr;
    }
    const tflite::EqualOptionsT *AsEqualOptions() const {
        return type == BuiltinOptions_EqualOptions ? reinterpret_cast<const tflite::EqualOptionsT *>(value) : nullptr;
    }
    tflite::NotEqualOptionsT *AsNotEqualOptions() {
        return type == BuiltinOptions_NotEqualOptions ? reinterpret_cast<tflite::NotEqualOptionsT *>(value) : nullptr;
    }
    const tflite::NotEqualOptionsT *AsNotEqualOptions() const {
        return type == BuiltinOptions_NotEqualOptions ? reinterpret_cast<const tflite::NotEqualOptionsT *>(value)
                                                      : nullptr;
    }
    tflite::ShapeOptionsT *AsShapeOptions() {
        return type == BuiltinOptions_ShapeOptions ? reinterpret_cast<tflite::ShapeOptionsT *>(value) : nullptr;
    }
    const tflite::ShapeOptionsT *AsShapeOptions() const {
        return type == BuiltinOptions_ShapeOptions ? reinterpret_cast<const tflite::ShapeOptionsT *>(value) : nullptr;
    }
    tflite::PowOptionsT *AsPowOptions() {
        return type == BuiltinOptions_PowOptions ? reinterpret_cast<tflite::PowOptionsT *>(value) : nullptr;
    }
    const tflite::PowOptionsT *AsPowOptions() const {
        return type == BuiltinOptions_PowOptions ? reinterpret_cast<const tflite::PowOptionsT *>(value) : nullptr;
    }
    tflite::ArgMinOptionsT *AsArgMinOptions() {
        return type == BuiltinOptions_ArgMinOptions ? reinterpret_cast<tflite::ArgMinOptionsT *>(value) : nullptr;
    }
    const tflite::ArgMinOptionsT *AsArgMinOptions() const {
        return type == BuiltinOptions_ArgMinOptions ? reinterpret_cast<const tflite::ArgMinOptionsT *>(value) : nullptr;
    }
    tflite::FakeQuantOptionsT *AsFakeQuantOptions() {
        return type == BuiltinOptions_FakeQuantOptions ? reinterpret_cast<tflite::FakeQuantOptionsT *>(value) : nullptr;
    }
    const tflite::FakeQuantOptionsT *AsFakeQuantOptions() const {
        return type == BuiltinOptions_FakeQuantOptions ? reinterpret_cast<const tflite::FakeQuantOptionsT *>(value)
                                                       : nullptr;
    }
    tflite::PackOptionsT *AsPackOptions() {
        return type == BuiltinOptions_PackOptions ? reinterpret_cast<tflite::PackOptionsT *>(value) : nullptr;
    }
    const tflite::PackOptionsT *AsPackOptions() const {
        return type == BuiltinOptions_PackOptions ? reinterpret_cast<const tflite::PackOptionsT *>(value) : nullptr;
    }
    tflite::LogicalOrOptionsT *AsLogicalOrOptions() {
        return type == BuiltinOptions_LogicalOrOptions ? reinterpret_cast<tflite::LogicalOrOptionsT *>(value) : nullptr;
    }
    const tflite::LogicalOrOptionsT *AsLogicalOrOptions() const {
        return type == BuiltinOptions_LogicalOrOptions ? reinterpret_cast<const tflite::LogicalOrOptionsT *>(value)
                                                       : nullptr;
    }
    tflite::OneHotOptionsT *AsOneHotOptions() {
        return type == BuiltinOptions_OneHotOptions ? reinterpret_cast<tflite::OneHotOptionsT *>(value) : nullptr;
    }
    const tflite::OneHotOptionsT *AsOneHotOptions() const {
        return type == BuiltinOptions_OneHotOptions ? reinterpret_cast<const tflite::OneHotOptionsT *>(value) : nullptr;
    }
    tflite::LogicalAndOptionsT *AsLogicalAndOptions() {
        return type == BuiltinOptions_LogicalAndOptions ? reinterpret_cast<tflite::LogicalAndOptionsT *>(value)
                                                        : nullptr;
    }
    const tflite::LogicalAndOptionsT *AsLogicalAndOptions() const {
        return type == BuiltinOptions_LogicalAndOptions ? reinterpret_cast<const tflite::LogicalAndOptionsT *>(value)
                                                        : nullptr;
    }
    tflite::LogicalNotOptionsT *AsLogicalNotOptions() {
        return type == BuiltinOptions_LogicalNotOptions ? reinterpret_cast<tflite::LogicalNotOptionsT *>(value)
                                                        : nullptr;
    }
    const tflite::LogicalNotOptionsT *AsLogicalNotOptions() const {
        return type == BuiltinOptions_LogicalNotOptions ? reinterpret_cast<const tflite::LogicalNotOptionsT *>(value)
                                                        : nullptr;
    }
    tflite::UnpackOptionsT *AsUnpackOptions() {
        return type == BuiltinOptions_UnpackOptions ? reinterpret_cast<tflite::UnpackOptionsT *>(value) : nullptr;
    }
    const tflite::UnpackOptionsT *AsUnpackOptions() const {
        return type == BuiltinOptions_UnpackOptions ? reinterpret_cast<const tflite::UnpackOptionsT *>(value) : nullptr;
    }
    tflite::FloorDivOptionsT *AsFloorDivOptions() {
        return type == BuiltinOptions_FloorDivOptions ? reinterpret_cast<tflite::FloorDivOptionsT *>(value) : nullptr;
    }
    const tflite::FloorDivOptionsT *AsFloorDivOptions() const {
        return type == BuiltinOptions_FloorDivOptions ? reinterpret_cast<const tflite::FloorDivOptionsT *>(value)
                                                      : nullptr;
    }
    tflite::SquareOptionsT *AsSquareOptions() {
        return type == BuiltinOptions_SquareOptions ? reinterpret_cast<tflite::SquareOptionsT *>(value) : nullptr;
    }
    const tflite::SquareOptionsT *AsSquareOptions() const {
        return type == BuiltinOptions_SquareOptions ? reinterpret_cast<const tflite::SquareOptionsT *>(value) : nullptr;
    }
    tflite::ZerosLikeOptionsT *AsZerosLikeOptions() {
        return type == BuiltinOptions_ZerosLikeOptions ? reinterpret_cast<tflite::ZerosLikeOptionsT *>(value) : nullptr;
    }
    const tflite::ZerosLikeOptionsT *AsZerosLikeOptions() const {
        return type == BuiltinOptions_ZerosLikeOptions ? reinterpret_cast<const tflite::ZerosLikeOptionsT *>(value)
                                                       : nullptr;
    }
    tflite::FillOptionsT *AsFillOptions() {
        return type == BuiltinOptions_FillOptions ? reinterpret_cast<tflite::FillOptionsT *>(value) : nullptr;
    }
    const tflite::FillOptionsT *AsFillOptions() const {
        return type == BuiltinOptions_FillOptions ? reinterpret_cast<const tflite::FillOptionsT *>(value) : nullptr;
    }
    tflite::BidirectionalSequenceLSTMOptionsT *AsBidirectionalSequenceLSTMOptions() {
        return type == BuiltinOptions_BidirectionalSequenceLSTMOptions
                   ? reinterpret_cast<tflite::BidirectionalSequenceLSTMOptionsT *>(value)
                   : nullptr;
    }
    const tflite::BidirectionalSequenceLSTMOptionsT *AsBidirectionalSequenceLSTMOptions() const {
        return type == BuiltinOptions_BidirectionalSequenceLSTMOptions
                   ? reinterpret_cast<const tflite::BidirectionalSequenceLSTMOptionsT *>(value)
                   : nullptr;
    }
    tflite::BidirectionalSequenceRNNOptionsT *AsBidirectionalSequenceRNNOptions() {
        return type == BuiltinOptions_BidirectionalSequenceRNNOptions
                   ? reinterpret_cast<tflite::BidirectionalSequenceRNNOptionsT *>(value)
                   : nullptr;
    }
    const tflite::BidirectionalSequenceRNNOptionsT *AsBidirectionalSequenceRNNOptions() const {
        return type == BuiltinOptions_BidirectionalSequenceRNNOptions
                   ? reinterpret_cast<const tflite::BidirectionalSequenceRNNOptionsT *>(value)
                   : nullptr;
    }
    tflite::UnidirectionalSequenceLSTMOptionsT *AsUnidirectionalSequenceLSTMOptions() {
        return type == BuiltinOptions_UnidirectionalSequenceLSTMOptions
                   ? reinterpret_cast<tflite::UnidirectionalSequenceLSTMOptionsT *>(value)
                   : nullptr;
    }
    const tflite::UnidirectionalSequenceLSTMOptionsT *AsUnidirectionalSequenceLSTMOptions() const {
        return type == BuiltinOptions_UnidirectionalSequenceLSTMOptions
                   ? reinterpret_cast<const tflite::UnidirectionalSequenceLSTMOptionsT *>(value)
                   : nullptr;
    }
    tflite::FloorModOptionsT *AsFloorModOptions() {
        return type == BuiltinOptions_FloorModOptions ? reinterpret_cast<tflite::FloorModOptionsT *>(value) : nullptr;
    }
    const tflite::FloorModOptionsT *AsFloorModOptions() const {
        return type == BuiltinOptions_FloorModOptions ? reinterpret_cast<const tflite::FloorModOptionsT *>(value)
                                                      : nullptr;
    }
    tflite::RangeOptionsT *AsRangeOptions() {
        return type == BuiltinOptions_RangeOptions ? reinterpret_cast<tflite::RangeOptionsT *>(value) : nullptr;
    }
    const tflite::RangeOptionsT *AsRangeOptions() const {
        return type == BuiltinOptions_RangeOptions ? reinterpret_cast<const tflite::RangeOptionsT *>(value) : nullptr;
    }
    tflite::ResizeNearestNeighborOptionsT *AsResizeNearestNeighborOptions() {
        return type == BuiltinOptions_ResizeNearestNeighborOptions
                   ? reinterpret_cast<tflite::ResizeNearestNeighborOptionsT *>(value)
                   : nullptr;
    }
    const tflite::ResizeNearestNeighborOptionsT *AsResizeNearestNeighborOptions() const {
        return type == BuiltinOptions_ResizeNearestNeighborOptions
                   ? reinterpret_cast<const tflite::ResizeNearestNeighborOptionsT *>(value)
                   : nullptr;
    }
    tflite::LeakyReluOptionsT *AsLeakyReluOptions() {
        return type == BuiltinOptions_LeakyReluOptions ? reinterpret_cast<tflite::LeakyReluOptionsT *>(value) : nullptr;
    }
    const tflite::LeakyReluOptionsT *AsLeakyReluOptions() const {
        return type == BuiltinOptions_LeakyReluOptions ? reinterpret_cast<const tflite::LeakyReluOptionsT *>(value)
                                                       : nullptr;
    }
    tflite::SquaredDifferenceOptionsT *AsSquaredDifferenceOptions() {
        return type == BuiltinOptions_SquaredDifferenceOptions
                   ? reinterpret_cast<tflite::SquaredDifferenceOptionsT *>(value)
                   : nullptr;
    }
    const tflite::SquaredDifferenceOptionsT *AsSquaredDifferenceOptions() const {
        return type == BuiltinOptions_SquaredDifferenceOptions
                   ? reinterpret_cast<const tflite::SquaredDifferenceOptionsT *>(value)
                   : nullptr;
    }
    tflite::MirrorPadOptionsT *AsMirrorPadOptions() {
        return type == BuiltinOptions_MirrorPadOptions ? reinterpret_cast<tflite::MirrorPadOptionsT *>(value) : nullptr;
    }
    const tflite::MirrorPadOptionsT *AsMirrorPadOptions() const {
        return type == BuiltinOptions_MirrorPadOptions ? reinterpret_cast<const tflite::MirrorPadOptionsT *>(value)
                                                       : nullptr;
    }
    tflite::AbsOptionsT *AsAbsOptions() {
        return type == BuiltinOptions_AbsOptions ? reinterpret_cast<tflite::AbsOptionsT *>(value) : nullptr;
    }
    const tflite::AbsOptionsT *AsAbsOptions() const {
        return type == BuiltinOptions_AbsOptions ? reinterpret_cast<const tflite::AbsOptionsT *>(value) : nullptr;
    }
    tflite::SplitVOptionsT *AsSplitVOptions() {
        return type == BuiltinOptions_SplitVOptions ? reinterpret_cast<tflite::SplitVOptionsT *>(value) : nullptr;
    }
    const tflite::SplitVOptionsT *AsSplitVOptions() const {
        return type == BuiltinOptions_SplitVOptions ? reinterpret_cast<const tflite::SplitVOptionsT *>(value) : nullptr;
    }
    tflite::UniqueOptionsT *AsUniqueOptions() {
        return type == BuiltinOptions_UniqueOptions ? reinterpret_cast<tflite::UniqueOptionsT *>(value) : nullptr;
    }
    const tflite::UniqueOptionsT *AsUniqueOptions() const {
        return type == BuiltinOptions_UniqueOptions ? reinterpret_cast<const tflite::UniqueOptionsT *>(value) : nullptr;
    }
    tflite::ReverseV2OptionsT *AsReverseV2Options() {
        return type == BuiltinOptions_ReverseV2Options ? reinterpret_cast<tflite::ReverseV2OptionsT *>(value) : nullptr;
    }
    const tflite::ReverseV2OptionsT *AsReverseV2Options() const {
        return type == BuiltinOptions_ReverseV2Options ? reinterpret_cast<const tflite::ReverseV2OptionsT *>(value)
                                                       : nullptr;
    }
    tflite::AddNOptionsT *AsAddNOptions() {
        return type == BuiltinOptions_AddNOptions ? reinterpret_cast<tflite::AddNOptionsT *>(value) : nullptr;
    }
    const tflite::AddNOptionsT *AsAddNOptions() const {
        return type == BuiltinOptions_AddNOptions ? reinterpret_cast<const tflite::AddNOptionsT *>(value) : nullptr;
    }
    tflite::GatherNdOptionsT *AsGatherNdOptions() {
        return type == BuiltinOptions_GatherNdOptions ? reinterpret_cast<tflite::GatherNdOptionsT *>(value) : nullptr;
    }
    const tflite::GatherNdOptionsT *AsGatherNdOptions() const {
        return type == BuiltinOptions_GatherNdOptions ? reinterpret_cast<const tflite::GatherNdOptionsT *>(value)
                                                      : nullptr;
    }
    tflite::CosOptionsT *AsCosOptions() {
        return type == BuiltinOptions_CosOptions ? reinterpret_cast<tflite::CosOptionsT *>(value) : nullptr;
    }
    const tflite::CosOptionsT *AsCosOptions() const {
        return type == BuiltinOptions_CosOptions ? reinterpret_cast<const tflite::CosOptionsT *>(value) : nullptr;
    }
    tflite::WhereOptionsT *AsWhereOptions() {
        return type == BuiltinOptions_WhereOptions ? reinterpret_cast<tflite::WhereOptionsT *>(value) : nullptr;
    }
    const tflite::WhereOptionsT *AsWhereOptions() const {
        return type == BuiltinOptions_WhereOptions ? reinterpret_cast<const tflite::WhereOptionsT *>(value) : nullptr;
    }
    tflite::RankOptionsT *AsRankOptions() {
        return type == BuiltinOptions_RankOptions ? reinterpret_cast<tflite::RankOptionsT *>(value) : nullptr;
    }
    const tflite::RankOptionsT *AsRankOptions() const {
        return type == BuiltinOptions_RankOptions ? reinterpret_cast<const tflite::RankOptionsT *>(value) : nullptr;
    }
    tflite::ReverseSequenceOptionsT *AsReverseSequenceOptions() {
        return type == BuiltinOptions_ReverseSequenceOptions
                   ? reinterpret_cast<tflite::ReverseSequenceOptionsT *>(value)
                   : nullptr;
    }
    const tflite::ReverseSequenceOptionsT *AsReverseSequenceOptions() const {
        return type == BuiltinOptions_ReverseSequenceOptions
                   ? reinterpret_cast<const tflite::ReverseSequenceOptionsT *>(value)
                   : nullptr;
    }
    tflite::MatrixDiagOptionsT *AsMatrixDiagOptions() {
        return type == BuiltinOptions_MatrixDiagOptions ? reinterpret_cast<tflite::MatrixDiagOptionsT *>(value)
                                                        : nullptr;
    }
    const tflite::MatrixDiagOptionsT *AsMatrixDiagOptions() const {
        return type == BuiltinOptions_MatrixDiagOptions ? reinterpret_cast<const tflite::MatrixDiagOptionsT *>(value)
                                                        : nullptr;
    }
    tflite::QuantizeOptionsT *AsQuantizeOptions() {
        return type == BuiltinOptions_QuantizeOptions ? reinterpret_cast<tflite::QuantizeOptionsT *>(value) : nullptr;
    }
    const tflite::QuantizeOptionsT *AsQuantizeOptions() const {
        return type == BuiltinOptions_QuantizeOptions ? reinterpret_cast<const tflite::QuantizeOptionsT *>(value)
                                                      : nullptr;
    }
    tflite::MatrixSetDiagOptionsT *AsMatrixSetDiagOptions() {
        return type == BuiltinOptions_MatrixSetDiagOptions ? reinterpret_cast<tflite::MatrixSetDiagOptionsT *>(value)
                                                           : nullptr;
    }
    const tflite::MatrixSetDiagOptionsT *AsMatrixSetDiagOptions() const {
        return type == BuiltinOptions_MatrixSetDiagOptions
                   ? reinterpret_cast<const tflite::MatrixSetDiagOptionsT *>(value)
                   : nullptr;
    }
    tflite::HardSwishOptionsT *AsHardSwishOptions() {
        return type == BuiltinOptions_HardSwishOptions ? reinterpret_cast<tflite::HardSwishOptionsT *>(value) : nullptr;
    }
    const tflite::HardSwishOptionsT *AsHardSwishOptions() const {
        return type == BuiltinOptions_HardSwishOptions ? reinterpret_cast<const tflite::HardSwishOptionsT *>(value)
                                                       : nullptr;
    }
    tflite::IfOptionsT *AsIfOptions() {
        return type == BuiltinOptions_IfOptions ? reinterpret_cast<tflite::IfOptionsT *>(value) : nullptr;
    }
    const tflite::IfOptionsT *AsIfOptions() const {
        return type == BuiltinOptions_IfOptions ? reinterpret_cast<const tflite::IfOptionsT *>(value) : nullptr;
    }
    tflite::WhileOptionsT *AsWhileOptions() {
        return type == BuiltinOptions_WhileOptions ? reinterpret_cast<tflite::WhileOptionsT *>(value) : nullptr;
    }
    const tflite::WhileOptionsT *AsWhileOptions() const {
        return type == BuiltinOptions_WhileOptions ? reinterpret_cast<const tflite::WhileOptionsT *>(value) : nullptr;
    }
    tflite::DepthToSpaceOptionsT *AsDepthToSpaceOptions() {
        return type == BuiltinOptions_DepthToSpaceOptions ? reinterpret_cast<tflite::DepthToSpaceOptionsT *>(value)
                                                          : nullptr;
    }
    const tflite::DepthToSpaceOptionsT *AsDepthToSpaceOptions() const {
        return type == BuiltinOptions_DepthToSpaceOptions
                   ? reinterpret_cast<const tflite::DepthToSpaceOptionsT *>(value)
                   : nullptr;
    }
    tflite::NonMaxSuppressionV4OptionsT *AsNonMaxSuppressionV4Options() {
        return type == BuiltinOptions_NonMaxSuppressionV4Options
                   ? reinterpret_cast<tflite::NonMaxSuppressionV4OptionsT *>(value)
                   : nullptr;
    }
    const tflite::NonMaxSuppressionV4OptionsT *AsNonMaxSuppressionV4Options() const {
        return type == BuiltinOptions_NonMaxSuppressionV4Options
                   ? reinterpret_cast<const tflite::NonMaxSuppressionV4OptionsT *>(value)
                   : nullptr;
    }
    tflite::NonMaxSuppressionV5OptionsT *AsNonMaxSuppressionV5Options() {
        return type == BuiltinOptions_NonMaxSuppressionV5Options
                   ? reinterpret_cast<tflite::NonMaxSuppressionV5OptionsT *>(value)
                   : nullptr;
    }
    const tflite::NonMaxSuppressionV5OptionsT *AsNonMaxSuppressionV5Options() const {
        return type == BuiltinOptions_NonMaxSuppressionV5Options
                   ? reinterpret_cast<const tflite::NonMaxSuppressionV5OptionsT *>(value)
                   : nullptr;
    }
    tflite::ScatterNdOptionsT *AsScatterNdOptions() {
        return type == BuiltinOptions_ScatterNdOptions ? reinterpret_cast<tflite::ScatterNdOptionsT *>(value) : nullptr;
    }
    const tflite::ScatterNdOptionsT *AsScatterNdOptions() const {
        return type == BuiltinOptions_ScatterNdOptions ? reinterpret_cast<const tflite::ScatterNdOptionsT *>(value)
                                                       : nullptr;
    }
    tflite::SelectV2OptionsT *AsSelectV2Options() {
        return type == BuiltinOptions_SelectV2Options ? reinterpret_cast<tflite::SelectV2OptionsT *>(value) : nullptr;
    }
    const tflite::SelectV2OptionsT *AsSelectV2Options() const {
        return type == BuiltinOptions_SelectV2Options ? reinterpret_cast<const tflite::SelectV2OptionsT *>(value)
                                                      : nullptr;
    }
    tflite::DensifyOptionsT *AsDensifyOptions() {
        return type == BuiltinOptions_DensifyOptions ? reinterpret_cast<tflite::DensifyOptionsT *>(value) : nullptr;
    }
    const tflite::DensifyOptionsT *AsDensifyOptions() const {
        return type == BuiltinOptions_DensifyOptions ? reinterpret_cast<const tflite::DensifyOptionsT *>(value)
                                                     : nullptr;
    }
    tflite::SegmentSumOptionsT *AsSegmentSumOptions() {
        return type == BuiltinOptions_SegmentSumOptions ? reinterpret_cast<tflite::SegmentSumOptionsT *>(value)
                                                        : nullptr;
    }
    const tflite::SegmentSumOptionsT *AsSegmentSumOptions() const {
        return type == BuiltinOptions_SegmentSumOptions ? reinterpret_cast<const tflite::SegmentSumOptionsT *>(value)
                                                        : nullptr;
    }
    tflite::BatchMatMulOptionsT *AsBatchMatMulOptions() {
        return type == BuiltinOptions_BatchMatMulOptions ? reinterpret_cast<tflite::BatchMatMulOptionsT *>(value)
                                                         : nullptr;
    }
    const tflite::BatchMatMulOptionsT *AsBatchMatMulOptions() const {
        return type == BuiltinOptions_BatchMatMulOptions ? reinterpret_cast<const tflite::BatchMatMulOptionsT *>(value)
                                                         : nullptr;
    }
};

bool VerifyBuiltinOptions(flatbuffers::Verifier &verifier, const void *obj, BuiltinOptions type);
bool VerifyBuiltinOptionsVector(flatbuffers::Verifier &verifier,
                                const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                                const flatbuffers::Vector<uint8_t> *types);

enum Padding { Padding_SAME = 0, Padding_VALID = 1, Padding_MIN = Padding_SAME, Padding_MAX = Padding_VALID };

inline const Padding (&EnumValuesPadding())[2] {
    static const Padding values[] = {Padding_SAME, Padding_VALID};
    return values;
}

inline const char *const *EnumNamesPadding() {
    static const char *const names[3] = {"SAME", "VALID", nullptr};
    return names;
}

inline const char *EnumNamePadding(Padding e) {
    if (flatbuffers::IsOutRange(e, Padding_SAME, Padding_VALID))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesPadding()[index];
}

enum ActivationFunctionType {
    ActivationFunctionType_NONE         = 0,
    ActivationFunctionType_RELU         = 1,
    ActivationFunctionType_RELU_N1_TO_1 = 2,
    ActivationFunctionType_RELU6        = 3,
    ActivationFunctionType_TANH         = 4,
    ActivationFunctionType_SIGN_BIT     = 5,
    ActivationFunctionType_MIN          = ActivationFunctionType_NONE,
    ActivationFunctionType_MAX          = ActivationFunctionType_SIGN_BIT
};

inline const ActivationFunctionType (&EnumValuesActivationFunctionType())[6] {
    static const ActivationFunctionType values[] = {
        ActivationFunctionType_NONE,  ActivationFunctionType_RELU, ActivationFunctionType_RELU_N1_TO_1,
        ActivationFunctionType_RELU6, ActivationFunctionType_TANH, ActivationFunctionType_SIGN_BIT};
    return values;
}

inline const char *const *EnumNamesActivationFunctionType() {
    static const char *const names[7] = {"NONE", "RELU", "RELU_N1_TO_1", "RELU6", "TANH", "SIGN_BIT", nullptr};
    return names;
}

inline const char *EnumNameActivationFunctionType(ActivationFunctionType e) {
    if (flatbuffers::IsOutRange(e, ActivationFunctionType_NONE, ActivationFunctionType_SIGN_BIT))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesActivationFunctionType()[index];
}

enum LSHProjectionType {
    LSHProjectionType_UNKNOWN = 0,
    LSHProjectionType_SPARSE  = 1,
    LSHProjectionType_DENSE   = 2,
    LSHProjectionType_MIN     = LSHProjectionType_UNKNOWN,
    LSHProjectionType_MAX     = LSHProjectionType_DENSE
};

inline const LSHProjectionType (&EnumValuesLSHProjectionType())[3] {
    static const LSHProjectionType values[] = {LSHProjectionType_UNKNOWN, LSHProjectionType_SPARSE,
                                               LSHProjectionType_DENSE};
    return values;
}

inline const char *const *EnumNamesLSHProjectionType() {
    static const char *const names[4] = {"UNKNOWN", "SPARSE", "DENSE", nullptr};
    return names;
}

inline const char *EnumNameLSHProjectionType(LSHProjectionType e) {
    if (flatbuffers::IsOutRange(e, LSHProjectionType_UNKNOWN, LSHProjectionType_DENSE))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesLSHProjectionType()[index];
}

enum FullyConnectedOptionsWeightsFormat {
    FullyConnectedOptionsWeightsFormat_DEFAULT          = 0,
    FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8 = 1,
    FullyConnectedOptionsWeightsFormat_MIN              = FullyConnectedOptionsWeightsFormat_DEFAULT,
    FullyConnectedOptionsWeightsFormat_MAX              = FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8
};

inline const FullyConnectedOptionsWeightsFormat (&EnumValuesFullyConnectedOptionsWeightsFormat())[2] {
    static const FullyConnectedOptionsWeightsFormat values[] = {FullyConnectedOptionsWeightsFormat_DEFAULT,
                                                                FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8};
    return values;
}

inline const char *const *EnumNamesFullyConnectedOptionsWeightsFormat() {
    static const char *const names[3] = {"DEFAULT", "SHUFFLED4x16INT8", nullptr};
    return names;
}

inline const char *EnumNameFullyConnectedOptionsWeightsFormat(FullyConnectedOptionsWeightsFormat e) {
    if (flatbuffers::IsOutRange(e, FullyConnectedOptionsWeightsFormat_DEFAULT,
                                FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesFullyConnectedOptionsWeightsFormat()[index];
}

enum LSTMKernelType {
    LSTMKernelType_FULL  = 0,
    LSTMKernelType_BASIC = 1,
    LSTMKernelType_MIN   = LSTMKernelType_FULL,
    LSTMKernelType_MAX   = LSTMKernelType_BASIC
};

inline const LSTMKernelType (&EnumValuesLSTMKernelType())[2] {
    static const LSTMKernelType values[] = {LSTMKernelType_FULL, LSTMKernelType_BASIC};
    return values;
}

inline const char *const *EnumNamesLSTMKernelType() {
    static const char *const names[3] = {"FULL", "BASIC", nullptr};
    return names;
}

inline const char *EnumNameLSTMKernelType(LSTMKernelType e) {
    if (flatbuffers::IsOutRange(e, LSTMKernelType_FULL, LSTMKernelType_BASIC))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesLSTMKernelType()[index];
}

enum CombinerType {
    CombinerType_SUM   = 0,
    CombinerType_MEAN  = 1,
    CombinerType_SQRTN = 2,
    CombinerType_MIN   = CombinerType_SUM,
    CombinerType_MAX   = CombinerType_SQRTN
};

inline const CombinerType (&EnumValuesCombinerType())[3] {
    static const CombinerType values[] = {CombinerType_SUM, CombinerType_MEAN, CombinerType_SQRTN};
    return values;
}

inline const char *const *EnumNamesCombinerType() {
    static const char *const names[4] = {"SUM", "MEAN", "SQRTN", nullptr};
    return names;
}

inline const char *EnumNameCombinerType(CombinerType e) {
    if (flatbuffers::IsOutRange(e, CombinerType_SUM, CombinerType_SQRTN))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesCombinerType()[index];
}

enum MirrorPadMode {
    MirrorPadMode_REFLECT   = 0,
    MirrorPadMode_SYMMETRIC = 1,
    MirrorPadMode_MIN       = MirrorPadMode_REFLECT,
    MirrorPadMode_MAX       = MirrorPadMode_SYMMETRIC
};

inline const MirrorPadMode (&EnumValuesMirrorPadMode())[2] {
    static const MirrorPadMode values[] = {MirrorPadMode_REFLECT, MirrorPadMode_SYMMETRIC};
    return values;
}

inline const char *const *EnumNamesMirrorPadMode() {
    static const char *const names[3] = {"REFLECT", "SYMMETRIC", nullptr};
    return names;
}

inline const char *EnumNameMirrorPadMode(MirrorPadMode e) {
    if (flatbuffers::IsOutRange(e, MirrorPadMode_REFLECT, MirrorPadMode_SYMMETRIC))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesMirrorPadMode()[index];
}

enum CustomOptionsFormat {
    CustomOptionsFormat_FLEXBUFFERS = 0,
    CustomOptionsFormat_MIN         = CustomOptionsFormat_FLEXBUFFERS,
    CustomOptionsFormat_MAX         = CustomOptionsFormat_FLEXBUFFERS
};

inline const CustomOptionsFormat (&EnumValuesCustomOptionsFormat())[1] {
    static const CustomOptionsFormat values[] = {CustomOptionsFormat_FLEXBUFFERS};
    return values;
}

inline const char *const *EnumNamesCustomOptionsFormat() {
    static const char *const names[2] = {"FLEXBUFFERS", nullptr};
    return names;
}

inline const char *EnumNameCustomOptionsFormat(CustomOptionsFormat e) {
    if (flatbuffers::IsOutRange(e, CustomOptionsFormat_FLEXBUFFERS, CustomOptionsFormat_FLEXBUFFERS))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesCustomOptionsFormat()[index];
}

struct CustomQuantizationT : public flatbuffers::NativeTable {
    typedef CustomQuantization TableType;
    std::vector<uint8_t> custom;
    CustomQuantizationT() {}
};

struct CustomQuantization FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef CustomQuantizationT NativeTableType;
    typedef CustomQuantizationBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return CustomQuantizationTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_CUSTOM = 4 };
    const flatbuffers::Vector<uint8_t> *custom() const {
        return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CUSTOM);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_CUSTOM) && verifier.VerifyVector(custom()) &&
               verifier.EndTable();
    }
    CustomQuantizationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(CustomQuantizationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<CustomQuantization> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                        const CustomQuantizationT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CustomQuantizationBuilder {
    typedef CustomQuantization Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_custom(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom) {
        fbb_.AddOffset(CustomQuantization::VT_CUSTOM, custom);
    }
    explicit CustomQuantizationBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    CustomQuantizationBuilder &operator=(const CustomQuantizationBuilder &);
    flatbuffers::Offset<CustomQuantization> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<CustomQuantization>(end);
        return o;
    }
};

inline flatbuffers::Offset<CustomQuantization> CreateCustomQuantization(
    flatbuffers::FlatBufferBuilder &_fbb, flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom = 0) {
    CustomQuantizationBuilder builder_(_fbb);
    builder_.add_custom(custom);
    return builder_.Finish();
}

inline flatbuffers::Offset<CustomQuantization> CreateCustomQuantizationDirect(
    flatbuffers::FlatBufferBuilder &_fbb, const std::vector<uint8_t> *custom = nullptr) {
    if (custom) {
        _fbb.ForceVectorAlignment(custom->size(), sizeof(uint8_t), 16);
    }
    auto custom__ = custom ? _fbb.CreateVector<uint8_t>(*custom) : 0;
    return tflite::CreateCustomQuantization(_fbb, custom__);
}

flatbuffers::Offset<CustomQuantization> CreateCustomQuantization(
    flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QuantizationParametersT : public flatbuffers::NativeTable {
    typedef QuantizationParameters TableType;
    std::vector<float> min;
    std::vector<float> max;
    std::vector<float> scale;
    std::vector<int64_t> zero_point;
    tflite::QuantizationDetailsUnion details;
    int32_t quantized_dimension;
    QuantizationParametersT() : quantized_dimension(0) {}
};

struct QuantizationParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef QuantizationParametersT NativeTableType;
    typedef QuantizationParametersBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return QuantizationParametersTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_MIN                 = 4,
        VT_MAX                 = 6,
        VT_SCALE               = 8,
        VT_ZERO_POINT          = 10,
        VT_DETAILS_TYPE        = 12,
        VT_DETAILS             = 14,
        VT_QUANTIZED_DIMENSION = 16
    };
    const flatbuffers::Vector<float> *min() const {
        return GetPointer<const flatbuffers::Vector<float> *>(VT_MIN);
    }
    const flatbuffers::Vector<float> *max() const {
        return GetPointer<const flatbuffers::Vector<float> *>(VT_MAX);
    }
    const flatbuffers::Vector<float> *scale() const {
        return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALE);
    }
    const flatbuffers::Vector<int64_t> *zero_point() const {
        return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_ZERO_POINT);
    }
    tflite::QuantizationDetails details_type() const {
        return static_cast<tflite::QuantizationDetails>(GetField<uint8_t>(VT_DETAILS_TYPE, 0));
    }
    const void *details() const {
        return GetPointer<const void *>(VT_DETAILS);
    }
    template <typename T>
    const T *details_as() const;
    const tflite::CustomQuantization *details_as_CustomQuantization() const {
        return details_type() == tflite::QuantizationDetails_CustomQuantization
                   ? static_cast<const tflite::CustomQuantization *>(details())
                   : nullptr;
    }
    int32_t quantized_dimension() const {
        return GetField<int32_t>(VT_QUANTIZED_DIMENSION, 0);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_MIN) && verifier.VerifyVector(min()) &&
               VerifyOffset(verifier, VT_MAX) && verifier.VerifyVector(max()) && VerifyOffset(verifier, VT_SCALE) &&
               verifier.VerifyVector(scale()) && VerifyOffset(verifier, VT_ZERO_POINT) &&
               verifier.VerifyVector(zero_point()) && VerifyField<uint8_t>(verifier, VT_DETAILS_TYPE) &&
               VerifyOffset(verifier, VT_DETAILS) && VerifyQuantizationDetails(verifier, details(), details_type()) &&
               VerifyField<int32_t>(verifier, VT_QUANTIZED_DIMENSION) && verifier.EndTable();
    }
    QuantizationParametersT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(QuantizationParametersT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<QuantizationParameters> Pack(
        flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT *_o,
        const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template <>
inline const tflite::CustomQuantization *QuantizationParameters::details_as<tflite::CustomQuantization>() const {
    return details_as_CustomQuantization();
}

struct QuantizationParametersBuilder {
    typedef QuantizationParameters Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_min(flatbuffers::Offset<flatbuffers::Vector<float>> min) {
        fbb_.AddOffset(QuantizationParameters::VT_MIN, min);
    }
    void add_max(flatbuffers::Offset<flatbuffers::Vector<float>> max) {
        fbb_.AddOffset(QuantizationParameters::VT_MAX, max);
    }
    void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale) {
        fbb_.AddOffset(QuantizationParameters::VT_SCALE, scale);
    }
    void add_zero_point(flatbuffers::Offset<flatbuffers::Vector<int64_t>> zero_point) {
        fbb_.AddOffset(QuantizationParameters::VT_ZERO_POINT, zero_point);
    }
    void add_details_type(tflite::QuantizationDetails details_type) {
        fbb_.AddElement<uint8_t>(QuantizationParameters::VT_DETAILS_TYPE, static_cast<uint8_t>(details_type), 0);
    }
    void add_details(flatbuffers::Offset<void> details) {
        fbb_.AddOffset(QuantizationParameters::VT_DETAILS, details);
    }
    void add_quantized_dimension(int32_t quantized_dimension) {
        fbb_.AddElement<int32_t>(QuantizationParameters::VT_QUANTIZED_DIMENSION, quantized_dimension, 0);
    }
    explicit QuantizationParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    QuantizationParametersBuilder &operator=(const QuantizationParametersBuilder &);
    flatbuffers::Offset<QuantizationParameters> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<QuantizationParameters>(end);
        return o;
    }
};

inline flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(
    flatbuffers::FlatBufferBuilder &_fbb, flatbuffers::Offset<flatbuffers::Vector<float>> min = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> max = 0, flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> zero_point = 0,
    tflite::QuantizationDetails details_type = tflite::QuantizationDetails_NONE, flatbuffers::Offset<void> details = 0,
    int32_t quantized_dimension = 0) {
    QuantizationParametersBuilder builder_(_fbb);
    builder_.add_quantized_dimension(quantized_dimension);
    builder_.add_details(details);
    builder_.add_zero_point(zero_point);
    builder_.add_scale(scale);
    builder_.add_max(max);
    builder_.add_min(min);
    builder_.add_details_type(details_type);
    return builder_.Finish();
}

inline flatbuffers::Offset<QuantizationParameters> CreateQuantizationParametersDirect(
    flatbuffers::FlatBufferBuilder &_fbb, const std::vector<float> *min = nullptr,
    const std::vector<float> *max = nullptr, const std::vector<float> *scale = nullptr,
    const std::vector<int64_t> *zero_point   = nullptr,
    tflite::QuantizationDetails details_type = tflite::QuantizationDetails_NONE, flatbuffers::Offset<void> details = 0,
    int32_t quantized_dimension = 0) {
    auto min__        = min ? _fbb.CreateVector<float>(*min) : 0;
    auto max__        = max ? _fbb.CreateVector<float>(*max) : 0;
    auto scale__      = scale ? _fbb.CreateVector<float>(*scale) : 0;
    auto zero_point__ = zero_point ? _fbb.CreateVector<int64_t>(*zero_point) : 0;
    return tflite::CreateQuantizationParameters(_fbb, min__, max__, scale__, zero_point__, details_type, details,
                                                quantized_dimension);
}

flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(
    flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Int32VectorT : public flatbuffers::NativeTable {
    typedef Int32Vector TableType;
    std::vector<int32_t> values;
    Int32VectorT() {}
};

struct Int32Vector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef Int32VectorT NativeTableType;
    typedef Int32VectorBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return Int32VectorTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUES = 4 };
    const flatbuffers::Vector<int32_t> *values() const {
        return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_VALUES);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_VALUES) && verifier.VerifyVector(values()) &&
               verifier.EndTable();
    }
    Int32VectorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(Int32VectorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<Int32Vector> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Int32VectorBuilder {
    typedef Int32Vector Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_values(flatbuffers::Offset<flatbuffers::Vector<int32_t>> values) {
        fbb_.AddOffset(Int32Vector::VT_VALUES, values);
    }
    explicit Int32VectorBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    Int32VectorBuilder &operator=(const Int32VectorBuilder &);
    flatbuffers::Offset<Int32Vector> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<Int32Vector>(end);
        return o;
    }
};

inline flatbuffers::Offset<Int32Vector> CreateInt32Vector(
    flatbuffers::FlatBufferBuilder &_fbb, flatbuffers::Offset<flatbuffers::Vector<int32_t>> values = 0) {
    Int32VectorBuilder builder_(_fbb);
    builder_.add_values(values);
    return builder_.Finish();
}

inline flatbuffers::Offset<Int32Vector> CreateInt32VectorDirect(flatbuffers::FlatBufferBuilder &_fbb,
                                                                const std::vector<int32_t> *values = nullptr) {
    auto values__ = values ? _fbb.CreateVector<int32_t>(*values) : 0;
    return tflite::CreateInt32Vector(_fbb, values__);
}

flatbuffers::Offset<Int32Vector> CreateInt32Vector(flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Uint16VectorT : public flatbuffers::NativeTable {
    typedef Uint16Vector TableType;
    std::vector<uint16_t> values;
    Uint16VectorT() {}
};

struct Uint16Vector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef Uint16VectorT NativeTableType;
    typedef Uint16VectorBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return Uint16VectorTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUES = 4 };
    const flatbuffers::Vector<uint16_t> *values() const {
        return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_VALUES);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_VALUES) && verifier.VerifyVector(values()) &&
               verifier.EndTable();
    }
    Uint16VectorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(Uint16VectorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<Uint16Vector> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Uint16VectorT *_o,
                                                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Uint16VectorBuilder {
    typedef Uint16Vector Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_values(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> values) {
        fbb_.AddOffset(Uint16Vector::VT_VALUES, values);
    }
    explicit Uint16VectorBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    Uint16VectorBuilder &operator=(const Uint16VectorBuilder &);
    flatbuffers::Offset<Uint16Vector> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<Uint16Vector>(end);
        return o;
    }
};

inline flatbuffers::Offset<Uint16Vector> CreateUint16Vector(
    flatbuffers::FlatBufferBuilder &_fbb, flatbuffers::Offset<flatbuffers::Vector<uint16_t>> values = 0) {
    Uint16VectorBuilder builder_(_fbb);
    builder_.add_values(values);
    return builder_.Finish();
}

inline flatbuffers::Offset<Uint16Vector> CreateUint16VectorDirect(flatbuffers::FlatBufferBuilder &_fbb,
                                                                  const std::vector<uint16_t> *values = nullptr) {
    if (values) {
        _fbb.ForceVectorAlignment(values->size(), sizeof(uint16_t), 4);
    }
    auto values__ = values ? _fbb.CreateVector<uint16_t>(*values) : 0;
    return tflite::CreateUint16Vector(_fbb, values__);
}

flatbuffers::Offset<Uint16Vector> CreateUint16Vector(flatbuffers::FlatBufferBuilder &_fbb, const Uint16VectorT *_o,
                                                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Uint8VectorT : public flatbuffers::NativeTable {
    typedef Uint8Vector TableType;
    std::vector<uint8_t> values;
    Uint8VectorT() {}
};

struct Uint8Vector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef Uint8VectorT NativeTableType;
    typedef Uint8VectorBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return Uint8VectorTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUES = 4 };
    const flatbuffers::Vector<uint8_t> *values() const {
        return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUES);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_VALUES) && verifier.VerifyVector(values()) &&
               verifier.EndTable();
    }
    Uint8VectorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(Uint8VectorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<Uint8Vector> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Uint8VectorBuilder {
    typedef Uint8Vector Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_values(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> values) {
        fbb_.AddOffset(Uint8Vector::VT_VALUES, values);
    }
    explicit Uint8VectorBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    Uint8VectorBuilder &operator=(const Uint8VectorBuilder &);
    flatbuffers::Offset<Uint8Vector> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<Uint8Vector>(end);
        return o;
    }
};

inline flatbuffers::Offset<Uint8Vector> CreateUint8Vector(
    flatbuffers::FlatBufferBuilder &_fbb, flatbuffers::Offset<flatbuffers::Vector<uint8_t>> values = 0) {
    Uint8VectorBuilder builder_(_fbb);
    builder_.add_values(values);
    return builder_.Finish();
}

inline flatbuffers::Offset<Uint8Vector> CreateUint8VectorDirect(flatbuffers::FlatBufferBuilder &_fbb,
                                                                const std::vector<uint8_t> *values = nullptr) {
    if (values) {
        _fbb.ForceVectorAlignment(values->size(), sizeof(uint8_t), 4);
    }
    auto values__ = values ? _fbb.CreateVector<uint8_t>(*values) : 0;
    return tflite::CreateUint8Vector(_fbb, values__);
}

flatbuffers::Offset<Uint8Vector> CreateUint8Vector(flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DimensionMetadataT : public flatbuffers::NativeTable {
    typedef DimensionMetadata TableType;
    tflite::DimensionType format;
    int32_t dense_size;
    tflite::SparseIndexVectorUnion array_segments;
    tflite::SparseIndexVectorUnion array_indices;
    DimensionMetadataT() : format(tflite::DimensionType_DENSE), dense_size(0) {}
};

struct DimensionMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef DimensionMetadataT NativeTableType;
    typedef DimensionMetadataBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return DimensionMetadataTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_FORMAT              = 4,
        VT_DENSE_SIZE          = 6,
        VT_ARRAY_SEGMENTS_TYPE = 8,
        VT_ARRAY_SEGMENTS      = 10,
        VT_ARRAY_INDICES_TYPE  = 12,
        VT_ARRAY_INDICES       = 14
    };
    tflite::DimensionType format() const {
        return static_cast<tflite::DimensionType>(GetField<int8_t>(VT_FORMAT, 0));
    }
    int32_t dense_size() const {
        return GetField<int32_t>(VT_DENSE_SIZE, 0);
    }
    tflite::SparseIndexVector array_segments_type() const {
        return static_cast<tflite::SparseIndexVector>(GetField<uint8_t>(VT_ARRAY_SEGMENTS_TYPE, 0));
    }
    const void *array_segments() const {
        return GetPointer<const void *>(VT_ARRAY_SEGMENTS);
    }
    template <typename T>
    const T *array_segments_as() const;
    const tflite::Int32Vector *array_segments_as_Int32Vector() const {
        return array_segments_type() == tflite::SparseIndexVector_Int32Vector
                   ? static_cast<const tflite::Int32Vector *>(array_segments())
                   : nullptr;
    }
    const tflite::Uint16Vector *array_segments_as_Uint16Vector() const {
        return array_segments_type() == tflite::SparseIndexVector_Uint16Vector
                   ? static_cast<const tflite::Uint16Vector *>(array_segments())
                   : nullptr;
    }
    const tflite::Uint8Vector *array_segments_as_Uint8Vector() const {
        return array_segments_type() == tflite::SparseIndexVector_Uint8Vector
                   ? static_cast<const tflite::Uint8Vector *>(array_segments())
                   : nullptr;
    }
    tflite::SparseIndexVector array_indices_type() const {
        return static_cast<tflite::SparseIndexVector>(GetField<uint8_t>(VT_ARRAY_INDICES_TYPE, 0));
    }
    const void *array_indices() const {
        return GetPointer<const void *>(VT_ARRAY_INDICES);
    }
    template <typename T>
    const T *array_indices_as() const;
    const tflite::Int32Vector *array_indices_as_Int32Vector() const {
        return array_indices_type() == tflite::SparseIndexVector_Int32Vector
                   ? static_cast<const tflite::Int32Vector *>(array_indices())
                   : nullptr;
    }
    const tflite::Uint16Vector *array_indices_as_Uint16Vector() const {
        return array_indices_type() == tflite::SparseIndexVector_Uint16Vector
                   ? static_cast<const tflite::Uint16Vector *>(array_indices())
                   : nullptr;
    }
    const tflite::Uint8Vector *array_indices_as_Uint8Vector() const {
        return array_indices_type() == tflite::SparseIndexVector_Uint8Vector
                   ? static_cast<const tflite::Uint8Vector *>(array_indices())
                   : nullptr;
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_FORMAT) &&
               VerifyField<int32_t>(verifier, VT_DENSE_SIZE) &&
               VerifyField<uint8_t>(verifier, VT_ARRAY_SEGMENTS_TYPE) && VerifyOffset(verifier, VT_ARRAY_SEGMENTS) &&
               VerifySparseIndexVector(verifier, array_segments(), array_segments_type()) &&
               VerifyField<uint8_t>(verifier, VT_ARRAY_INDICES_TYPE) && VerifyOffset(verifier, VT_ARRAY_INDICES) &&
               VerifySparseIndexVector(verifier, array_indices(), array_indices_type()) && verifier.EndTable();
    }
    DimensionMetadataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(DimensionMetadataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<DimensionMetadata> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                       const DimensionMetadataT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template <>
inline const tflite::Int32Vector *DimensionMetadata::array_segments_as<tflite::Int32Vector>() const {
    return array_segments_as_Int32Vector();
}

template <>
inline const tflite::Uint16Vector *DimensionMetadata::array_segments_as<tflite::Uint16Vector>() const {
    return array_segments_as_Uint16Vector();
}

template <>
inline const tflite::Uint8Vector *DimensionMetadata::array_segments_as<tflite::Uint8Vector>() const {
    return array_segments_as_Uint8Vector();
}

template <>
inline const tflite::Int32Vector *DimensionMetadata::array_indices_as<tflite::Int32Vector>() const {
    return array_indices_as_Int32Vector();
}

template <>
inline const tflite::Uint16Vector *DimensionMetadata::array_indices_as<tflite::Uint16Vector>() const {
    return array_indices_as_Uint16Vector();
}

template <>
inline const tflite::Uint8Vector *DimensionMetadata::array_indices_as<tflite::Uint8Vector>() const {
    return array_indices_as_Uint8Vector();
}

struct DimensionMetadataBuilder {
    typedef DimensionMetadata Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_format(tflite::DimensionType format) {
        fbb_.AddElement<int8_t>(DimensionMetadata::VT_FORMAT, static_cast<int8_t>(format), 0);
    }
    void add_dense_size(int32_t dense_size) {
        fbb_.AddElement<int32_t>(DimensionMetadata::VT_DENSE_SIZE, dense_size, 0);
    }
    void add_array_segments_type(tflite::SparseIndexVector array_segments_type) {
        fbb_.AddElement<uint8_t>(DimensionMetadata::VT_ARRAY_SEGMENTS_TYPE, static_cast<uint8_t>(array_segments_type),
                                 0);
    }
    void add_array_segments(flatbuffers::Offset<void> array_segments) {
        fbb_.AddOffset(DimensionMetadata::VT_ARRAY_SEGMENTS, array_segments);
    }
    void add_array_indices_type(tflite::SparseIndexVector array_indices_type) {
        fbb_.AddElement<uint8_t>(DimensionMetadata::VT_ARRAY_INDICES_TYPE, static_cast<uint8_t>(array_indices_type), 0);
    }
    void add_array_indices(flatbuffers::Offset<void> array_indices) {
        fbb_.AddOffset(DimensionMetadata::VT_ARRAY_INDICES, array_indices);
    }
    explicit DimensionMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    DimensionMetadataBuilder &operator=(const DimensionMetadataBuilder &);
    flatbuffers::Offset<DimensionMetadata> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<DimensionMetadata>(end);
        return o;
    }
};

inline flatbuffers::Offset<DimensionMetadata> CreateDimensionMetadata(
    flatbuffers::FlatBufferBuilder &_fbb, tflite::DimensionType format = tflite::DimensionType_DENSE,
    int32_t dense_size = 0, tflite::SparseIndexVector array_segments_type = tflite::SparseIndexVector_NONE,
    flatbuffers::Offset<void> array_segments     = 0,
    tflite::SparseIndexVector array_indices_type = tflite::SparseIndexVector_NONE,
    flatbuffers::Offset<void> array_indices      = 0) {
    DimensionMetadataBuilder builder_(_fbb);
    builder_.add_array_indices(array_indices);
    builder_.add_array_segments(array_segments);
    builder_.add_dense_size(dense_size);
    builder_.add_array_indices_type(array_indices_type);
    builder_.add_array_segments_type(array_segments_type);
    builder_.add_format(format);
    return builder_.Finish();
}

flatbuffers::Offset<DimensionMetadata> CreateDimensionMetadata(
    flatbuffers::FlatBufferBuilder &_fbb, const DimensionMetadataT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SparsityParametersT : public flatbuffers::NativeTable {
    typedef SparsityParameters TableType;
    std::vector<int32_t> traversal_order;
    std::vector<int32_t> block_map;
    std::vector<std::unique_ptr<tflite::DimensionMetadataT>> dim_metadata;
    SparsityParametersT() {}
};

struct SparsityParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SparsityParametersT NativeTableType;
    typedef SparsityParametersBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SparsityParametersTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_TRAVERSAL_ORDER = 4,
        VT_BLOCK_MAP       = 6,
        VT_DIM_METADATA    = 8
    };
    const flatbuffers::Vector<int32_t> *traversal_order() const {
        return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_TRAVERSAL_ORDER);
    }
    const flatbuffers::Vector<int32_t> *block_map() const {
        return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCK_MAP);
    }
    const flatbuffers::Vector<flatbuffers::Offset<tflite::DimensionMetadata>> *dim_metadata() const {
        return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::DimensionMetadata>> *>(VT_DIM_METADATA);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TRAVERSAL_ORDER) &&
               verifier.VerifyVector(traversal_order()) && VerifyOffset(verifier, VT_BLOCK_MAP) &&
               verifier.VerifyVector(block_map()) && VerifyOffset(verifier, VT_DIM_METADATA) &&
               verifier.VerifyVector(dim_metadata()) && verifier.VerifyVectorOfTables(dim_metadata()) &&
               verifier.EndTable();
    }
    SparsityParametersT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SparsityParametersT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SparsityParameters> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                        const SparsityParametersT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SparsityParametersBuilder {
    typedef SparsityParameters Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_traversal_order(flatbuffers::Offset<flatbuffers::Vector<int32_t>> traversal_order) {
        fbb_.AddOffset(SparsityParameters::VT_TRAVERSAL_ORDER, traversal_order);
    }
    void add_block_map(flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_map) {
        fbb_.AddOffset(SparsityParameters::VT_BLOCK_MAP, block_map);
    }
    void add_dim_metadata(
        flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::DimensionMetadata>>> dim_metadata) {
        fbb_.AddOffset(SparsityParameters::VT_DIM_METADATA, dim_metadata);
    }
    explicit SparsityParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SparsityParametersBuilder &operator=(const SparsityParametersBuilder &);
    flatbuffers::Offset<SparsityParameters> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SparsityParameters>(end);
        return o;
    }
};

inline flatbuffers::Offset<SparsityParameters> CreateSparsityParameters(
    flatbuffers::FlatBufferBuilder &_fbb, flatbuffers::Offset<flatbuffers::Vector<int32_t>> traversal_order = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_map                                           = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::DimensionMetadata>>> dim_metadata = 0) {
    SparsityParametersBuilder builder_(_fbb);
    builder_.add_dim_metadata(dim_metadata);
    builder_.add_block_map(block_map);
    builder_.add_traversal_order(traversal_order);
    return builder_.Finish();
}

inline flatbuffers::Offset<SparsityParameters> CreateSparsityParametersDirect(
    flatbuffers::FlatBufferBuilder &_fbb, const std::vector<int32_t> *traversal_order = nullptr,
    const std::vector<int32_t> *block_map                                           = nullptr,
    const std::vector<flatbuffers::Offset<tflite::DimensionMetadata>> *dim_metadata = nullptr) {
    auto traversal_order__ = traversal_order ? _fbb.CreateVector<int32_t>(*traversal_order) : 0;
    auto block_map__       = block_map ? _fbb.CreateVector<int32_t>(*block_map) : 0;
    auto dim_metadata__ =
        dim_metadata ? _fbb.CreateVector<flatbuffers::Offset<tflite::DimensionMetadata>>(*dim_metadata) : 0;
    return tflite::CreateSparsityParameters(_fbb, traversal_order__, block_map__, dim_metadata__);
}

flatbuffers::Offset<SparsityParameters> CreateSparsityParameters(
    flatbuffers::FlatBufferBuilder &_fbb, const SparsityParametersT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorT : public flatbuffers::NativeTable {
    typedef Tensor TableType;
    std::vector<int32_t> shape;
    tflite::TensorType type;
    uint32_t buffer;
    std::string name;
    std::unique_ptr<tflite::QuantizationParametersT> quantization;
    bool is_variable;
    std::unique_ptr<tflite::SparsityParametersT> sparsity;
    std::vector<int32_t> shape_signature;
    TensorT() : type(tflite::TensorType_FLOAT32), buffer(0), is_variable(false) {}
};

struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef TensorT NativeTableType;
    typedef TensorBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return TensorTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_SHAPE           = 4,
        VT_TYPE            = 6,
        VT_BUFFER          = 8,
        VT_NAME            = 10,
        VT_QUANTIZATION    = 12,
        VT_IS_VARIABLE     = 14,
        VT_SPARSITY        = 16,
        VT_SHAPE_SIGNATURE = 18
    };
    const flatbuffers::Vector<int32_t> *shape() const {
        return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SHAPE);
    }
    tflite::TensorType type() const {
        return static_cast<tflite::TensorType>(GetField<int8_t>(VT_TYPE, 0));
    }
    uint32_t buffer() const {
        return GetField<uint32_t>(VT_BUFFER, 0);
    }
    const flatbuffers::String *name() const {
        return GetPointer<const flatbuffers::String *>(VT_NAME);
    }
    const tflite::QuantizationParameters *quantization() const {
        return GetPointer<const tflite::QuantizationParameters *>(VT_QUANTIZATION);
    }
    bool is_variable() const {
        return GetField<uint8_t>(VT_IS_VARIABLE, 0) != 0;
    }
    const tflite::SparsityParameters *sparsity() const {
        return GetPointer<const tflite::SparsityParameters *>(VT_SPARSITY);
    }
    const flatbuffers::Vector<int32_t> *shape_signature() const {
        return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SHAPE_SIGNATURE);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_SHAPE) && verifier.VerifyVector(shape()) &&
               VerifyField<int8_t>(verifier, VT_TYPE) && VerifyField<uint32_t>(verifier, VT_BUFFER) &&
               VerifyOffset(verifier, VT_NAME) && verifier.VerifyString(name()) &&
               VerifyOffset(verifier, VT_QUANTIZATION) && verifier.VerifyTable(quantization()) &&
               VerifyField<uint8_t>(verifier, VT_IS_VARIABLE) && VerifyOffset(verifier, VT_SPARSITY) &&
               verifier.VerifyTable(sparsity()) && VerifyOffset(verifier, VT_SHAPE_SIGNATURE) &&
               verifier.VerifyVector(shape_signature()) && verifier.EndTable();
    }
    TensorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(TensorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<Tensor> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o,
                                            const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorBuilder {
    typedef Tensor Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape) {
        fbb_.AddOffset(Tensor::VT_SHAPE, shape);
    }
    void add_type(tflite::TensorType type) {
        fbb_.AddElement<int8_t>(Tensor::VT_TYPE, static_cast<int8_t>(type), 0);
    }
    void add_buffer(uint32_t buffer) {
        fbb_.AddElement<uint32_t>(Tensor::VT_BUFFER, buffer, 0);
    }
    void add_name(flatbuffers::Offset<flatbuffers::String> name) {
        fbb_.AddOffset(Tensor::VT_NAME, name);
    }
    void add_quantization(flatbuffers::Offset<tflite::QuantizationParameters> quantization) {
        fbb_.AddOffset(Tensor::VT_QUANTIZATION, quantization);
    }
    void add_is_variable(bool is_variable) {
        fbb_.AddElement<uint8_t>(Tensor::VT_IS_VARIABLE, static_cast<uint8_t>(is_variable), 0);
    }
    void add_sparsity(flatbuffers::Offset<tflite::SparsityParameters> sparsity) {
        fbb_.AddOffset(Tensor::VT_SPARSITY, sparsity);
    }
    void add_shape_signature(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape_signature) {
        fbb_.AddOffset(Tensor::VT_SHAPE_SIGNATURE, shape_signature);
    }
    explicit TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    TensorBuilder &operator=(const TensorBuilder &);
    flatbuffers::Offset<Tensor> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<Tensor>(end);
        return o;
    }
};

inline flatbuffers::Offset<Tensor> CreateTensor(flatbuffers::FlatBufferBuilder &_fbb,
                                                flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape = 0,
                                                tflite::TensorType type = tflite::TensorType_FLOAT32,
                                                uint32_t buffer = 0, flatbuffers::Offset<flatbuffers::String> name = 0,
                                                flatbuffers::Offset<tflite::QuantizationParameters> quantization = 0,
                                                bool is_variable                                         = false,
                                                flatbuffers::Offset<tflite::SparsityParameters> sparsity = 0,
                                                flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape_signature = 0) {
    TensorBuilder builder_(_fbb);
    builder_.add_shape_signature(shape_signature);
    builder_.add_sparsity(sparsity);
    builder_.add_quantization(quantization);
    builder_.add_name(name);
    builder_.add_buffer(buffer);
    builder_.add_shape(shape);
    builder_.add_is_variable(is_variable);
    builder_.add_type(type);
    return builder_.Finish();
}

inline flatbuffers::Offset<Tensor> CreateTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb, const std::vector<int32_t> *shape = nullptr,
    tflite::TensorType type = tflite::TensorType_FLOAT32, uint32_t buffer = 0, const char *name = nullptr,
    flatbuffers::Offset<tflite::QuantizationParameters> quantization = 0, bool is_variable = false,
    flatbuffers::Offset<tflite::SparsityParameters> sparsity = 0,
    const std::vector<int32_t> *shape_signature              = nullptr) {
    auto shape__           = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
    auto name__            = name ? _fbb.CreateString(name) : 0;
    auto shape_signature__ = shape_signature ? _fbb.CreateVector<int32_t>(*shape_signature) : 0;
    return tflite::CreateTensor(_fbb, shape__, type, buffer, name__, quantization, is_variable, sparsity,
                                shape_signature__);
}

flatbuffers::Offset<Tensor> CreateTensor(flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o,
                                         const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Conv2DOptionsT : public flatbuffers::NativeTable {
    typedef Conv2DOptions TableType;
    tflite::Padding padding;
    int32_t stride_w;
    int32_t stride_h;
    tflite::ActivationFunctionType fused_activation_function;
    int32_t dilation_w_factor;
    int32_t dilation_h_factor;
    Conv2DOptionsT()
        : padding(tflite::Padding_SAME),
          stride_w(0),
          stride_h(0),
          fused_activation_function(tflite::ActivationFunctionType_NONE),
          dilation_w_factor(1),
          dilation_h_factor(1) {}
};

struct Conv2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef Conv2DOptionsT NativeTableType;
    typedef Conv2DOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return Conv2DOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_PADDING                   = 4,
        VT_STRIDE_W                  = 6,
        VT_STRIDE_H                  = 8,
        VT_FUSED_ACTIVATION_FUNCTION = 10,
        VT_DILATION_W_FACTOR         = 12,
        VT_DILATION_H_FACTOR         = 14
    };
    tflite::Padding padding() const {
        return static_cast<tflite::Padding>(GetField<int8_t>(VT_PADDING, 0));
    }
    int32_t stride_w() const {
        return GetField<int32_t>(VT_STRIDE_W, 0);
    }
    int32_t stride_h() const {
        return GetField<int32_t>(VT_STRIDE_H, 0);
    }
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    int32_t dilation_w_factor() const {
        return GetField<int32_t>(VT_DILATION_W_FACTOR, 1);
    }
    int32_t dilation_h_factor() const {
        return GetField<int32_t>(VT_DILATION_H_FACTOR, 1);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_PADDING) &&
               VerifyField<int32_t>(verifier, VT_STRIDE_W) && VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
               VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
               VerifyField<int32_t>(verifier, VT_DILATION_W_FACTOR) &&
               VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR) && verifier.EndTable();
    }
    Conv2DOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(Conv2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<Conv2DOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Conv2DOptionsBuilder {
    typedef Conv2DOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_padding(tflite::Padding padding) {
        fbb_.AddElement<int8_t>(Conv2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
    }
    void add_stride_w(int32_t stride_w) {
        fbb_.AddElement<int32_t>(Conv2DOptions::VT_STRIDE_W, stride_w, 0);
    }
    void add_stride_h(int32_t stride_h) {
        fbb_.AddElement<int32_t>(Conv2DOptions::VT_STRIDE_H, stride_h, 0);
    }
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(Conv2DOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    void add_dilation_w_factor(int32_t dilation_w_factor) {
        fbb_.AddElement<int32_t>(Conv2DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
    }
    void add_dilation_h_factor(int32_t dilation_h_factor) {
        fbb_.AddElement<int32_t>(Conv2DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
    }
    explicit Conv2DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    Conv2DOptionsBuilder &operator=(const Conv2DOptionsBuilder &);
    flatbuffers::Offset<Conv2DOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<Conv2DOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(
    flatbuffers::FlatBufferBuilder &_fbb, tflite::Padding padding = tflite::Padding_SAME, int32_t stride_w = 0,
    int32_t stride_h                                         = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    int32_t dilation_w_factor = 1, int32_t dilation_h_factor = 1) {
    Conv2DOptionsBuilder builder_(_fbb);
    builder_.add_dilation_h_factor(dilation_h_factor);
    builder_.add_dilation_w_factor(dilation_w_factor);
    builder_.add_stride_h(stride_h);
    builder_.add_stride_w(stride_w);
    builder_.add_fused_activation_function(fused_activation_function);
    builder_.add_padding(padding);
    return builder_.Finish();
}

flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Pool2DOptionsT : public flatbuffers::NativeTable {
    typedef Pool2DOptions TableType;
    tflite::Padding padding;
    int32_t stride_w;
    int32_t stride_h;
    int32_t filter_width;
    int32_t filter_height;
    tflite::ActivationFunctionType fused_activation_function;
    Pool2DOptionsT()
        : padding(tflite::Padding_SAME),
          stride_w(0),
          stride_h(0),
          filter_width(0),
          filter_height(0),
          fused_activation_function(tflite::ActivationFunctionType_NONE) {}
};

struct Pool2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef Pool2DOptionsT NativeTableType;
    typedef Pool2DOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return Pool2DOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_PADDING                   = 4,
        VT_STRIDE_W                  = 6,
        VT_STRIDE_H                  = 8,
        VT_FILTER_WIDTH              = 10,
        VT_FILTER_HEIGHT             = 12,
        VT_FUSED_ACTIVATION_FUNCTION = 14
    };
    tflite::Padding padding() const {
        return static_cast<tflite::Padding>(GetField<int8_t>(VT_PADDING, 0));
    }
    int32_t stride_w() const {
        return GetField<int32_t>(VT_STRIDE_W, 0);
    }
    int32_t stride_h() const {
        return GetField<int32_t>(VT_STRIDE_H, 0);
    }
    int32_t filter_width() const {
        return GetField<int32_t>(VT_FILTER_WIDTH, 0);
    }
    int32_t filter_height() const {
        return GetField<int32_t>(VT_FILTER_HEIGHT, 0);
    }
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_PADDING) &&
               VerifyField<int32_t>(verifier, VT_STRIDE_W) && VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
               VerifyField<int32_t>(verifier, VT_FILTER_WIDTH) && VerifyField<int32_t>(verifier, VT_FILTER_HEIGHT) &&
               VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) && verifier.EndTable();
    }
    Pool2DOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(Pool2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<Pool2DOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Pool2DOptionsBuilder {
    typedef Pool2DOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_padding(tflite::Padding padding) {
        fbb_.AddElement<int8_t>(Pool2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
    }
    void add_stride_w(int32_t stride_w) {
        fbb_.AddElement<int32_t>(Pool2DOptions::VT_STRIDE_W, stride_w, 0);
    }
    void add_stride_h(int32_t stride_h) {
        fbb_.AddElement<int32_t>(Pool2DOptions::VT_STRIDE_H, stride_h, 0);
    }
    void add_filter_width(int32_t filter_width) {
        fbb_.AddElement<int32_t>(Pool2DOptions::VT_FILTER_WIDTH, filter_width, 0);
    }
    void add_filter_height(int32_t filter_height) {
        fbb_.AddElement<int32_t>(Pool2DOptions::VT_FILTER_HEIGHT, filter_height, 0);
    }
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(Pool2DOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    explicit Pool2DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    Pool2DOptionsBuilder &operator=(const Pool2DOptionsBuilder &);
    flatbuffers::Offset<Pool2DOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<Pool2DOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(
    flatbuffers::FlatBufferBuilder &_fbb, tflite::Padding padding = tflite::Padding_SAME, int32_t stride_w = 0,
    int32_t stride_h = 0, int32_t filter_width = 0, int32_t filter_height = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
    Pool2DOptionsBuilder builder_(_fbb);
    builder_.add_filter_height(filter_height);
    builder_.add_filter_width(filter_width);
    builder_.add_stride_h(stride_h);
    builder_.add_stride_w(stride_w);
    builder_.add_fused_activation_function(fused_activation_function);
    builder_.add_padding(padding);
    return builder_.Finish();
}

flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DepthwiseConv2DOptionsT : public flatbuffers::NativeTable {
    typedef DepthwiseConv2DOptions TableType;
    tflite::Padding padding;
    int32_t stride_w;
    int32_t stride_h;
    int32_t depth_multiplier;
    tflite::ActivationFunctionType fused_activation_function;
    int32_t dilation_w_factor;
    int32_t dilation_h_factor;
    DepthwiseConv2DOptionsT()
        : padding(tflite::Padding_SAME),
          stride_w(0),
          stride_h(0),
          depth_multiplier(0),
          fused_activation_function(tflite::ActivationFunctionType_NONE),
          dilation_w_factor(1),
          dilation_h_factor(1) {}
};

struct DepthwiseConv2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef DepthwiseConv2DOptionsT NativeTableType;
    typedef DepthwiseConv2DOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return DepthwiseConv2DOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_PADDING                   = 4,
        VT_STRIDE_W                  = 6,
        VT_STRIDE_H                  = 8,
        VT_DEPTH_MULTIPLIER          = 10,
        VT_FUSED_ACTIVATION_FUNCTION = 12,
        VT_DILATION_W_FACTOR         = 14,
        VT_DILATION_H_FACTOR         = 16
    };
    tflite::Padding padding() const {
        return static_cast<tflite::Padding>(GetField<int8_t>(VT_PADDING, 0));
    }
    int32_t stride_w() const {
        return GetField<int32_t>(VT_STRIDE_W, 0);
    }
    int32_t stride_h() const {
        return GetField<int32_t>(VT_STRIDE_H, 0);
    }
    int32_t depth_multiplier() const {
        return GetField<int32_t>(VT_DEPTH_MULTIPLIER, 0);
    }
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    int32_t dilation_w_factor() const {
        return GetField<int32_t>(VT_DILATION_W_FACTOR, 1);
    }
    int32_t dilation_h_factor() const {
        return GetField<int32_t>(VT_DILATION_H_FACTOR, 1);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_PADDING) &&
               VerifyField<int32_t>(verifier, VT_STRIDE_W) && VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
               VerifyField<int32_t>(verifier, VT_DEPTH_MULTIPLIER) &&
               VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
               VerifyField<int32_t>(verifier, VT_DILATION_W_FACTOR) &&
               VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR) && verifier.EndTable();
    }
    DepthwiseConv2DOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(DepthwiseConv2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<DepthwiseConv2DOptions> Pack(
        flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT *_o,
        const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DepthwiseConv2DOptionsBuilder {
    typedef DepthwiseConv2DOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_padding(tflite::Padding padding) {
        fbb_.AddElement<int8_t>(DepthwiseConv2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
    }
    void add_stride_w(int32_t stride_w) {
        fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_STRIDE_W, stride_w, 0);
    }
    void add_stride_h(int32_t stride_h) {
        fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_STRIDE_H, stride_h, 0);
    }
    void add_depth_multiplier(int32_t depth_multiplier) {
        fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DEPTH_MULTIPLIER, depth_multiplier, 0);
    }
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(DepthwiseConv2DOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    void add_dilation_w_factor(int32_t dilation_w_factor) {
        fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
    }
    void add_dilation_h_factor(int32_t dilation_h_factor) {
        fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
    }
    explicit DepthwiseConv2DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    DepthwiseConv2DOptionsBuilder &operator=(const DepthwiseConv2DOptionsBuilder &);
    flatbuffers::Offset<DepthwiseConv2DOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<DepthwiseConv2DOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(
    flatbuffers::FlatBufferBuilder &_fbb, tflite::Padding padding = tflite::Padding_SAME, int32_t stride_w = 0,
    int32_t stride_h = 0, int32_t depth_multiplier = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    int32_t dilation_w_factor = 1, int32_t dilation_h_factor = 1) {
    DepthwiseConv2DOptionsBuilder builder_(_fbb);
    builder_.add_dilation_h_factor(dilation_h_factor);
    builder_.add_dilation_w_factor(dilation_w_factor);
    builder_.add_depth_multiplier(depth_multiplier);
    builder_.add_stride_h(stride_h);
    builder_.add_stride_w(stride_w);
    builder_.add_fused_activation_function(fused_activation_function);
    builder_.add_padding(padding);
    return builder_.Finish();
}

flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConcatEmbeddingsOptionsT : public flatbuffers::NativeTable {
    typedef ConcatEmbeddingsOptions TableType;
    int32_t num_channels;
    std::vector<int32_t> num_columns_per_channel;
    std::vector<int32_t> embedding_dim_per_channel;
    ConcatEmbeddingsOptionsT() : num_channels(0) {}
};

struct ConcatEmbeddingsOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ConcatEmbeddingsOptionsT NativeTableType;
    typedef ConcatEmbeddingsOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ConcatEmbeddingsOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_NUM_CHANNELS              = 4,
        VT_NUM_COLUMNS_PER_CHANNEL   = 6,
        VT_EMBEDDING_DIM_PER_CHANNEL = 8
    };
    int32_t num_channels() const {
        return GetField<int32_t>(VT_NUM_CHANNELS, 0);
    }
    const flatbuffers::Vector<int32_t> *num_columns_per_channel() const {
        return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_NUM_COLUMNS_PER_CHANNEL);
    }
    const flatbuffers::Vector<int32_t> *embedding_dim_per_channel() const {
        return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_EMBEDDING_DIM_PER_CHANNEL);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_NUM_CHANNELS) &&
               VerifyOffset(verifier, VT_NUM_COLUMNS_PER_CHANNEL) && verifier.VerifyVector(num_columns_per_channel()) &&
               VerifyOffset(verifier, VT_EMBEDDING_DIM_PER_CHANNEL) &&
               verifier.VerifyVector(embedding_dim_per_channel()) && verifier.EndTable();
    }
    ConcatEmbeddingsOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ConcatEmbeddingsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<ConcatEmbeddingsOptions> Pack(
        flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT *_o,
        const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConcatEmbeddingsOptionsBuilder {
    typedef ConcatEmbeddingsOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_num_channels(int32_t num_channels) {
        fbb_.AddElement<int32_t>(ConcatEmbeddingsOptions::VT_NUM_CHANNELS, num_channels, 0);
    }
    void add_num_columns_per_channel(flatbuffers::Offset<flatbuffers::Vector<int32_t>> num_columns_per_channel) {
        fbb_.AddOffset(ConcatEmbeddingsOptions::VT_NUM_COLUMNS_PER_CHANNEL, num_columns_per_channel);
    }
    void add_embedding_dim_per_channel(flatbuffers::Offset<flatbuffers::Vector<int32_t>> embedding_dim_per_channel) {
        fbb_.AddOffset(ConcatEmbeddingsOptions::VT_EMBEDDING_DIM_PER_CHANNEL, embedding_dim_per_channel);
    }
    explicit ConcatEmbeddingsOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ConcatEmbeddingsOptionsBuilder &operator=(const ConcatEmbeddingsOptionsBuilder &);
    flatbuffers::Offset<ConcatEmbeddingsOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<ConcatEmbeddingsOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(
    flatbuffers::FlatBufferBuilder &_fbb, int32_t num_channels = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> num_columns_per_channel   = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> embedding_dim_per_channel = 0) {
    ConcatEmbeddingsOptionsBuilder builder_(_fbb);
    builder_.add_embedding_dim_per_channel(embedding_dim_per_channel);
    builder_.add_num_columns_per_channel(num_columns_per_channel);
    builder_.add_num_channels(num_channels);
    return builder_.Finish();
}

inline flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb, int32_t num_channels = 0,
    const std::vector<int32_t> *num_columns_per_channel   = nullptr,
    const std::vector<int32_t> *embedding_dim_per_channel = nullptr) {
    auto num_columns_per_channel__ = num_columns_per_channel ? _fbb.CreateVector<int32_t>(*num_columns_per_channel) : 0;
    auto embedding_dim_per_channel__ =
        embedding_dim_per_channel ? _fbb.CreateVector<int32_t>(*embedding_dim_per_channel) : 0;
    return tflite::CreateConcatEmbeddingsOptions(_fbb, num_channels, num_columns_per_channel__,
                                                 embedding_dim_per_channel__);
}

flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LSHProjectionOptionsT : public flatbuffers::NativeTable {
    typedef LSHProjectionOptions TableType;
    tflite::LSHProjectionType type;
    LSHProjectionOptionsT() : type(tflite::LSHProjectionType_UNKNOWN) {}
};

struct LSHProjectionOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef LSHProjectionOptionsT NativeTableType;
    typedef LSHProjectionOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return LSHProjectionOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_TYPE = 4 };
    tflite::LSHProjectionType type() const {
        return static_cast<tflite::LSHProjectionType>(GetField<int8_t>(VT_TYPE, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_TYPE) && verifier.EndTable();
    }
    LSHProjectionOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(LSHProjectionOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<LSHProjectionOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                          const LSHProjectionOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LSHProjectionOptionsBuilder {
    typedef LSHProjectionOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_type(tflite::LSHProjectionType type) {
        fbb_.AddElement<int8_t>(LSHProjectionOptions::VT_TYPE, static_cast<int8_t>(type), 0);
    }
    explicit LSHProjectionOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    LSHProjectionOptionsBuilder &operator=(const LSHProjectionOptionsBuilder &);
    flatbuffers::Offset<LSHProjectionOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<LSHProjectionOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<LSHProjectionOptions> CreateLSHProjectionOptions(
    flatbuffers::FlatBufferBuilder &_fbb, tflite::LSHProjectionType type = tflite::LSHProjectionType_UNKNOWN) {
    LSHProjectionOptionsBuilder builder_(_fbb);
    builder_.add_type(type);
    return builder_.Finish();
}

flatbuffers::Offset<LSHProjectionOptions> CreateLSHProjectionOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SVDFOptionsT : public flatbuffers::NativeTable {
    typedef SVDFOptions TableType;
    int32_t rank;
    tflite::ActivationFunctionType fused_activation_function;
    bool asymmetric_quantize_inputs;
    SVDFOptionsT()
        : rank(0), fused_activation_function(tflite::ActivationFunctionType_NONE), asymmetric_quantize_inputs(false) {}
};

struct SVDFOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SVDFOptionsT NativeTableType;
    typedef SVDFOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SVDFOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_RANK                       = 4,
        VT_FUSED_ACTIVATION_FUNCTION  = 6,
        VT_ASYMMETRIC_QUANTIZE_INPUTS = 8
    };
    int32_t rank() const {
        return GetField<int32_t>(VT_RANK, 0);
    }
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    bool asymmetric_quantize_inputs() const {
        return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_RANK) &&
               VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
               VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) && verifier.EndTable();
    }
    SVDFOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SVDFOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SVDFOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SVDFOptionsBuilder {
    typedef SVDFOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_rank(int32_t rank) {
        fbb_.AddElement<int32_t>(SVDFOptions::VT_RANK, rank, 0);
    }
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(SVDFOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
        fbb_.AddElement<uint8_t>(SVDFOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                                 static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
    }
    explicit SVDFOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SVDFOptionsBuilder &operator=(const SVDFOptionsBuilder &);
    flatbuffers::Offset<SVDFOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SVDFOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(
    flatbuffers::FlatBufferBuilder &_fbb, int32_t rank = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    bool asymmetric_quantize_inputs                          = false) {
    SVDFOptionsBuilder builder_(_fbb);
    builder_.add_rank(rank);
    builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
    builder_.add_fused_activation_function(fused_activation_function);
    return builder_.Finish();
}

flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RNNOptionsT : public flatbuffers::NativeTable {
    typedef RNNOptions TableType;
    tflite::ActivationFunctionType fused_activation_function;
    bool asymmetric_quantize_inputs;
    RNNOptionsT() : fused_activation_function(tflite::ActivationFunctionType_NONE), asymmetric_quantize_inputs(false) {}
};

struct RNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef RNNOptionsT NativeTableType;
    typedef RNNOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return RNNOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_FUSED_ACTIVATION_FUNCTION  = 4,
        VT_ASYMMETRIC_QUANTIZE_INPUTS = 6
    };
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    bool asymmetric_quantize_inputs() const {
        return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
               VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) && verifier.EndTable();
    }
    RNNOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(RNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<RNNOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RNNOptionsBuilder {
    typedef RNNOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(RNNOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
        fbb_.AddElement<uint8_t>(RNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                                 static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
    }
    explicit RNNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    RNNOptionsBuilder &operator=(const RNNOptionsBuilder &);
    flatbuffers::Offset<RNNOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<RNNOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<RNNOptions> CreateRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    bool asymmetric_quantize_inputs                          = false) {
    RNNOptionsBuilder builder_(_fbb);
    builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
    builder_.add_fused_activation_function(fused_activation_function);
    return builder_.Finish();
}

flatbuffers::Offset<RNNOptions> CreateRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SequenceRNNOptionsT : public flatbuffers::NativeTable {
    typedef SequenceRNNOptions TableType;
    bool time_major;
    tflite::ActivationFunctionType fused_activation_function;
    bool asymmetric_quantize_inputs;
    SequenceRNNOptionsT()
        : time_major(false),
          fused_activation_function(tflite::ActivationFunctionType_NONE),
          asymmetric_quantize_inputs(false) {}
};

struct SequenceRNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SequenceRNNOptionsT NativeTableType;
    typedef SequenceRNNOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SequenceRNNOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_TIME_MAJOR                 = 4,
        VT_FUSED_ACTIVATION_FUNCTION  = 6,
        VT_ASYMMETRIC_QUANTIZE_INPUTS = 8
    };
    bool time_major() const {
        return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0;
    }
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    bool asymmetric_quantize_inputs() const {
        return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
               VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
               VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) && verifier.EndTable();
    }
    SequenceRNNOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SequenceRNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SequenceRNNOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                        const SequenceRNNOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SequenceRNNOptionsBuilder {
    typedef SequenceRNNOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_time_major(bool time_major) {
        fbb_.AddElement<uint8_t>(SequenceRNNOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 0);
    }
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(SequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
        fbb_.AddElement<uint8_t>(SequenceRNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                                 static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
    }
    explicit SequenceRNNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SequenceRNNOptionsBuilder &operator=(const SequenceRNNOptionsBuilder &);
    flatbuffers::Offset<SequenceRNNOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SequenceRNNOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb, bool time_major = false,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    bool asymmetric_quantize_inputs                          = false) {
    SequenceRNNOptionsBuilder builder_(_fbb);
    builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
    builder_.add_fused_activation_function(fused_activation_function);
    builder_.add_time_major(time_major);
    return builder_.Finish();
}

flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BidirectionalSequenceRNNOptionsT : public flatbuffers::NativeTable {
    typedef BidirectionalSequenceRNNOptions TableType;
    bool time_major;
    tflite::ActivationFunctionType fused_activation_function;
    bool merge_outputs;
    bool asymmetric_quantize_inputs;
    BidirectionalSequenceRNNOptionsT()
        : time_major(false),
          fused_activation_function(tflite::ActivationFunctionType_NONE),
          merge_outputs(false),
          asymmetric_quantize_inputs(false) {}
};

struct BidirectionalSequenceRNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef BidirectionalSequenceRNNOptionsT NativeTableType;
    typedef BidirectionalSequenceRNNOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return BidirectionalSequenceRNNOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_TIME_MAJOR                 = 4,
        VT_FUSED_ACTIVATION_FUNCTION  = 6,
        VT_MERGE_OUTPUTS              = 8,
        VT_ASYMMETRIC_QUANTIZE_INPUTS = 10
    };
    bool time_major() const {
        return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0;
    }
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    bool merge_outputs() const {
        return GetField<uint8_t>(VT_MERGE_OUTPUTS, 0) != 0;
    }
    bool asymmetric_quantize_inputs() const {
        return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
               VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
               VerifyField<uint8_t>(verifier, VT_MERGE_OUTPUTS) &&
               VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) && verifier.EndTable();
    }
    BidirectionalSequenceRNNOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(BidirectionalSequenceRNNOptionsT *_o,
                  const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<BidirectionalSequenceRNNOptions> Pack(
        flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT *_o,
        const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BidirectionalSequenceRNNOptionsBuilder {
    typedef BidirectionalSequenceRNNOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_time_major(bool time_major) {
        fbb_.AddElement<uint8_t>(BidirectionalSequenceRNNOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 0);
    }
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(BidirectionalSequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    void add_merge_outputs(bool merge_outputs) {
        fbb_.AddElement<uint8_t>(BidirectionalSequenceRNNOptions::VT_MERGE_OUTPUTS, static_cast<uint8_t>(merge_outputs),
                                 0);
    }
    void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
        fbb_.AddElement<uint8_t>(BidirectionalSequenceRNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                                 static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
    }
    explicit BidirectionalSequenceRNNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    BidirectionalSequenceRNNOptionsBuilder &operator=(const BidirectionalSequenceRNNOptionsBuilder &);
    flatbuffers::Offset<BidirectionalSequenceRNNOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<BidirectionalSequenceRNNOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb, bool time_major = false,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    bool merge_outputs = false, bool asymmetric_quantize_inputs = false) {
    BidirectionalSequenceRNNOptionsBuilder builder_(_fbb);
    builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
    builder_.add_merge_outputs(merge_outputs);
    builder_.add_fused_activation_function(fused_activation_function);
    builder_.add_time_major(time_major);
    return builder_.Finish();
}

flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FullyConnectedOptionsT : public flatbuffers::NativeTable {
    typedef FullyConnectedOptions TableType;
    tflite::ActivationFunctionType fused_activation_function;
    tflite::FullyConnectedOptionsWeightsFormat weights_format;
    bool keep_num_dims;
    bool asymmetric_quantize_inputs;
    FullyConnectedOptionsT()
        : fused_activation_function(tflite::ActivationFunctionType_NONE),
          weights_format(tflite::FullyConnectedOptionsWeightsFormat_DEFAULT),
          keep_num_dims(false),
          asymmetric_quantize_inputs(false) {}
};

struct FullyConnectedOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef FullyConnectedOptionsT NativeTableType;
    typedef FullyConnectedOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return FullyConnectedOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_FUSED_ACTIVATION_FUNCTION  = 4,
        VT_WEIGHTS_FORMAT             = 6,
        VT_KEEP_NUM_DIMS              = 8,
        VT_ASYMMETRIC_QUANTIZE_INPUTS = 10
    };
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    tflite::FullyConnectedOptionsWeightsFormat weights_format() const {
        return static_cast<tflite::FullyConnectedOptionsWeightsFormat>(GetField<int8_t>(VT_WEIGHTS_FORMAT, 0));
    }
    bool keep_num_dims() const {
        return GetField<uint8_t>(VT_KEEP_NUM_DIMS, 0) != 0;
    }
    bool asymmetric_quantize_inputs() const {
        return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
               VerifyField<int8_t>(verifier, VT_WEIGHTS_FORMAT) && VerifyField<uint8_t>(verifier, VT_KEEP_NUM_DIMS) &&
               VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) && verifier.EndTable();
    }
    FullyConnectedOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(FullyConnectedOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<FullyConnectedOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                           const FullyConnectedOptionsT *_o,
                                                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FullyConnectedOptionsBuilder {
    typedef FullyConnectedOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(FullyConnectedOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    void add_weights_format(tflite::FullyConnectedOptionsWeightsFormat weights_format) {
        fbb_.AddElement<int8_t>(FullyConnectedOptions::VT_WEIGHTS_FORMAT, static_cast<int8_t>(weights_format), 0);
    }
    void add_keep_num_dims(bool keep_num_dims) {
        fbb_.AddElement<uint8_t>(FullyConnectedOptions::VT_KEEP_NUM_DIMS, static_cast<uint8_t>(keep_num_dims), 0);
    }
    void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
        fbb_.AddElement<uint8_t>(FullyConnectedOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                                 static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
    }
    explicit FullyConnectedOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    FullyConnectedOptionsBuilder &operator=(const FullyConnectedOptionsBuilder &);
    flatbuffers::Offset<FullyConnectedOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<FullyConnectedOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function  = tflite::ActivationFunctionType_NONE,
    tflite::FullyConnectedOptionsWeightsFormat weights_format = tflite::FullyConnectedOptionsWeightsFormat_DEFAULT,
    bool keep_num_dims = false, bool asymmetric_quantize_inputs = false) {
    FullyConnectedOptionsBuilder builder_(_fbb);
    builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
    builder_.add_keep_num_dims(keep_num_dims);
    builder_.add_weights_format(weights_format);
    builder_.add_fused_activation_function(fused_activation_function);
    return builder_.Finish();
}

flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SoftmaxOptionsT : public flatbuffers::NativeTable {
    typedef SoftmaxOptions TableType;
    float beta;
    SoftmaxOptionsT() : beta(0.0f) {}
};

struct SoftmaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SoftmaxOptionsT NativeTableType;
    typedef SoftmaxOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SoftmaxOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_BETA = 4 };
    float beta() const {
        return GetField<float>(VT_BETA, 0.0f);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<float>(verifier, VT_BETA) && verifier.EndTable();
    }
    SoftmaxOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SoftmaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SoftmaxOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT *_o,
                                                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SoftmaxOptionsBuilder {
    typedef SoftmaxOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_beta(float beta) {
        fbb_.AddElement<float>(SoftmaxOptions::VT_BETA, beta, 0.0f);
    }
    explicit SoftmaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SoftmaxOptionsBuilder &operator=(const SoftmaxOptionsBuilder &);
    flatbuffers::Offset<SoftmaxOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SoftmaxOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SoftmaxOptions> CreateSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                float beta = 0.0f) {
    SoftmaxOptionsBuilder builder_(_fbb);
    builder_.add_beta(beta);
    return builder_.Finish();
}

flatbuffers::Offset<SoftmaxOptions> CreateSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                         const SoftmaxOptionsT *_o,
                                                         const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConcatenationOptionsT : public flatbuffers::NativeTable {
    typedef ConcatenationOptions TableType;
    int32_t axis;
    tflite::ActivationFunctionType fused_activation_function;
    ConcatenationOptionsT() : axis(0), fused_activation_function(tflite::ActivationFunctionType_NONE) {}
};

struct ConcatenationOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ConcatenationOptionsT NativeTableType;
    typedef ConcatenationOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ConcatenationOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_AXIS = 4, VT_FUSED_ACTIVATION_FUNCTION = 6 };
    int32_t axis() const {
        return GetField<int32_t>(VT_AXIS, 0);
    }
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_AXIS) &&
               VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) && verifier.EndTable();
    }
    ConcatenationOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ConcatenationOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<ConcatenationOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                          const ConcatenationOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConcatenationOptionsBuilder {
    typedef ConcatenationOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_axis(int32_t axis) {
        fbb_.AddElement<int32_t>(ConcatenationOptions::VT_AXIS, axis, 0);
    }
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(ConcatenationOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    explicit ConcatenationOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ConcatenationOptionsBuilder &operator=(const ConcatenationOptionsBuilder &);
    flatbuffers::Offset<ConcatenationOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<ConcatenationOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(
    flatbuffers::FlatBufferBuilder &_fbb, int32_t axis = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
    ConcatenationOptionsBuilder builder_(_fbb);
    builder_.add_axis(axis);
    builder_.add_fused_activation_function(fused_activation_function);
    return builder_.Finish();
}

flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddOptionsT : public flatbuffers::NativeTable {
    typedef AddOptions TableType;
    tflite::ActivationFunctionType fused_activation_function;
    bool pot_scale_int16;
    AddOptionsT() : fused_activation_function(tflite::ActivationFunctionType_NONE), pot_scale_int16(true) {}
};

struct AddOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef AddOptionsT NativeTableType;
    typedef AddOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return AddOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_FUSED_ACTIVATION_FUNCTION = 4,
        VT_POT_SCALE_INT16           = 6
    };
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    bool pot_scale_int16() const {
        return GetField<uint8_t>(VT_POT_SCALE_INT16, 1) != 0;
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
               VerifyField<uint8_t>(verifier, VT_POT_SCALE_INT16) && verifier.EndTable();
    }
    AddOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(AddOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<AddOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddOptionsBuilder {
    typedef AddOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(AddOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    void add_pot_scale_int16(bool pot_scale_int16) {
        fbb_.AddElement<uint8_t>(AddOptions::VT_POT_SCALE_INT16, static_cast<uint8_t>(pot_scale_int16), 1);
    }
    explicit AddOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    AddOptionsBuilder &operator=(const AddOptionsBuilder &);
    flatbuffers::Offset<AddOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<AddOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<AddOptions> CreateAddOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    bool pot_scale_int16                                     = true) {
    AddOptionsBuilder builder_(_fbb);
    builder_.add_pot_scale_int16(pot_scale_int16);
    builder_.add_fused_activation_function(fused_activation_function);
    return builder_.Finish();
}

flatbuffers::Offset<AddOptions> CreateAddOptions(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MulOptionsT : public flatbuffers::NativeTable {
    typedef MulOptions TableType;
    tflite::ActivationFunctionType fused_activation_function;
    MulOptionsT() : fused_activation_function(tflite::ActivationFunctionType_NONE) {}
};

struct MulOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef MulOptionsT NativeTableType;
    typedef MulOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return MulOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_FUSED_ACTIVATION_FUNCTION = 4 };
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
               verifier.EndTable();
    }
    MulOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(MulOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<MulOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MulOptionsBuilder {
    typedef MulOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(MulOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    explicit MulOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    MulOptionsBuilder &operator=(const MulOptionsBuilder &);
    flatbuffers::Offset<MulOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<MulOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<MulOptions> CreateMulOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
    MulOptionsBuilder builder_(_fbb);
    builder_.add_fused_activation_function(fused_activation_function);
    return builder_.Finish();
}

flatbuffers::Offset<MulOptions> CreateMulOptions(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct L2NormOptionsT : public flatbuffers::NativeTable {
    typedef L2NormOptions TableType;
    tflite::ActivationFunctionType fused_activation_function;
    L2NormOptionsT() : fused_activation_function(tflite::ActivationFunctionType_NONE) {}
};

struct L2NormOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef L2NormOptionsT NativeTableType;
    typedef L2NormOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return L2NormOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_FUSED_ACTIVATION_FUNCTION = 4 };
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
               verifier.EndTable();
    }
    L2NormOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(L2NormOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<L2NormOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct L2NormOptionsBuilder {
    typedef L2NormOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(L2NormOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    explicit L2NormOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    L2NormOptionsBuilder &operator=(const L2NormOptionsBuilder &);
    flatbuffers::Offset<L2NormOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<L2NormOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
    L2NormOptionsBuilder builder_(_fbb);
    builder_.add_fused_activation_function(fused_activation_function);
    return builder_.Finish();
}

flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LocalResponseNormalizationOptionsT : public flatbuffers::NativeTable {
    typedef LocalResponseNormalizationOptions TableType;
    int32_t radius;
    float bias;
    float alpha;
    float beta;
    LocalResponseNormalizationOptionsT() : radius(0), bias(0.0f), alpha(0.0f), beta(0.0f) {}
};

struct LocalResponseNormalizationOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef LocalResponseNormalizationOptionsT NativeTableType;
    typedef LocalResponseNormalizationOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return LocalResponseNormalizationOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_RADIUS = 4,
        VT_BIAS   = 6,
        VT_ALPHA  = 8,
        VT_BETA   = 10
    };
    int32_t radius() const {
        return GetField<int32_t>(VT_RADIUS, 0);
    }
    float bias() const {
        return GetField<float>(VT_BIAS, 0.0f);
    }
    float alpha() const {
        return GetField<float>(VT_ALPHA, 0.0f);
    }
    float beta() const {
        return GetField<float>(VT_BETA, 0.0f);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_RADIUS) &&
               VerifyField<float>(verifier, VT_BIAS) && VerifyField<float>(verifier, VT_ALPHA) &&
               VerifyField<float>(verifier, VT_BETA) && verifier.EndTable();
    }
    LocalResponseNormalizationOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(LocalResponseNormalizationOptionsT *_o,
                  const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<LocalResponseNormalizationOptions> Pack(
        flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT *_o,
        const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LocalResponseNormalizationOptionsBuilder {
    typedef LocalResponseNormalizationOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_radius(int32_t radius) {
        fbb_.AddElement<int32_t>(LocalResponseNormalizationOptions::VT_RADIUS, radius, 0);
    }
    void add_bias(float bias) {
        fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_BIAS, bias, 0.0f);
    }
    void add_alpha(float alpha) {
        fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_ALPHA, alpha, 0.0f);
    }
    void add_beta(float beta) {
        fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_BETA, beta, 0.0f);
    }
    explicit LocalResponseNormalizationOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    LocalResponseNormalizationOptionsBuilder &operator=(const LocalResponseNormalizationOptionsBuilder &);
    flatbuffers::Offset<LocalResponseNormalizationOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<LocalResponseNormalizationOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(
    flatbuffers::FlatBufferBuilder &_fbb, int32_t radius = 0, float bias = 0.0f, float alpha = 0.0f,
    float beta = 0.0f) {
    LocalResponseNormalizationOptionsBuilder builder_(_fbb);
    builder_.add_beta(beta);
    builder_.add_alpha(alpha);
    builder_.add_bias(bias);
    builder_.add_radius(radius);
    return builder_.Finish();
}

flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LSTMOptionsT : public flatbuffers::NativeTable {
    typedef LSTMOptions TableType;
    tflite::ActivationFunctionType fused_activation_function;
    float cell_clip;
    float proj_clip;
    tflite::LSTMKernelType kernel_type;
    bool asymmetric_quantize_inputs;
    LSTMOptionsT()
        : fused_activation_function(tflite::ActivationFunctionType_NONE),
          cell_clip(0.0f),
          proj_clip(0.0f),
          kernel_type(tflite::LSTMKernelType_FULL),
          asymmetric_quantize_inputs(false) {}
};

struct LSTMOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef LSTMOptionsT NativeTableType;
    typedef LSTMOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return LSTMOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_FUSED_ACTIVATION_FUNCTION  = 4,
        VT_CELL_CLIP                  = 6,
        VT_PROJ_CLIP                  = 8,
        VT_KERNEL_TYPE                = 10,
        VT_ASYMMETRIC_QUANTIZE_INPUTS = 12
    };
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    float cell_clip() const {
        return GetField<float>(VT_CELL_CLIP, 0.0f);
    }
    float proj_clip() const {
        return GetField<float>(VT_PROJ_CLIP, 0.0f);
    }
    tflite::LSTMKernelType kernel_type() const {
        return static_cast<tflite::LSTMKernelType>(GetField<int8_t>(VT_KERNEL_TYPE, 0));
    }
    bool asymmetric_quantize_inputs() const {
        return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
               VerifyField<float>(verifier, VT_CELL_CLIP) && VerifyField<float>(verifier, VT_PROJ_CLIP) &&
               VerifyField<int8_t>(verifier, VT_KERNEL_TYPE) &&
               VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) && verifier.EndTable();
    }
    LSTMOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(LSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<LSTMOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LSTMOptionsBuilder {
    typedef LSTMOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(LSTMOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    void add_cell_clip(float cell_clip) {
        fbb_.AddElement<float>(LSTMOptions::VT_CELL_CLIP, cell_clip, 0.0f);
    }
    void add_proj_clip(float proj_clip) {
        fbb_.AddElement<float>(LSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0f);
    }
    void add_kernel_type(tflite::LSTMKernelType kernel_type) {
        fbb_.AddElement<int8_t>(LSTMOptions::VT_KERNEL_TYPE, static_cast<int8_t>(kernel_type), 0);
    }
    void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
        fbb_.AddElement<uint8_t>(LSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                                 static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
    }
    explicit LSTMOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    LSTMOptionsBuilder &operator=(const LSTMOptionsBuilder &);
    flatbuffers::Offset<LSTMOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<LSTMOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    float cell_clip = 0.0f, float proj_clip = 0.0f, tflite::LSTMKernelType kernel_type = tflite::LSTMKernelType_FULL,
    bool asymmetric_quantize_inputs = false) {
    LSTMOptionsBuilder builder_(_fbb);
    builder_.add_proj_clip(proj_clip);
    builder_.add_cell_clip(cell_clip);
    builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
    builder_.add_kernel_type(kernel_type);
    builder_.add_fused_activation_function(fused_activation_function);
    return builder_.Finish();
}

flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnidirectionalSequenceLSTMOptionsT : public flatbuffers::NativeTable {
    typedef UnidirectionalSequenceLSTMOptions TableType;
    tflite::ActivationFunctionType fused_activation_function;
    float cell_clip;
    float proj_clip;
    bool time_major;
    bool asymmetric_quantize_inputs;
    UnidirectionalSequenceLSTMOptionsT()
        : fused_activation_function(tflite::ActivationFunctionType_NONE),
          cell_clip(0.0f),
          proj_clip(0.0f),
          time_major(false),
          asymmetric_quantize_inputs(false) {}
};

struct UnidirectionalSequenceLSTMOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef UnidirectionalSequenceLSTMOptionsT NativeTableType;
    typedef UnidirectionalSequenceLSTMOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return UnidirectionalSequenceLSTMOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_FUSED_ACTIVATION_FUNCTION  = 4,
        VT_CELL_CLIP                  = 6,
        VT_PROJ_CLIP                  = 8,
        VT_TIME_MAJOR                 = 10,
        VT_ASYMMETRIC_QUANTIZE_INPUTS = 12
    };
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    float cell_clip() const {
        return GetField<float>(VT_CELL_CLIP, 0.0f);
    }
    float proj_clip() const {
        return GetField<float>(VT_PROJ_CLIP, 0.0f);
    }
    bool time_major() const {
        return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0;
    }
    bool asymmetric_quantize_inputs() const {
        return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
               VerifyField<float>(verifier, VT_CELL_CLIP) && VerifyField<float>(verifier, VT_PROJ_CLIP) &&
               VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
               VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) && verifier.EndTable();
    }
    UnidirectionalSequenceLSTMOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(UnidirectionalSequenceLSTMOptionsT *_o,
                  const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> Pack(
        flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT *_o,
        const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnidirectionalSequenceLSTMOptionsBuilder {
    typedef UnidirectionalSequenceLSTMOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(UnidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    void add_cell_clip(float cell_clip) {
        fbb_.AddElement<float>(UnidirectionalSequenceLSTMOptions::VT_CELL_CLIP, cell_clip, 0.0f);
    }
    void add_proj_clip(float proj_clip) {
        fbb_.AddElement<float>(UnidirectionalSequenceLSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0f);
    }
    void add_time_major(bool time_major) {
        fbb_.AddElement<uint8_t>(UnidirectionalSequenceLSTMOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 0);
    }
    void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
        fbb_.AddElement<uint8_t>(UnidirectionalSequenceLSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                                 static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
    }
    explicit UnidirectionalSequenceLSTMOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    UnidirectionalSequenceLSTMOptionsBuilder &operator=(const UnidirectionalSequenceLSTMOptionsBuilder &);
    flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<UnidirectionalSequenceLSTMOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> CreateUnidirectionalSequenceLSTMOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    float cell_clip = 0.0f, float proj_clip = 0.0f, bool time_major = false, bool asymmetric_quantize_inputs = false) {
    UnidirectionalSequenceLSTMOptionsBuilder builder_(_fbb);
    builder_.add_proj_clip(proj_clip);
    builder_.add_cell_clip(cell_clip);
    builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
    builder_.add_time_major(time_major);
    builder_.add_fused_activation_function(fused_activation_function);
    return builder_.Finish();
}

flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> CreateUnidirectionalSequenceLSTMOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BidirectionalSequenceLSTMOptionsT : public flatbuffers::NativeTable {
    typedef BidirectionalSequenceLSTMOptions TableType;
    tflite::ActivationFunctionType fused_activation_function;
    float cell_clip;
    float proj_clip;
    bool merge_outputs;
    bool time_major;
    bool asymmetric_quantize_inputs;
    BidirectionalSequenceLSTMOptionsT()
        : fused_activation_function(tflite::ActivationFunctionType_NONE),
          cell_clip(0.0f),
          proj_clip(0.0f),
          merge_outputs(false),
          time_major(true),
          asymmetric_quantize_inputs(false) {}
};

struct BidirectionalSequenceLSTMOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef BidirectionalSequenceLSTMOptionsT NativeTableType;
    typedef BidirectionalSequenceLSTMOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return BidirectionalSequenceLSTMOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_FUSED_ACTIVATION_FUNCTION  = 4,
        VT_CELL_CLIP                  = 6,
        VT_PROJ_CLIP                  = 8,
        VT_MERGE_OUTPUTS              = 10,
        VT_TIME_MAJOR                 = 12,
        VT_ASYMMETRIC_QUANTIZE_INPUTS = 14
    };
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    float cell_clip() const {
        return GetField<float>(VT_CELL_CLIP, 0.0f);
    }
    float proj_clip() const {
        return GetField<float>(VT_PROJ_CLIP, 0.0f);
    }
    bool merge_outputs() const {
        return GetField<uint8_t>(VT_MERGE_OUTPUTS, 0) != 0;
    }
    bool time_major() const {
        return GetField<uint8_t>(VT_TIME_MAJOR, 1) != 0;
    }
    bool asymmetric_quantize_inputs() const {
        return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
               VerifyField<float>(verifier, VT_CELL_CLIP) && VerifyField<float>(verifier, VT_PROJ_CLIP) &&
               VerifyField<uint8_t>(verifier, VT_MERGE_OUTPUTS) && VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
               VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) && verifier.EndTable();
    }
    BidirectionalSequenceLSTMOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(BidirectionalSequenceLSTMOptionsT *_o,
                  const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<BidirectionalSequenceLSTMOptions> Pack(
        flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT *_o,
        const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BidirectionalSequenceLSTMOptionsBuilder {
    typedef BidirectionalSequenceLSTMOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(BidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    void add_cell_clip(float cell_clip) {
        fbb_.AddElement<float>(BidirectionalSequenceLSTMOptions::VT_CELL_CLIP, cell_clip, 0.0f);
    }
    void add_proj_clip(float proj_clip) {
        fbb_.AddElement<float>(BidirectionalSequenceLSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0f);
    }
    void add_merge_outputs(bool merge_outputs) {
        fbb_.AddElement<uint8_t>(BidirectionalSequenceLSTMOptions::VT_MERGE_OUTPUTS,
                                 static_cast<uint8_t>(merge_outputs), 0);
    }
    void add_time_major(bool time_major) {
        fbb_.AddElement<uint8_t>(BidirectionalSequenceLSTMOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 1);
    }
    void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
        fbb_.AddElement<uint8_t>(BidirectionalSequenceLSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                                 static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
    }
    explicit BidirectionalSequenceLSTMOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    BidirectionalSequenceLSTMOptionsBuilder &operator=(const BidirectionalSequenceLSTMOptionsBuilder &);
    flatbuffers::Offset<BidirectionalSequenceLSTMOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<BidirectionalSequenceLSTMOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<BidirectionalSequenceLSTMOptions> CreateBidirectionalSequenceLSTMOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    float cell_clip = 0.0f, float proj_clip = 0.0f, bool merge_outputs = false, bool time_major = true,
    bool asymmetric_quantize_inputs = false) {
    BidirectionalSequenceLSTMOptionsBuilder builder_(_fbb);
    builder_.add_proj_clip(proj_clip);
    builder_.add_cell_clip(cell_clip);
    builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
    builder_.add_time_major(time_major);
    builder_.add_merge_outputs(merge_outputs);
    builder_.add_fused_activation_function(fused_activation_function);
    return builder_.Finish();
}

flatbuffers::Offset<BidirectionalSequenceLSTMOptions> CreateBidirectionalSequenceLSTMOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResizeBilinearOptionsT : public flatbuffers::NativeTable {
    typedef ResizeBilinearOptions TableType;
    bool align_corners;
    bool half_pixel_centers;
    ResizeBilinearOptionsT() : align_corners(false), half_pixel_centers(false) {}
};

struct ResizeBilinearOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ResizeBilinearOptionsT NativeTableType;
    typedef ResizeBilinearOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ResizeBilinearOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_ALIGN_CORNERS      = 8,
        VT_HALF_PIXEL_CENTERS = 10
    };
    bool align_corners() const {
        return GetField<uint8_t>(VT_ALIGN_CORNERS, 0) != 0;
    }
    bool half_pixel_centers() const {
        return GetField<uint8_t>(VT_HALF_PIXEL_CENTERS, 0) != 0;
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_ALIGN_CORNERS) &&
               VerifyField<uint8_t>(verifier, VT_HALF_PIXEL_CENTERS) && verifier.EndTable();
    }
    ResizeBilinearOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ResizeBilinearOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<ResizeBilinearOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                           const ResizeBilinearOptionsT *_o,
                                                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResizeBilinearOptionsBuilder {
    typedef ResizeBilinearOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_align_corners(bool align_corners) {
        fbb_.AddElement<uint8_t>(ResizeBilinearOptions::VT_ALIGN_CORNERS, static_cast<uint8_t>(align_corners), 0);
    }
    void add_half_pixel_centers(bool half_pixel_centers) {
        fbb_.AddElement<uint8_t>(ResizeBilinearOptions::VT_HALF_PIXEL_CENTERS, static_cast<uint8_t>(half_pixel_centers),
                                 0);
    }
    explicit ResizeBilinearOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ResizeBilinearOptionsBuilder &operator=(const ResizeBilinearOptionsBuilder &);
    flatbuffers::Offset<ResizeBilinearOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<ResizeBilinearOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                              bool align_corners      = false,
                                                                              bool half_pixel_centers = false) {
    ResizeBilinearOptionsBuilder builder_(_fbb);
    builder_.add_half_pixel_centers(half_pixel_centers);
    builder_.add_align_corners(align_corners);
    return builder_.Finish();
}

flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResizeNearestNeighborOptionsT : public flatbuffers::NativeTable {
    typedef ResizeNearestNeighborOptions TableType;
    bool align_corners;
    bool half_pixel_centers;
    ResizeNearestNeighborOptionsT() : align_corners(false), half_pixel_centers(false) {}
};

struct ResizeNearestNeighborOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ResizeNearestNeighborOptionsT NativeTableType;
    typedef ResizeNearestNeighborOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ResizeNearestNeighborOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_ALIGN_CORNERS = 4, VT_HALF_PIXEL_CENTERS = 6 };
    bool align_corners() const {
        return GetField<uint8_t>(VT_ALIGN_CORNERS, 0) != 0;
    }
    bool half_pixel_centers() const {
        return GetField<uint8_t>(VT_HALF_PIXEL_CENTERS, 0) != 0;
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_ALIGN_CORNERS) &&
               VerifyField<uint8_t>(verifier, VT_HALF_PIXEL_CENTERS) && verifier.EndTable();
    }
    ResizeNearestNeighborOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ResizeNearestNeighborOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<ResizeNearestNeighborOptions> Pack(
        flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT *_o,
        const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResizeNearestNeighborOptionsBuilder {
    typedef ResizeNearestNeighborOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_align_corners(bool align_corners) {
        fbb_.AddElement<uint8_t>(ResizeNearestNeighborOptions::VT_ALIGN_CORNERS, static_cast<uint8_t>(align_corners),
                                 0);
    }
    void add_half_pixel_centers(bool half_pixel_centers) {
        fbb_.AddElement<uint8_t>(ResizeNearestNeighborOptions::VT_HALF_PIXEL_CENTERS,
                                 static_cast<uint8_t>(half_pixel_centers), 0);
    }
    explicit ResizeNearestNeighborOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ResizeNearestNeighborOptionsBuilder &operator=(const ResizeNearestNeighborOptionsBuilder &);
    flatbuffers::Offset<ResizeNearestNeighborOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<ResizeNearestNeighborOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<ResizeNearestNeighborOptions> CreateResizeNearestNeighborOptions(
    flatbuffers::FlatBufferBuilder &_fbb, bool align_corners = false, bool half_pixel_centers = false) {
    ResizeNearestNeighborOptionsBuilder builder_(_fbb);
    builder_.add_half_pixel_centers(half_pixel_centers);
    builder_.add_align_corners(align_corners);
    return builder_.Finish();
}

flatbuffers::Offset<ResizeNearestNeighborOptions> CreateResizeNearestNeighborOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CallOptionsT : public flatbuffers::NativeTable {
    typedef CallOptions TableType;
    uint32_t subgraph;
    CallOptionsT() : subgraph(0) {}
};

struct CallOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef CallOptionsT NativeTableType;
    typedef CallOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return CallOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_SUBGRAPH = 4 };
    uint32_t subgraph() const {
        return GetField<uint32_t>(VT_SUBGRAPH, 0);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_SUBGRAPH) && verifier.EndTable();
    }
    CallOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(CallOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<CallOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CallOptionsBuilder {
    typedef CallOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_subgraph(uint32_t subgraph) {
        fbb_.AddElement<uint32_t>(CallOptions::VT_SUBGRAPH, subgraph, 0);
    }
    explicit CallOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    CallOptionsBuilder &operator=(const CallOptionsBuilder &);
    flatbuffers::Offset<CallOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<CallOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<CallOptions> CreateCallOptions(flatbuffers::FlatBufferBuilder &_fbb, uint32_t subgraph = 0) {
    CallOptionsBuilder builder_(_fbb);
    builder_.add_subgraph(subgraph);
    return builder_.Finish();
}

flatbuffers::Offset<CallOptions> CreateCallOptions(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PadOptionsT : public flatbuffers::NativeTable {
    typedef PadOptions TableType;
    PadOptionsT() {}
};

struct PadOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef PadOptionsT NativeTableType;
    typedef PadOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return PadOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    PadOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(PadOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<PadOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PadOptionsBuilder {
    typedef PadOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit PadOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    PadOptionsBuilder &operator=(const PadOptionsBuilder &);
    flatbuffers::Offset<PadOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<PadOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<PadOptions> CreatePadOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    PadOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<PadOptions> CreatePadOptions(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PadV2OptionsT : public flatbuffers::NativeTable {
    typedef PadV2Options TableType;
    PadV2OptionsT() {}
};

struct PadV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef PadV2OptionsT NativeTableType;
    typedef PadV2OptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return PadV2OptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    PadV2OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(PadV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<PadV2Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT *_o,
                                                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PadV2OptionsBuilder {
    typedef PadV2Options Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit PadV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    PadV2OptionsBuilder &operator=(const PadV2OptionsBuilder &);
    flatbuffers::Offset<PadV2Options> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<PadV2Options>(end);
        return o;
    }
};

inline flatbuffers::Offset<PadV2Options> CreatePadV2Options(flatbuffers::FlatBufferBuilder &_fbb) {
    PadV2OptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<PadV2Options> CreatePadV2Options(flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT *_o,
                                                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReshapeOptionsT : public flatbuffers::NativeTable {
    typedef ReshapeOptions TableType;
    std::vector<int32_t> new_shape;
    ReshapeOptionsT() {}
};

struct ReshapeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ReshapeOptionsT NativeTableType;
    typedef ReshapeOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ReshapeOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_NEW_SHAPE = 4 };
    const flatbuffers::Vector<int32_t> *new_shape() const {
        return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_NEW_SHAPE);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NEW_SHAPE) &&
               verifier.VerifyVector(new_shape()) && verifier.EndTable();
    }
    ReshapeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ReshapeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<ReshapeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT *_o,
                                                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReshapeOptionsBuilder {
    typedef ReshapeOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_new_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> new_shape) {
        fbb_.AddOffset(ReshapeOptions::VT_NEW_SHAPE, new_shape);
    }
    explicit ReshapeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ReshapeOptionsBuilder &operator=(const ReshapeOptionsBuilder &);
    flatbuffers::Offset<ReshapeOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<ReshapeOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<ReshapeOptions> CreateReshapeOptions(
    flatbuffers::FlatBufferBuilder &_fbb, flatbuffers::Offset<flatbuffers::Vector<int32_t>> new_shape = 0) {
    ReshapeOptionsBuilder builder_(_fbb);
    builder_.add_new_shape(new_shape);
    return builder_.Finish();
}

inline flatbuffers::Offset<ReshapeOptions> CreateReshapeOptionsDirect(flatbuffers::FlatBufferBuilder &_fbb,
                                                                      const std::vector<int32_t> *new_shape = nullptr) {
    auto new_shape__ = new_shape ? _fbb.CreateVector<int32_t>(*new_shape) : 0;
    return tflite::CreateReshapeOptions(_fbb, new_shape__);
}

flatbuffers::Offset<ReshapeOptions> CreateReshapeOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                         const ReshapeOptionsT *_o,
                                                         const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpaceToBatchNDOptionsT : public flatbuffers::NativeTable {
    typedef SpaceToBatchNDOptions TableType;
    SpaceToBatchNDOptionsT() {}
};

struct SpaceToBatchNDOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SpaceToBatchNDOptionsT NativeTableType;
    typedef SpaceToBatchNDOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SpaceToBatchNDOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    SpaceToBatchNDOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SpaceToBatchNDOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SpaceToBatchNDOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                           const SpaceToBatchNDOptionsT *_o,
                                                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpaceToBatchNDOptionsBuilder {
    typedef SpaceToBatchNDOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit SpaceToBatchNDOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SpaceToBatchNDOptionsBuilder &operator=(const SpaceToBatchNDOptionsBuilder &);
    flatbuffers::Offset<SpaceToBatchNDOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SpaceToBatchNDOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SpaceToBatchNDOptions> CreateSpaceToBatchNDOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    SpaceToBatchNDOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<SpaceToBatchNDOptions> CreateSpaceToBatchNDOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchToSpaceNDOptionsT : public flatbuffers::NativeTable {
    typedef BatchToSpaceNDOptions TableType;
    BatchToSpaceNDOptionsT() {}
};

struct BatchToSpaceNDOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef BatchToSpaceNDOptionsT NativeTableType;
    typedef BatchToSpaceNDOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return BatchToSpaceNDOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    BatchToSpaceNDOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(BatchToSpaceNDOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<BatchToSpaceNDOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                           const BatchToSpaceNDOptionsT *_o,
                                                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchToSpaceNDOptionsBuilder {
    typedef BatchToSpaceNDOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit BatchToSpaceNDOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    BatchToSpaceNDOptionsBuilder &operator=(const BatchToSpaceNDOptionsBuilder &);
    flatbuffers::Offset<BatchToSpaceNDOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<BatchToSpaceNDOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<BatchToSpaceNDOptions> CreateBatchToSpaceNDOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    BatchToSpaceNDOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<BatchToSpaceNDOptions> CreateBatchToSpaceNDOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SkipGramOptionsT : public flatbuffers::NativeTable {
    typedef SkipGramOptions TableType;
    int32_t ngram_size;
    int32_t max_skip_size;
    bool include_all_ngrams;
    SkipGramOptionsT() : ngram_size(0), max_skip_size(0), include_all_ngrams(false) {}
};

struct SkipGramOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SkipGramOptionsT NativeTableType;
    typedef SkipGramOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SkipGramOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_NGRAM_SIZE         = 4,
        VT_MAX_SKIP_SIZE      = 6,
        VT_INCLUDE_ALL_NGRAMS = 8
    };
    int32_t ngram_size() const {
        return GetField<int32_t>(VT_NGRAM_SIZE, 0);
    }
    int32_t max_skip_size() const {
        return GetField<int32_t>(VT_MAX_SKIP_SIZE, 0);
    }
    bool include_all_ngrams() const {
        return GetField<uint8_t>(VT_INCLUDE_ALL_NGRAMS, 0) != 0;
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_NGRAM_SIZE) &&
               VerifyField<int32_t>(verifier, VT_MAX_SKIP_SIZE) &&
               VerifyField<uint8_t>(verifier, VT_INCLUDE_ALL_NGRAMS) && verifier.EndTable();
    }
    SkipGramOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SkipGramOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SkipGramOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT *_o,
                                                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SkipGramOptionsBuilder {
    typedef SkipGramOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_ngram_size(int32_t ngram_size) {
        fbb_.AddElement<int32_t>(SkipGramOptions::VT_NGRAM_SIZE, ngram_size, 0);
    }
    void add_max_skip_size(int32_t max_skip_size) {
        fbb_.AddElement<int32_t>(SkipGramOptions::VT_MAX_SKIP_SIZE, max_skip_size, 0);
    }
    void add_include_all_ngrams(bool include_all_ngrams) {
        fbb_.AddElement<uint8_t>(SkipGramOptions::VT_INCLUDE_ALL_NGRAMS, static_cast<uint8_t>(include_all_ngrams), 0);
    }
    explicit SkipGramOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SkipGramOptionsBuilder &operator=(const SkipGramOptionsBuilder &);
    flatbuffers::Offset<SkipGramOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SkipGramOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                  int32_t ngram_size = 0, int32_t max_skip_size = 0,
                                                                  bool include_all_ngrams = false) {
    SkipGramOptionsBuilder builder_(_fbb);
    builder_.add_max_skip_size(max_skip_size);
    builder_.add_ngram_size(ngram_size);
    builder_.add_include_all_ngrams(include_all_ngrams);
    return builder_.Finish();
}

flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                           const SkipGramOptionsT *_o,
                                                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpaceToDepthOptionsT : public flatbuffers::NativeTable {
    typedef SpaceToDepthOptions TableType;
    int32_t block_size;
    SpaceToDepthOptionsT() : block_size(0) {}
};

struct SpaceToDepthOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SpaceToDepthOptionsT NativeTableType;
    typedef SpaceToDepthOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SpaceToDepthOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_BLOCK_SIZE = 4 };
    int32_t block_size() const {
        return GetField<int32_t>(VT_BLOCK_SIZE, 0);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_BLOCK_SIZE) && verifier.EndTable();
    }
    SpaceToDepthOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SpaceToDepthOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SpaceToDepthOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                         const SpaceToDepthOptionsT *_o,
                                                         const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpaceToDepthOptionsBuilder {
    typedef SpaceToDepthOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_block_size(int32_t block_size) {
        fbb_.AddElement<int32_t>(SpaceToDepthOptions::VT_BLOCK_SIZE, block_size, 0);
    }
    explicit SpaceToDepthOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SpaceToDepthOptionsBuilder &operator=(const SpaceToDepthOptionsBuilder &);
    flatbuffers::Offset<SpaceToDepthOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SpaceToDepthOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SpaceToDepthOptions> CreateSpaceToDepthOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                          int32_t block_size = 0) {
    SpaceToDepthOptionsBuilder builder_(_fbb);
    builder_.add_block_size(block_size);
    return builder_.Finish();
}

flatbuffers::Offset<SpaceToDepthOptions> CreateSpaceToDepthOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DepthToSpaceOptionsT : public flatbuffers::NativeTable {
    typedef DepthToSpaceOptions TableType;
    int32_t block_size;
    DepthToSpaceOptionsT() : block_size(0) {}
};

struct DepthToSpaceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef DepthToSpaceOptionsT NativeTableType;
    typedef DepthToSpaceOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return DepthToSpaceOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_BLOCK_SIZE = 4 };
    int32_t block_size() const {
        return GetField<int32_t>(VT_BLOCK_SIZE, 0);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_BLOCK_SIZE) && verifier.EndTable();
    }
    DepthToSpaceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(DepthToSpaceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<DepthToSpaceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                         const DepthToSpaceOptionsT *_o,
                                                         const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DepthToSpaceOptionsBuilder {
    typedef DepthToSpaceOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_block_size(int32_t block_size) {
        fbb_.AddElement<int32_t>(DepthToSpaceOptions::VT_BLOCK_SIZE, block_size, 0);
    }
    explicit DepthToSpaceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    DepthToSpaceOptionsBuilder &operator=(const DepthToSpaceOptionsBuilder &);
    flatbuffers::Offset<DepthToSpaceOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<DepthToSpaceOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<DepthToSpaceOptions> CreateDepthToSpaceOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                          int32_t block_size = 0) {
    DepthToSpaceOptionsBuilder builder_(_fbb);
    builder_.add_block_size(block_size);
    return builder_.Finish();
}

flatbuffers::Offset<DepthToSpaceOptions> CreateDepthToSpaceOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubOptionsT : public flatbuffers::NativeTable {
    typedef SubOptions TableType;
    tflite::ActivationFunctionType fused_activation_function;
    bool pot_scale_int16;
    SubOptionsT() : fused_activation_function(tflite::ActivationFunctionType_NONE), pot_scale_int16(true) {}
};

struct SubOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SubOptionsT NativeTableType;
    typedef SubOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SubOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_FUSED_ACTIVATION_FUNCTION = 4,
        VT_POT_SCALE_INT16           = 6
    };
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    bool pot_scale_int16() const {
        return GetField<uint8_t>(VT_POT_SCALE_INT16, 1) != 0;
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
               VerifyField<uint8_t>(verifier, VT_POT_SCALE_INT16) && verifier.EndTable();
    }
    SubOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SubOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SubOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubOptionsBuilder {
    typedef SubOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(SubOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    void add_pot_scale_int16(bool pot_scale_int16) {
        fbb_.AddElement<uint8_t>(SubOptions::VT_POT_SCALE_INT16, static_cast<uint8_t>(pot_scale_int16), 1);
    }
    explicit SubOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SubOptionsBuilder &operator=(const SubOptionsBuilder &);
    flatbuffers::Offset<SubOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SubOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SubOptions> CreateSubOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    bool pot_scale_int16                                     = true) {
    SubOptionsBuilder builder_(_fbb);
    builder_.add_pot_scale_int16(pot_scale_int16);
    builder_.add_fused_activation_function(fused_activation_function);
    return builder_.Finish();
}

flatbuffers::Offset<SubOptions> CreateSubOptions(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DivOptionsT : public flatbuffers::NativeTable {
    typedef DivOptions TableType;
    tflite::ActivationFunctionType fused_activation_function;
    DivOptionsT() : fused_activation_function(tflite::ActivationFunctionType_NONE) {}
};

struct DivOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef DivOptionsT NativeTableType;
    typedef DivOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return DivOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_FUSED_ACTIVATION_FUNCTION = 4 };
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
               verifier.EndTable();
    }
    DivOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(DivOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<DivOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DivOptionsBuilder {
    typedef DivOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(DivOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    explicit DivOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    DivOptionsBuilder &operator=(const DivOptionsBuilder &);
    flatbuffers::Offset<DivOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<DivOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<DivOptions> CreateDivOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
    DivOptionsBuilder builder_(_fbb);
    builder_.add_fused_activation_function(fused_activation_function);
    return builder_.Finish();
}

flatbuffers::Offset<DivOptions> CreateDivOptions(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TopKV2OptionsT : public flatbuffers::NativeTable {
    typedef TopKV2Options TableType;
    TopKV2OptionsT() {}
};

struct TopKV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef TopKV2OptionsT NativeTableType;
    typedef TopKV2OptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return TopKV2OptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    TopKV2OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(TopKV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<TopKV2Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TopKV2OptionsBuilder {
    typedef TopKV2Options Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit TopKV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    TopKV2OptionsBuilder &operator=(const TopKV2OptionsBuilder &);
    flatbuffers::Offset<TopKV2Options> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<TopKV2Options>(end);
        return o;
    }
};

inline flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(flatbuffers::FlatBufferBuilder &_fbb) {
    TopKV2OptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EmbeddingLookupSparseOptionsT : public flatbuffers::NativeTable {
    typedef EmbeddingLookupSparseOptions TableType;
    tflite::CombinerType combiner;
    EmbeddingLookupSparseOptionsT() : combiner(tflite::CombinerType_SUM) {}
};

struct EmbeddingLookupSparseOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef EmbeddingLookupSparseOptionsT NativeTableType;
    typedef EmbeddingLookupSparseOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return EmbeddingLookupSparseOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_COMBINER = 4 };
    tflite::CombinerType combiner() const {
        return static_cast<tflite::CombinerType>(GetField<int8_t>(VT_COMBINER, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_COMBINER) && verifier.EndTable();
    }
    EmbeddingLookupSparseOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(EmbeddingLookupSparseOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<EmbeddingLookupSparseOptions> Pack(
        flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT *_o,
        const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EmbeddingLookupSparseOptionsBuilder {
    typedef EmbeddingLookupSparseOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_combiner(tflite::CombinerType combiner) {
        fbb_.AddElement<int8_t>(EmbeddingLookupSparseOptions::VT_COMBINER, static_cast<int8_t>(combiner), 0);
    }
    explicit EmbeddingLookupSparseOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    EmbeddingLookupSparseOptionsBuilder &operator=(const EmbeddingLookupSparseOptionsBuilder &);
    flatbuffers::Offset<EmbeddingLookupSparseOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<EmbeddingLookupSparseOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<EmbeddingLookupSparseOptions> CreateEmbeddingLookupSparseOptions(
    flatbuffers::FlatBufferBuilder &_fbb, tflite::CombinerType combiner = tflite::CombinerType_SUM) {
    EmbeddingLookupSparseOptionsBuilder builder_(_fbb);
    builder_.add_combiner(combiner);
    return builder_.Finish();
}

flatbuffers::Offset<EmbeddingLookupSparseOptions> CreateEmbeddingLookupSparseOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GatherOptionsT : public flatbuffers::NativeTable {
    typedef GatherOptions TableType;
    int32_t axis;
    GatherOptionsT() : axis(0) {}
};

struct GatherOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef GatherOptionsT NativeTableType;
    typedef GatherOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return GatherOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_AXIS = 4 };
    int32_t axis() const {
        return GetField<int32_t>(VT_AXIS, 0);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_AXIS) && verifier.EndTable();
    }
    GatherOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(GatherOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<GatherOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GatherOptionsBuilder {
    typedef GatherOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_axis(int32_t axis) {
        fbb_.AddElement<int32_t>(GatherOptions::VT_AXIS, axis, 0);
    }
    explicit GatherOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    GatherOptionsBuilder &operator=(const GatherOptionsBuilder &);
    flatbuffers::Offset<GatherOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<GatherOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<GatherOptions> CreateGatherOptions(flatbuffers::FlatBufferBuilder &_fbb, int32_t axis = 0) {
    GatherOptionsBuilder builder_(_fbb);
    builder_.add_axis(axis);
    return builder_.Finish();
}

flatbuffers::Offset<GatherOptions> CreateGatherOptions(flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransposeOptionsT : public flatbuffers::NativeTable {
    typedef TransposeOptions TableType;
    TransposeOptionsT() {}
};

struct TransposeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef TransposeOptionsT NativeTableType;
    typedef TransposeOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return TransposeOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    TransposeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(TransposeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<TransposeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT *_o,
                                                      const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransposeOptionsBuilder {
    typedef TransposeOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit TransposeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    TransposeOptionsBuilder &operator=(const TransposeOptionsBuilder &);
    flatbuffers::Offset<TransposeOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<TransposeOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<TransposeOptions> CreateTransposeOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    TransposeOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<TransposeOptions> CreateTransposeOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExpOptionsT : public flatbuffers::NativeTable {
    typedef ExpOptions TableType;
    ExpOptionsT() {}
};

struct ExpOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ExpOptionsT NativeTableType;
    typedef ExpOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ExpOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    ExpOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ExpOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<ExpOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpOptionsBuilder {
    typedef ExpOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit ExpOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ExpOptionsBuilder &operator=(const ExpOptionsBuilder &);
    flatbuffers::Offset<ExpOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<ExpOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<ExpOptions> CreateExpOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    ExpOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<ExpOptions> CreateExpOptions(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CosOptionsT : public flatbuffers::NativeTable {
    typedef CosOptions TableType;
    CosOptionsT() {}
};

struct CosOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef CosOptionsT NativeTableType;
    typedef CosOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return CosOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    CosOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(CosOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<CosOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CosOptionsBuilder {
    typedef CosOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit CosOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    CosOptionsBuilder &operator=(const CosOptionsBuilder &);
    flatbuffers::Offset<CosOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<CosOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<CosOptions> CreateCosOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    CosOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<CosOptions> CreateCosOptions(flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReducerOptionsT : public flatbuffers::NativeTable {
    typedef ReducerOptions TableType;
    bool keep_dims;
    ReducerOptionsT() : keep_dims(false) {}
};

struct ReducerOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ReducerOptionsT NativeTableType;
    typedef ReducerOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ReducerOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_KEEP_DIMS = 4 };
    bool keep_dims() const {
        return GetField<uint8_t>(VT_KEEP_DIMS, 0) != 0;
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_KEEP_DIMS) && verifier.EndTable();
    }
    ReducerOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ReducerOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<ReducerOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT *_o,
                                                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReducerOptionsBuilder {
    typedef ReducerOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_keep_dims(bool keep_dims) {
        fbb_.AddElement<uint8_t>(ReducerOptions::VT_KEEP_DIMS, static_cast<uint8_t>(keep_dims), 0);
    }
    explicit ReducerOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ReducerOptionsBuilder &operator=(const ReducerOptionsBuilder &);
    flatbuffers::Offset<ReducerOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<ReducerOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<ReducerOptions> CreateReducerOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                bool keep_dims = false) {
    ReducerOptionsBuilder builder_(_fbb);
    builder_.add_keep_dims(keep_dims);
    return builder_.Finish();
}

flatbuffers::Offset<ReducerOptions> CreateReducerOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                         const ReducerOptionsT *_o,
                                                         const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SqueezeOptionsT : public flatbuffers::NativeTable {
    typedef SqueezeOptions TableType;
    std::vector<int32_t> squeeze_dims;
    SqueezeOptionsT() {}
};

struct SqueezeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SqueezeOptionsT NativeTableType;
    typedef SqueezeOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SqueezeOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_SQUEEZE_DIMS = 4 };
    const flatbuffers::Vector<int32_t> *squeeze_dims() const {
        return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SQUEEZE_DIMS);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_SQUEEZE_DIMS) &&
               verifier.VerifyVector(squeeze_dims()) && verifier.EndTable();
    }
    SqueezeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SqueezeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SqueezeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT *_o,
                                                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SqueezeOptionsBuilder {
    typedef SqueezeOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_squeeze_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> squeeze_dims) {
        fbb_.AddOffset(SqueezeOptions::VT_SQUEEZE_DIMS, squeeze_dims);
    }
    explicit SqueezeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SqueezeOptionsBuilder &operator=(const SqueezeOptionsBuilder &);
    flatbuffers::Offset<SqueezeOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SqueezeOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptions(
    flatbuffers::FlatBufferBuilder &_fbb, flatbuffers::Offset<flatbuffers::Vector<int32_t>> squeeze_dims = 0) {
    SqueezeOptionsBuilder builder_(_fbb);
    builder_.add_squeeze_dims(squeeze_dims);
    return builder_.Finish();
}

inline flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb, const std::vector<int32_t> *squeeze_dims = nullptr) {
    auto squeeze_dims__ = squeeze_dims ? _fbb.CreateVector<int32_t>(*squeeze_dims) : 0;
    return tflite::CreateSqueezeOptions(_fbb, squeeze_dims__);
}

flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                         const SqueezeOptionsT *_o,
                                                         const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SplitOptionsT : public flatbuffers::NativeTable {
    typedef SplitOptions TableType;
    int32_t num_splits;
    SplitOptionsT() : num_splits(0) {}
};

struct SplitOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SplitOptionsT NativeTableType;
    typedef SplitOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SplitOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_NUM_SPLITS = 4 };
    int32_t num_splits() const {
        return GetField<int32_t>(VT_NUM_SPLITS, 0);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_NUM_SPLITS) && verifier.EndTable();
    }
    SplitOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SplitOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SplitOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT *_o,
                                                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SplitOptionsBuilder {
    typedef SplitOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_num_splits(int32_t num_splits) {
        fbb_.AddElement<int32_t>(SplitOptions::VT_NUM_SPLITS, num_splits, 0);
    }
    explicit SplitOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SplitOptionsBuilder &operator=(const SplitOptionsBuilder &);
    flatbuffers::Offset<SplitOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SplitOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SplitOptions> CreateSplitOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                            int32_t num_splits = 0) {
    SplitOptionsBuilder builder_(_fbb);
    builder_.add_num_splits(num_splits);
    return builder_.Finish();
}

flatbuffers::Offset<SplitOptions> CreateSplitOptions(flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT *_o,
                                                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SplitVOptionsT : public flatbuffers::NativeTable {
    typedef SplitVOptions TableType;
    int32_t num_splits;
    SplitVOptionsT() : num_splits(0) {}
};

struct SplitVOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SplitVOptionsT NativeTableType;
    typedef SplitVOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SplitVOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_NUM_SPLITS = 4 };
    int32_t num_splits() const {
        return GetField<int32_t>(VT_NUM_SPLITS, 0);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_NUM_SPLITS) && verifier.EndTable();
    }
    SplitVOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SplitVOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SplitVOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SplitVOptionsBuilder {
    typedef SplitVOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_num_splits(int32_t num_splits) {
        fbb_.AddElement<int32_t>(SplitVOptions::VT_NUM_SPLITS, num_splits, 0);
    }
    explicit SplitVOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SplitVOptionsBuilder &operator=(const SplitVOptionsBuilder &);
    flatbuffers::Offset<SplitVOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SplitVOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SplitVOptions> CreateSplitVOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              int32_t num_splits = 0) {
    SplitVOptionsBuilder builder_(_fbb);
    builder_.add_num_splits(num_splits);
    return builder_.Finish();
}

flatbuffers::Offset<SplitVOptions> CreateSplitVOptions(flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StridedSliceOptionsT : public flatbuffers::NativeTable {
    typedef StridedSliceOptions TableType;
    int32_t begin_mask;
    int32_t end_mask;
    int32_t ellipsis_mask;
    int32_t new_axis_mask;
    int32_t shrink_axis_mask;
    StridedSliceOptionsT() : begin_mask(0), end_mask(0), ellipsis_mask(0), new_axis_mask(0), shrink_axis_mask(0) {}
};

struct StridedSliceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef StridedSliceOptionsT NativeTableType;
    typedef StridedSliceOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return StridedSliceOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_BEGIN_MASK       = 4,
        VT_END_MASK         = 6,
        VT_ELLIPSIS_MASK    = 8,
        VT_NEW_AXIS_MASK    = 10,
        VT_SHRINK_AXIS_MASK = 12
    };
    int32_t begin_mask() const {
        return GetField<int32_t>(VT_BEGIN_MASK, 0);
    }
    int32_t end_mask() const {
        return GetField<int32_t>(VT_END_MASK, 0);
    }
    int32_t ellipsis_mask() const {
        return GetField<int32_t>(VT_ELLIPSIS_MASK, 0);
    }
    int32_t new_axis_mask() const {
        return GetField<int32_t>(VT_NEW_AXIS_MASK, 0);
    }
    int32_t shrink_axis_mask() const {
        return GetField<int32_t>(VT_SHRINK_AXIS_MASK, 0);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_BEGIN_MASK) &&
               VerifyField<int32_t>(verifier, VT_END_MASK) && VerifyField<int32_t>(verifier, VT_ELLIPSIS_MASK) &&
               VerifyField<int32_t>(verifier, VT_NEW_AXIS_MASK) &&
               VerifyField<int32_t>(verifier, VT_SHRINK_AXIS_MASK) && verifier.EndTable();
    }
    StridedSliceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(StridedSliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<StridedSliceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                         const StridedSliceOptionsT *_o,
                                                         const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StridedSliceOptionsBuilder {
    typedef StridedSliceOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_begin_mask(int32_t begin_mask) {
        fbb_.AddElement<int32_t>(StridedSliceOptions::VT_BEGIN_MASK, begin_mask, 0);
    }
    void add_end_mask(int32_t end_mask) {
        fbb_.AddElement<int32_t>(StridedSliceOptions::VT_END_MASK, end_mask, 0);
    }
    void add_ellipsis_mask(int32_t ellipsis_mask) {
        fbb_.AddElement<int32_t>(StridedSliceOptions::VT_ELLIPSIS_MASK, ellipsis_mask, 0);
    }
    void add_new_axis_mask(int32_t new_axis_mask) {
        fbb_.AddElement<int32_t>(StridedSliceOptions::VT_NEW_AXIS_MASK, new_axis_mask, 0);
    }
    void add_shrink_axis_mask(int32_t shrink_axis_mask) {
        fbb_.AddElement<int32_t>(StridedSliceOptions::VT_SHRINK_AXIS_MASK, shrink_axis_mask, 0);
    }
    explicit StridedSliceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    StridedSliceOptionsBuilder &operator=(const StridedSliceOptionsBuilder &);
    flatbuffers::Offset<StridedSliceOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<StridedSliceOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                          int32_t begin_mask = 0, int32_t end_mask = 0,
                                                                          int32_t ellipsis_mask    = 0,
                                                                          int32_t new_axis_mask    = 0,
                                                                          int32_t shrink_axis_mask = 0) {
    StridedSliceOptionsBuilder builder_(_fbb);
    builder_.add_shrink_axis_mask(shrink_axis_mask);
    builder_.add_new_axis_mask(new_axis_mask);
    builder_.add_ellipsis_mask(ellipsis_mask);
    builder_.add_end_mask(end_mask);
    builder_.add_begin_mask(begin_mask);
    return builder_.Finish();
}

flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogSoftmaxOptionsT : public flatbuffers::NativeTable {
    typedef LogSoftmaxOptions TableType;
    LogSoftmaxOptionsT() {}
};

struct LogSoftmaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef LogSoftmaxOptionsT NativeTableType;
    typedef LogSoftmaxOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return LogSoftmaxOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    LogSoftmaxOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(LogSoftmaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<LogSoftmaxOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                       const LogSoftmaxOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogSoftmaxOptionsBuilder {
    typedef LogSoftmaxOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit LogSoftmaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    LogSoftmaxOptionsBuilder &operator=(const LogSoftmaxOptionsBuilder &);
    flatbuffers::Offset<LogSoftmaxOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<LogSoftmaxOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<LogSoftmaxOptions> CreateLogSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    LogSoftmaxOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<LogSoftmaxOptions> CreateLogSoftmaxOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CastOptionsT : public flatbuffers::NativeTable {
    typedef CastOptions TableType;
    tflite::TensorType in_data_type;
    tflite::TensorType out_data_type;
    CastOptionsT() : in_data_type(tflite::TensorType_FLOAT32), out_data_type(tflite::TensorType_FLOAT32) {}
};

struct CastOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef CastOptionsT NativeTableType;
    typedef CastOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return CastOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_IN_DATA_TYPE = 4, VT_OUT_DATA_TYPE = 6 };
    tflite::TensorType in_data_type() const {
        return static_cast<tflite::TensorType>(GetField<int8_t>(VT_IN_DATA_TYPE, 0));
    }
    tflite::TensorType out_data_type() const {
        return static_cast<tflite::TensorType>(GetField<int8_t>(VT_OUT_DATA_TYPE, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_IN_DATA_TYPE) &&
               VerifyField<int8_t>(verifier, VT_OUT_DATA_TYPE) && verifier.EndTable();
    }
    CastOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(CastOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<CastOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CastOptionsBuilder {
    typedef CastOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_in_data_type(tflite::TensorType in_data_type) {
        fbb_.AddElement<int8_t>(CastOptions::VT_IN_DATA_TYPE, static_cast<int8_t>(in_data_type), 0);
    }
    void add_out_data_type(tflite::TensorType out_data_type) {
        fbb_.AddElement<int8_t>(CastOptions::VT_OUT_DATA_TYPE, static_cast<int8_t>(out_data_type), 0);
    }
    explicit CastOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    CastOptionsBuilder &operator=(const CastOptionsBuilder &);
    flatbuffers::Offset<CastOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<CastOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<CastOptions> CreateCastOptions(
    flatbuffers::FlatBufferBuilder &_fbb, tflite::TensorType in_data_type = tflite::TensorType_FLOAT32,
    tflite::TensorType out_data_type = tflite::TensorType_FLOAT32) {
    CastOptionsBuilder builder_(_fbb);
    builder_.add_out_data_type(out_data_type);
    builder_.add_in_data_type(in_data_type);
    return builder_.Finish();
}

flatbuffers::Offset<CastOptions> CreateCastOptions(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DequantizeOptionsT : public flatbuffers::NativeTable {
    typedef DequantizeOptions TableType;
    DequantizeOptionsT() {}
};

struct DequantizeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef DequantizeOptionsT NativeTableType;
    typedef DequantizeOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return DequantizeOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    DequantizeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(DequantizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<DequantizeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                       const DequantizeOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DequantizeOptionsBuilder {
    typedef DequantizeOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit DequantizeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    DequantizeOptionsBuilder &operator=(const DequantizeOptionsBuilder &);
    flatbuffers::Offset<DequantizeOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<DequantizeOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    DequantizeOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MaximumMinimumOptionsT : public flatbuffers::NativeTable {
    typedef MaximumMinimumOptions TableType;
    MaximumMinimumOptionsT() {}
};

struct MaximumMinimumOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef MaximumMinimumOptionsT NativeTableType;
    typedef MaximumMinimumOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return MaximumMinimumOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    MaximumMinimumOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(MaximumMinimumOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<MaximumMinimumOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                           const MaximumMinimumOptionsT *_o,
                                                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MaximumMinimumOptionsBuilder {
    typedef MaximumMinimumOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit MaximumMinimumOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    MaximumMinimumOptionsBuilder &operator=(const MaximumMinimumOptionsBuilder &);
    flatbuffers::Offset<MaximumMinimumOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<MaximumMinimumOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    MaximumMinimumOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TileOptionsT : public flatbuffers::NativeTable {
    typedef TileOptions TableType;
    TileOptionsT() {}
};

struct TileOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef TileOptionsT NativeTableType;
    typedef TileOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return TileOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    TileOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(TileOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<TileOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TileOptionsBuilder {
    typedef TileOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit TileOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    TileOptionsBuilder &operator=(const TileOptionsBuilder &);
    flatbuffers::Offset<TileOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<TileOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<TileOptions> CreateTileOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    TileOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<TileOptions> CreateTileOptions(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArgMaxOptionsT : public flatbuffers::NativeTable {
    typedef ArgMaxOptions TableType;
    tflite::TensorType output_type;
    ArgMaxOptionsT() : output_type(tflite::TensorType_FLOAT32) {}
};

struct ArgMaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ArgMaxOptionsT NativeTableType;
    typedef ArgMaxOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ArgMaxOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_OUTPUT_TYPE = 4 };
    tflite::TensorType output_type() const {
        return static_cast<tflite::TensorType>(GetField<int8_t>(VT_OUTPUT_TYPE, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_OUTPUT_TYPE) && verifier.EndTable();
    }
    ArgMaxOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ArgMaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<ArgMaxOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArgMaxOptionsBuilder {
    typedef ArgMaxOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_output_type(tflite::TensorType output_type) {
        fbb_.AddElement<int8_t>(ArgMaxOptions::VT_OUTPUT_TYPE, static_cast<int8_t>(output_type), 0);
    }
    explicit ArgMaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ArgMaxOptionsBuilder &operator=(const ArgMaxOptionsBuilder &);
    flatbuffers::Offset<ArgMaxOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<ArgMaxOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<ArgMaxOptions> CreateArgMaxOptions(
    flatbuffers::FlatBufferBuilder &_fbb, tflite::TensorType output_type = tflite::TensorType_FLOAT32) {
    ArgMaxOptionsBuilder builder_(_fbb);
    builder_.add_output_type(output_type);
    return builder_.Finish();
}

flatbuffers::Offset<ArgMaxOptions> CreateArgMaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArgMinOptionsT : public flatbuffers::NativeTable {
    typedef ArgMinOptions TableType;
    tflite::TensorType output_type;
    ArgMinOptionsT() : output_type(tflite::TensorType_FLOAT32) {}
};

struct ArgMinOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ArgMinOptionsT NativeTableType;
    typedef ArgMinOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ArgMinOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_OUTPUT_TYPE = 4 };
    tflite::TensorType output_type() const {
        return static_cast<tflite::TensorType>(GetField<int8_t>(VT_OUTPUT_TYPE, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_OUTPUT_TYPE) && verifier.EndTable();
    }
    ArgMinOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ArgMinOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<ArgMinOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArgMinOptionsBuilder {
    typedef ArgMinOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_output_type(tflite::TensorType output_type) {
        fbb_.AddElement<int8_t>(ArgMinOptions::VT_OUTPUT_TYPE, static_cast<int8_t>(output_type), 0);
    }
    explicit ArgMinOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ArgMinOptionsBuilder &operator=(const ArgMinOptionsBuilder &);
    flatbuffers::Offset<ArgMinOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<ArgMinOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<ArgMinOptions> CreateArgMinOptions(
    flatbuffers::FlatBufferBuilder &_fbb, tflite::TensorType output_type = tflite::TensorType_FLOAT32) {
    ArgMinOptionsBuilder builder_(_fbb);
    builder_.add_output_type(output_type);
    return builder_.Finish();
}

flatbuffers::Offset<ArgMinOptions> CreateArgMinOptions(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GreaterOptionsT : public flatbuffers::NativeTable {
    typedef GreaterOptions TableType;
    GreaterOptionsT() {}
};

struct GreaterOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef GreaterOptionsT NativeTableType;
    typedef GreaterOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return GreaterOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    GreaterOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(GreaterOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<GreaterOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT *_o,
                                                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GreaterOptionsBuilder {
    typedef GreaterOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit GreaterOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    GreaterOptionsBuilder &operator=(const GreaterOptionsBuilder &);
    flatbuffers::Offset<GreaterOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<GreaterOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<GreaterOptions> CreateGreaterOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    GreaterOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<GreaterOptions> CreateGreaterOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                         const GreaterOptionsT *_o,
                                                         const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GreaterEqualOptionsT : public flatbuffers::NativeTable {
    typedef GreaterEqualOptions TableType;
    GreaterEqualOptionsT() {}
};

struct GreaterEqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef GreaterEqualOptionsT NativeTableType;
    typedef GreaterEqualOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return GreaterEqualOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    GreaterEqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(GreaterEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<GreaterEqualOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                         const GreaterEqualOptionsT *_o,
                                                         const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GreaterEqualOptionsBuilder {
    typedef GreaterEqualOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit GreaterEqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    GreaterEqualOptionsBuilder &operator=(const GreaterEqualOptionsBuilder &);
    flatbuffers::Offset<GreaterEqualOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<GreaterEqualOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<GreaterEqualOptions> CreateGreaterEqualOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    GreaterEqualOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<GreaterEqualOptions> CreateGreaterEqualOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LessOptionsT : public flatbuffers::NativeTable {
    typedef LessOptions TableType;
    LessOptionsT() {}
};

struct LessOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef LessOptionsT NativeTableType;
    typedef LessOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return LessOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    LessOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(LessOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<LessOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LessOptionsBuilder {
    typedef LessOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit LessOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    LessOptionsBuilder &operator=(const LessOptionsBuilder &);
    flatbuffers::Offset<LessOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<LessOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<LessOptions> CreateLessOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    LessOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<LessOptions> CreateLessOptions(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LessEqualOptionsT : public flatbuffers::NativeTable {
    typedef LessEqualOptions TableType;
    LessEqualOptionsT() {}
};

struct LessEqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef LessEqualOptionsT NativeTableType;
    typedef LessEqualOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return LessEqualOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    LessEqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(LessEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<LessEqualOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT *_o,
                                                      const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LessEqualOptionsBuilder {
    typedef LessEqualOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit LessEqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    LessEqualOptionsBuilder &operator=(const LessEqualOptionsBuilder &);
    flatbuffers::Offset<LessEqualOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<LessEqualOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<LessEqualOptions> CreateLessEqualOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    LessEqualOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<LessEqualOptions> CreateLessEqualOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NegOptionsT : public flatbuffers::NativeTable {
    typedef NegOptions TableType;
    NegOptionsT() {}
};

struct NegOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef NegOptionsT NativeTableType;
    typedef NegOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return NegOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    NegOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(NegOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<NegOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NegOptionsBuilder {
    typedef NegOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit NegOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    NegOptionsBuilder &operator=(const NegOptionsBuilder &);
    flatbuffers::Offset<NegOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<NegOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<NegOptions> CreateNegOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    NegOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<NegOptions> CreateNegOptions(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SelectOptionsT : public flatbuffers::NativeTable {
    typedef SelectOptions TableType;
    SelectOptionsT() {}
};

struct SelectOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SelectOptionsT NativeTableType;
    typedef SelectOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SelectOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    SelectOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SelectOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SelectOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SelectOptionsBuilder {
    typedef SelectOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit SelectOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SelectOptionsBuilder &operator=(const SelectOptionsBuilder &);
    flatbuffers::Offset<SelectOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SelectOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SelectOptions> CreateSelectOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    SelectOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<SelectOptions> CreateSelectOptions(flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SliceOptionsT : public flatbuffers::NativeTable {
    typedef SliceOptions TableType;
    SliceOptionsT() {}
};

struct SliceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SliceOptionsT NativeTableType;
    typedef SliceOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SliceOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    SliceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SliceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT *_o,
                                                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SliceOptionsBuilder {
    typedef SliceOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit SliceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SliceOptionsBuilder &operator=(const SliceOptionsBuilder &);
    flatbuffers::Offset<SliceOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SliceOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SliceOptions> CreateSliceOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    SliceOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<SliceOptions> CreateSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT *_o,
                                                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransposeConvOptionsT : public flatbuffers::NativeTable {
    typedef TransposeConvOptions TableType;
    tflite::Padding padding;
    int32_t stride_w;
    int32_t stride_h;
    TransposeConvOptionsT() : padding(tflite::Padding_SAME), stride_w(0), stride_h(0) {}
};

struct TransposeConvOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef TransposeConvOptionsT NativeTableType;
    typedef TransposeConvOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return TransposeConvOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_PADDING  = 4,
        VT_STRIDE_W = 6,
        VT_STRIDE_H = 8
    };
    tflite::Padding padding() const {
        return static_cast<tflite::Padding>(GetField<int8_t>(VT_PADDING, 0));
    }
    int32_t stride_w() const {
        return GetField<int32_t>(VT_STRIDE_W, 0);
    }
    int32_t stride_h() const {
        return GetField<int32_t>(VT_STRIDE_H, 0);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_PADDING) &&
               VerifyField<int32_t>(verifier, VT_STRIDE_W) && VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
               verifier.EndTable();
    }
    TransposeConvOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(TransposeConvOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<TransposeConvOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                          const TransposeConvOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransposeConvOptionsBuilder {
    typedef TransposeConvOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_padding(tflite::Padding padding) {
        fbb_.AddElement<int8_t>(TransposeConvOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
    }
    void add_stride_w(int32_t stride_w) {
        fbb_.AddElement<int32_t>(TransposeConvOptions::VT_STRIDE_W, stride_w, 0);
    }
    void add_stride_h(int32_t stride_h) {
        fbb_.AddElement<int32_t>(TransposeConvOptions::VT_STRIDE_H, stride_h, 0);
    }
    explicit TransposeConvOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    TransposeConvOptionsBuilder &operator=(const TransposeConvOptionsBuilder &);
    flatbuffers::Offset<TransposeConvOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<TransposeConvOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(
    flatbuffers::FlatBufferBuilder &_fbb, tflite::Padding padding = tflite::Padding_SAME, int32_t stride_w = 0,
    int32_t stride_h = 0) {
    TransposeConvOptionsBuilder builder_(_fbb);
    builder_.add_stride_h(stride_h);
    builder_.add_stride_w(stride_w);
    builder_.add_padding(padding);
    return builder_.Finish();
}

flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExpandDimsOptionsT : public flatbuffers::NativeTable {
    typedef ExpandDimsOptions TableType;
    ExpandDimsOptionsT() {}
};

struct ExpandDimsOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ExpandDimsOptionsT NativeTableType;
    typedef ExpandDimsOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ExpandDimsOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    ExpandDimsOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ExpandDimsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<ExpandDimsOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                       const ExpandDimsOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpandDimsOptionsBuilder {
    typedef ExpandDimsOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit ExpandDimsOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ExpandDimsOptionsBuilder &operator=(const ExpandDimsOptionsBuilder &);
    flatbuffers::Offset<ExpandDimsOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<ExpandDimsOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<ExpandDimsOptions> CreateExpandDimsOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    ExpandDimsOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<ExpandDimsOptions> CreateExpandDimsOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SparseToDenseOptionsT : public flatbuffers::NativeTable {
    typedef SparseToDenseOptions TableType;
    bool validate_indices;
    SparseToDenseOptionsT() : validate_indices(false) {}
};

struct SparseToDenseOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SparseToDenseOptionsT NativeTableType;
    typedef SparseToDenseOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SparseToDenseOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALIDATE_INDICES = 4 };
    bool validate_indices() const {
        return GetField<uint8_t>(VT_VALIDATE_INDICES, 0) != 0;
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_VALIDATE_INDICES) && verifier.EndTable();
    }
    SparseToDenseOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SparseToDenseOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SparseToDenseOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                          const SparseToDenseOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SparseToDenseOptionsBuilder {
    typedef SparseToDenseOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_validate_indices(bool validate_indices) {
        fbb_.AddElement<uint8_t>(SparseToDenseOptions::VT_VALIDATE_INDICES, static_cast<uint8_t>(validate_indices), 0);
    }
    explicit SparseToDenseOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SparseToDenseOptionsBuilder &operator=(const SparseToDenseOptionsBuilder &);
    flatbuffers::Offset<SparseToDenseOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SparseToDenseOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SparseToDenseOptions> CreateSparseToDenseOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                            bool validate_indices = false) {
    SparseToDenseOptionsBuilder builder_(_fbb);
    builder_.add_validate_indices(validate_indices);
    return builder_.Finish();
}

flatbuffers::Offset<SparseToDenseOptions> CreateSparseToDenseOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EqualOptionsT : public flatbuffers::NativeTable {
    typedef EqualOptions TableType;
    EqualOptionsT() {}
};

struct EqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef EqualOptionsT NativeTableType;
    typedef EqualOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return EqualOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    EqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(EqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<EqualOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT *_o,
                                                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EqualOptionsBuilder {
    typedef EqualOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit EqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    EqualOptionsBuilder &operator=(const EqualOptionsBuilder &);
    flatbuffers::Offset<EqualOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<EqualOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<EqualOptions> CreateEqualOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    EqualOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<EqualOptions> CreateEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT *_o,
                                                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NotEqualOptionsT : public flatbuffers::NativeTable {
    typedef NotEqualOptions TableType;
    NotEqualOptionsT() {}
};

struct NotEqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef NotEqualOptionsT NativeTableType;
    typedef NotEqualOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return NotEqualOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    NotEqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(NotEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<NotEqualOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT *_o,
                                                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NotEqualOptionsBuilder {
    typedef NotEqualOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit NotEqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    NotEqualOptionsBuilder &operator=(const NotEqualOptionsBuilder &);
    flatbuffers::Offset<NotEqualOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<NotEqualOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<NotEqualOptions> CreateNotEqualOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    NotEqualOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<NotEqualOptions> CreateNotEqualOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                           const NotEqualOptionsT *_o,
                                                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ShapeOptionsT : public flatbuffers::NativeTable {
    typedef ShapeOptions TableType;
    tflite::TensorType out_type;
    ShapeOptionsT() : out_type(tflite::TensorType_FLOAT32) {}
};

struct ShapeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ShapeOptionsT NativeTableType;
    typedef ShapeOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ShapeOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_OUT_TYPE = 4 };
    tflite::TensorType out_type() const {
        return static_cast<tflite::TensorType>(GetField<int8_t>(VT_OUT_TYPE, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_OUT_TYPE) && verifier.EndTable();
    }
    ShapeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ShapeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<ShapeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT *_o,
                                                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ShapeOptionsBuilder {
    typedef ShapeOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_out_type(tflite::TensorType out_type) {
        fbb_.AddElement<int8_t>(ShapeOptions::VT_OUT_TYPE, static_cast<int8_t>(out_type), 0);
    }
    explicit ShapeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ShapeOptionsBuilder &operator=(const ShapeOptionsBuilder &);
    flatbuffers::Offset<ShapeOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<ShapeOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<ShapeOptions> CreateShapeOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                            tflite::TensorType out_type = tflite::TensorType_FLOAT32) {
    ShapeOptionsBuilder builder_(_fbb);
    builder_.add_out_type(out_type);
    return builder_.Finish();
}

flatbuffers::Offset<ShapeOptions> CreateShapeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT *_o,
                                                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RankOptionsT : public flatbuffers::NativeTable {
    typedef RankOptions TableType;
    RankOptionsT() {}
};

struct RankOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef RankOptionsT NativeTableType;
    typedef RankOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return RankOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    RankOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(RankOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<RankOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RankOptionsBuilder {
    typedef RankOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit RankOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    RankOptionsBuilder &operator=(const RankOptionsBuilder &);
    flatbuffers::Offset<RankOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<RankOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<RankOptions> CreateRankOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    RankOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<RankOptions> CreateRankOptions(flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PowOptionsT : public flatbuffers::NativeTable {
    typedef PowOptions TableType;
    PowOptionsT() {}
};

struct PowOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef PowOptionsT NativeTableType;
    typedef PowOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return PowOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    PowOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(PowOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<PowOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PowOptionsBuilder {
    typedef PowOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit PowOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    PowOptionsBuilder &operator=(const PowOptionsBuilder &);
    flatbuffers::Offset<PowOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<PowOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<PowOptions> CreatePowOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    PowOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<PowOptions> CreatePowOptions(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FakeQuantOptionsT : public flatbuffers::NativeTable {
    typedef FakeQuantOptions TableType;
    float min;
    float max;
    int32_t num_bits;
    bool narrow_range;
    FakeQuantOptionsT() : min(0.0f), max(0.0f), num_bits(0), narrow_range(false) {}
};

struct FakeQuantOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef FakeQuantOptionsT NativeTableType;
    typedef FakeQuantOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return FakeQuantOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_MIN          = 4,
        VT_MAX          = 6,
        VT_NUM_BITS     = 8,
        VT_NARROW_RANGE = 10
    };
    float min() const {
        return GetField<float>(VT_MIN, 0.0f);
    }
    float max() const {
        return GetField<float>(VT_MAX, 0.0f);
    }
    int32_t num_bits() const {
        return GetField<int32_t>(VT_NUM_BITS, 0);
    }
    bool narrow_range() const {
        return GetField<uint8_t>(VT_NARROW_RANGE, 0) != 0;
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<float>(verifier, VT_MIN) &&
               VerifyField<float>(verifier, VT_MAX) && VerifyField<int32_t>(verifier, VT_NUM_BITS) &&
               VerifyField<uint8_t>(verifier, VT_NARROW_RANGE) && verifier.EndTable();
    }
    FakeQuantOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(FakeQuantOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<FakeQuantOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT *_o,
                                                      const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FakeQuantOptionsBuilder {
    typedef FakeQuantOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_min(float min) {
        fbb_.AddElement<float>(FakeQuantOptions::VT_MIN, min, 0.0f);
    }
    void add_max(float max) {
        fbb_.AddElement<float>(FakeQuantOptions::VT_MAX, max, 0.0f);
    }
    void add_num_bits(int32_t num_bits) {
        fbb_.AddElement<int32_t>(FakeQuantOptions::VT_NUM_BITS, num_bits, 0);
    }
    void add_narrow_range(bool narrow_range) {
        fbb_.AddElement<uint8_t>(FakeQuantOptions::VT_NARROW_RANGE, static_cast<uint8_t>(narrow_range), 0);
    }
    explicit FakeQuantOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    FakeQuantOptionsBuilder &operator=(const FakeQuantOptionsBuilder &);
    flatbuffers::Offset<FakeQuantOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<FakeQuantOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    float min = 0.0f, float max = 0.0f,
                                                                    int32_t num_bits = 0, bool narrow_range = false) {
    FakeQuantOptionsBuilder builder_(_fbb);
    builder_.add_num_bits(num_bits);
    builder_.add_max(max);
    builder_.add_min(min);
    builder_.add_narrow_range(narrow_range);
    return builder_.Finish();
}

flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PackOptionsT : public flatbuffers::NativeTable {
    typedef PackOptions TableType;
    int32_t values_count;
    int32_t axis;
    PackOptionsT() : values_count(0), axis(0) {}
};

struct PackOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef PackOptionsT NativeTableType;
    typedef PackOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return PackOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUES_COUNT = 4, VT_AXIS = 6 };
    int32_t values_count() const {
        return GetField<int32_t>(VT_VALUES_COUNT, 0);
    }
    int32_t axis() const {
        return GetField<int32_t>(VT_AXIS, 0);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_VALUES_COUNT) &&
               VerifyField<int32_t>(verifier, VT_AXIS) && verifier.EndTable();
    }
    PackOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(PackOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<PackOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PackOptionsBuilder {
    typedef PackOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_values_count(int32_t values_count) {
        fbb_.AddElement<int32_t>(PackOptions::VT_VALUES_COUNT, values_count, 0);
    }
    void add_axis(int32_t axis) {
        fbb_.AddElement<int32_t>(PackOptions::VT_AXIS, axis, 0);
    }
    explicit PackOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    PackOptionsBuilder &operator=(const PackOptionsBuilder &);
    flatbuffers::Offset<PackOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<PackOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<PackOptions> CreatePackOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                          int32_t values_count = 0, int32_t axis = 0) {
    PackOptionsBuilder builder_(_fbb);
    builder_.add_axis(axis);
    builder_.add_values_count(values_count);
    return builder_.Finish();
}

flatbuffers::Offset<PackOptions> CreatePackOptions(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalOrOptionsT : public flatbuffers::NativeTable {
    typedef LogicalOrOptions TableType;
    LogicalOrOptionsT() {}
};

struct LogicalOrOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef LogicalOrOptionsT NativeTableType;
    typedef LogicalOrOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return LogicalOrOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    LogicalOrOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(LogicalOrOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<LogicalOrOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT *_o,
                                                      const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalOrOptionsBuilder {
    typedef LogicalOrOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit LogicalOrOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    LogicalOrOptionsBuilder &operator=(const LogicalOrOptionsBuilder &);
    flatbuffers::Offset<LogicalOrOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<LogicalOrOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<LogicalOrOptions> CreateLogicalOrOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    LogicalOrOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<LogicalOrOptions> CreateLogicalOrOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OneHotOptionsT : public flatbuffers::NativeTable {
    typedef OneHotOptions TableType;
    int32_t axis;
    OneHotOptionsT() : axis(0) {}
};

struct OneHotOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef OneHotOptionsT NativeTableType;
    typedef OneHotOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return OneHotOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_AXIS = 4 };
    int32_t axis() const {
        return GetField<int32_t>(VT_AXIS, 0);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_AXIS) && verifier.EndTable();
    }
    OneHotOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(OneHotOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<OneHotOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OneHotOptionsBuilder {
    typedef OneHotOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_axis(int32_t axis) {
        fbb_.AddElement<int32_t>(OneHotOptions::VT_AXIS, axis, 0);
    }
    explicit OneHotOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    OneHotOptionsBuilder &operator=(const OneHotOptionsBuilder &);
    flatbuffers::Offset<OneHotOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<OneHotOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(flatbuffers::FlatBufferBuilder &_fbb, int32_t axis = 0) {
    OneHotOptionsBuilder builder_(_fbb);
    builder_.add_axis(axis);
    return builder_.Finish();
}

flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AbsOptionsT : public flatbuffers::NativeTable {
    typedef AbsOptions TableType;
    AbsOptionsT() {}
};

struct AbsOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef AbsOptionsT NativeTableType;
    typedef AbsOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return AbsOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    AbsOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(AbsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<AbsOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AbsOptionsBuilder {
    typedef AbsOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit AbsOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    AbsOptionsBuilder &operator=(const AbsOptionsBuilder &);
    flatbuffers::Offset<AbsOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<AbsOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<AbsOptions> CreateAbsOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    AbsOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<AbsOptions> CreateAbsOptions(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HardSwishOptionsT : public flatbuffers::NativeTable {
    typedef HardSwishOptions TableType;
    HardSwishOptionsT() {}
};

struct HardSwishOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef HardSwishOptionsT NativeTableType;
    typedef HardSwishOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return HardSwishOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    HardSwishOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(HardSwishOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<HardSwishOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionsT *_o,
                                                      const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HardSwishOptionsBuilder {
    typedef HardSwishOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit HardSwishOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    HardSwishOptionsBuilder &operator=(const HardSwishOptionsBuilder &);
    flatbuffers::Offset<HardSwishOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<HardSwishOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<HardSwishOptions> CreateHardSwishOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    HardSwishOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<HardSwishOptions> CreateHardSwishOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalAndOptionsT : public flatbuffers::NativeTable {
    typedef LogicalAndOptions TableType;
    LogicalAndOptionsT() {}
};

struct LogicalAndOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef LogicalAndOptionsT NativeTableType;
    typedef LogicalAndOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return LogicalAndOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    LogicalAndOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(LogicalAndOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<LogicalAndOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                       const LogicalAndOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalAndOptionsBuilder {
    typedef LogicalAndOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit LogicalAndOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    LogicalAndOptionsBuilder &operator=(const LogicalAndOptionsBuilder &);
    flatbuffers::Offset<LogicalAndOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<LogicalAndOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<LogicalAndOptions> CreateLogicalAndOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    LogicalAndOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<LogicalAndOptions> CreateLogicalAndOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalNotOptionsT : public flatbuffers::NativeTable {
    typedef LogicalNotOptions TableType;
    LogicalNotOptionsT() {}
};

struct LogicalNotOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef LogicalNotOptionsT NativeTableType;
    typedef LogicalNotOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return LogicalNotOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    LogicalNotOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(LogicalNotOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<LogicalNotOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                       const LogicalNotOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalNotOptionsBuilder {
    typedef LogicalNotOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit LogicalNotOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    LogicalNotOptionsBuilder &operator=(const LogicalNotOptionsBuilder &);
    flatbuffers::Offset<LogicalNotOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<LogicalNotOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<LogicalNotOptions> CreateLogicalNotOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    LogicalNotOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<LogicalNotOptions> CreateLogicalNotOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnpackOptionsT : public flatbuffers::NativeTable {
    typedef UnpackOptions TableType;
    int32_t num;
    int32_t axis;
    UnpackOptionsT() : num(0), axis(0) {}
};

struct UnpackOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef UnpackOptionsT NativeTableType;
    typedef UnpackOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return UnpackOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_NUM = 4, VT_AXIS = 6 };
    int32_t num() const {
        return GetField<int32_t>(VT_NUM, 0);
    }
    int32_t axis() const {
        return GetField<int32_t>(VT_AXIS, 0);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_NUM) &&
               VerifyField<int32_t>(verifier, VT_AXIS) && verifier.EndTable();
    }
    UnpackOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(UnpackOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<UnpackOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnpackOptionsBuilder {
    typedef UnpackOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_num(int32_t num) {
        fbb_.AddElement<int32_t>(UnpackOptions::VT_NUM, num, 0);
    }
    void add_axis(int32_t axis) {
        fbb_.AddElement<int32_t>(UnpackOptions::VT_AXIS, axis, 0);
    }
    explicit UnpackOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    UnpackOptionsBuilder &operator=(const UnpackOptionsBuilder &);
    flatbuffers::Offset<UnpackOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<UnpackOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(flatbuffers::FlatBufferBuilder &_fbb, int32_t num = 0,
                                                              int32_t axis = 0) {
    UnpackOptionsBuilder builder_(_fbb);
    builder_.add_axis(axis);
    builder_.add_num(num);
    return builder_.Finish();
}

flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FloorDivOptionsT : public flatbuffers::NativeTable {
    typedef FloorDivOptions TableType;
    FloorDivOptionsT() {}
};

struct FloorDivOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef FloorDivOptionsT NativeTableType;
    typedef FloorDivOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return FloorDivOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    FloorDivOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(FloorDivOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<FloorDivOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT *_o,
                                                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FloorDivOptionsBuilder {
    typedef FloorDivOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit FloorDivOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    FloorDivOptionsBuilder &operator=(const FloorDivOptionsBuilder &);
    flatbuffers::Offset<FloorDivOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<FloorDivOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<FloorDivOptions> CreateFloorDivOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    FloorDivOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<FloorDivOptions> CreateFloorDivOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                           const FloorDivOptionsT *_o,
                                                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SquareOptionsT : public flatbuffers::NativeTable {
    typedef SquareOptions TableType;
    SquareOptionsT() {}
};

struct SquareOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SquareOptionsT NativeTableType;
    typedef SquareOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SquareOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    SquareOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SquareOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SquareOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SquareOptionsBuilder {
    typedef SquareOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit SquareOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SquareOptionsBuilder &operator=(const SquareOptionsBuilder &);
    flatbuffers::Offset<SquareOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SquareOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SquareOptions> CreateSquareOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    SquareOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<SquareOptions> CreateSquareOptions(flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ZerosLikeOptionsT : public flatbuffers::NativeTable {
    typedef ZerosLikeOptions TableType;
    ZerosLikeOptionsT() {}
};

struct ZerosLikeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ZerosLikeOptionsT NativeTableType;
    typedef ZerosLikeOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ZerosLikeOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    ZerosLikeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ZerosLikeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<ZerosLikeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT *_o,
                                                      const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ZerosLikeOptionsBuilder {
    typedef ZerosLikeOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit ZerosLikeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ZerosLikeOptionsBuilder &operator=(const ZerosLikeOptionsBuilder &);
    flatbuffers::Offset<ZerosLikeOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<ZerosLikeOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<ZerosLikeOptions> CreateZerosLikeOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    ZerosLikeOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<ZerosLikeOptions> CreateZerosLikeOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FillOptionsT : public flatbuffers::NativeTable {
    typedef FillOptions TableType;
    FillOptionsT() {}
};

struct FillOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef FillOptionsT NativeTableType;
    typedef FillOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return FillOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    FillOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(FillOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<FillOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FillOptionsBuilder {
    typedef FillOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit FillOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    FillOptionsBuilder &operator=(const FillOptionsBuilder &);
    flatbuffers::Offset<FillOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<FillOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<FillOptions> CreateFillOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    FillOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<FillOptions> CreateFillOptions(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FloorModOptionsT : public flatbuffers::NativeTable {
    typedef FloorModOptions TableType;
    FloorModOptionsT() {}
};

struct FloorModOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef FloorModOptionsT NativeTableType;
    typedef FloorModOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return FloorModOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    FloorModOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(FloorModOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<FloorModOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT *_o,
                                                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FloorModOptionsBuilder {
    typedef FloorModOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit FloorModOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    FloorModOptionsBuilder &operator=(const FloorModOptionsBuilder &);
    flatbuffers::Offset<FloorModOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<FloorModOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<FloorModOptions> CreateFloorModOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    FloorModOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<FloorModOptions> CreateFloorModOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                           const FloorModOptionsT *_o,
                                                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RangeOptionsT : public flatbuffers::NativeTable {
    typedef RangeOptions TableType;
    RangeOptionsT() {}
};

struct RangeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef RangeOptionsT NativeTableType;
    typedef RangeOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return RangeOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    RangeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(RangeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<RangeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT *_o,
                                                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RangeOptionsBuilder {
    typedef RangeOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit RangeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    RangeOptionsBuilder &operator=(const RangeOptionsBuilder &);
    flatbuffers::Offset<RangeOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<RangeOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<RangeOptions> CreateRangeOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    RangeOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<RangeOptions> CreateRangeOptions(flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT *_o,
                                                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LeakyReluOptionsT : public flatbuffers::NativeTable {
    typedef LeakyReluOptions TableType;
    float alpha;
    LeakyReluOptionsT() : alpha(0.0f) {}
};

struct LeakyReluOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef LeakyReluOptionsT NativeTableType;
    typedef LeakyReluOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return LeakyReluOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_ALPHA = 4 };
    float alpha() const {
        return GetField<float>(VT_ALPHA, 0.0f);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<float>(verifier, VT_ALPHA) && verifier.EndTable();
    }
    LeakyReluOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(LeakyReluOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<LeakyReluOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT *_o,
                                                      const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LeakyReluOptionsBuilder {
    typedef LeakyReluOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_alpha(float alpha) {
        fbb_.AddElement<float>(LeakyReluOptions::VT_ALPHA, alpha, 0.0f);
    }
    explicit LeakyReluOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    LeakyReluOptionsBuilder &operator=(const LeakyReluOptionsBuilder &);
    flatbuffers::Offset<LeakyReluOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<LeakyReluOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<LeakyReluOptions> CreateLeakyReluOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    float alpha = 0.0f) {
    LeakyReluOptionsBuilder builder_(_fbb);
    builder_.add_alpha(alpha);
    return builder_.Finish();
}

flatbuffers::Offset<LeakyReluOptions> CreateLeakyReluOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SquaredDifferenceOptionsT : public flatbuffers::NativeTable {
    typedef SquaredDifferenceOptions TableType;
    SquaredDifferenceOptionsT() {}
};

struct SquaredDifferenceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SquaredDifferenceOptionsT NativeTableType;
    typedef SquaredDifferenceOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SquaredDifferenceOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    SquaredDifferenceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SquaredDifferenceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SquaredDifferenceOptions> Pack(
        flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT *_o,
        const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SquaredDifferenceOptionsBuilder {
    typedef SquaredDifferenceOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit SquaredDifferenceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SquaredDifferenceOptionsBuilder &operator=(const SquaredDifferenceOptionsBuilder &);
    flatbuffers::Offset<SquaredDifferenceOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SquaredDifferenceOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SquaredDifferenceOptions> CreateSquaredDifferenceOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
    SquaredDifferenceOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<SquaredDifferenceOptions> CreateSquaredDifferenceOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MirrorPadOptionsT : public flatbuffers::NativeTable {
    typedef MirrorPadOptions TableType;
    tflite::MirrorPadMode mode;
    MirrorPadOptionsT() : mode(tflite::MirrorPadMode_REFLECT) {}
};

struct MirrorPadOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef MirrorPadOptionsT NativeTableType;
    typedef MirrorPadOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return MirrorPadOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_MODE = 4 };
    tflite::MirrorPadMode mode() const {
        return static_cast<tflite::MirrorPadMode>(GetField<int8_t>(VT_MODE, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_MODE) && verifier.EndTable();
    }
    MirrorPadOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(MirrorPadOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<MirrorPadOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT *_o,
                                                      const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MirrorPadOptionsBuilder {
    typedef MirrorPadOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_mode(tflite::MirrorPadMode mode) {
        fbb_.AddElement<int8_t>(MirrorPadOptions::VT_MODE, static_cast<int8_t>(mode), 0);
    }
    explicit MirrorPadOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    MirrorPadOptionsBuilder &operator=(const MirrorPadOptionsBuilder &);
    flatbuffers::Offset<MirrorPadOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<MirrorPadOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<MirrorPadOptions> CreateMirrorPadOptions(
    flatbuffers::FlatBufferBuilder &_fbb, tflite::MirrorPadMode mode = tflite::MirrorPadMode_REFLECT) {
    MirrorPadOptionsBuilder builder_(_fbb);
    builder_.add_mode(mode);
    return builder_.Finish();
}

flatbuffers::Offset<MirrorPadOptions> CreateMirrorPadOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UniqueOptionsT : public flatbuffers::NativeTable {
    typedef UniqueOptions TableType;
    tflite::TensorType idx_out_type;
    UniqueOptionsT() : idx_out_type(tflite::TensorType_INT32) {}
};

struct UniqueOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef UniqueOptionsT NativeTableType;
    typedef UniqueOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return UniqueOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_IDX_OUT_TYPE = 4 };
    tflite::TensorType idx_out_type() const {
        return static_cast<tflite::TensorType>(GetField<int8_t>(VT_IDX_OUT_TYPE, 2));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_IDX_OUT_TYPE) && verifier.EndTable();
    }
    UniqueOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(UniqueOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<UniqueOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UniqueOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UniqueOptionsBuilder {
    typedef UniqueOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_idx_out_type(tflite::TensorType idx_out_type) {
        fbb_.AddElement<int8_t>(UniqueOptions::VT_IDX_OUT_TYPE, static_cast<int8_t>(idx_out_type), 2);
    }
    explicit UniqueOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    UniqueOptionsBuilder &operator=(const UniqueOptionsBuilder &);
    flatbuffers::Offset<UniqueOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<UniqueOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<UniqueOptions> CreateUniqueOptions(
    flatbuffers::FlatBufferBuilder &_fbb, tflite::TensorType idx_out_type = tflite::TensorType_INT32) {
    UniqueOptionsBuilder builder_(_fbb);
    builder_.add_idx_out_type(idx_out_type);
    return builder_.Finish();
}

flatbuffers::Offset<UniqueOptions> CreateUniqueOptions(flatbuffers::FlatBufferBuilder &_fbb, const UniqueOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReverseV2OptionsT : public flatbuffers::NativeTable {
    typedef ReverseV2Options TableType;
    ReverseV2OptionsT() {}
};

struct ReverseV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ReverseV2OptionsT NativeTableType;
    typedef ReverseV2OptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ReverseV2OptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    ReverseV2OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ReverseV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<ReverseV2Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2OptionsT *_o,
                                                      const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReverseV2OptionsBuilder {
    typedef ReverseV2Options Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit ReverseV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ReverseV2OptionsBuilder &operator=(const ReverseV2OptionsBuilder &);
    flatbuffers::Offset<ReverseV2Options> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<ReverseV2Options>(end);
        return o;
    }
};

inline flatbuffers::Offset<ReverseV2Options> CreateReverseV2Options(flatbuffers::FlatBufferBuilder &_fbb) {
    ReverseV2OptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<ReverseV2Options> CreateReverseV2Options(
    flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2OptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddNOptionsT : public flatbuffers::NativeTable {
    typedef AddNOptions TableType;
    AddNOptionsT() {}
};

struct AddNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef AddNOptionsT NativeTableType;
    typedef AddNOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return AddNOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    AddNOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(AddNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<AddNOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddNOptionsBuilder {
    typedef AddNOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit AddNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    AddNOptionsBuilder &operator=(const AddNOptionsBuilder &);
    flatbuffers::Offset<AddNOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<AddNOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<AddNOptions> CreateAddNOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    AddNOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<AddNOptions> CreateAddNOptions(flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GatherNdOptionsT : public flatbuffers::NativeTable {
    typedef GatherNdOptions TableType;
    GatherNdOptionsT() {}
};

struct GatherNdOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef GatherNdOptionsT NativeTableType;
    typedef GatherNdOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return GatherNdOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    GatherNdOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(GatherNdOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<GatherNdOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdOptionsT *_o,
                                                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GatherNdOptionsBuilder {
    typedef GatherNdOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit GatherNdOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    GatherNdOptionsBuilder &operator=(const GatherNdOptionsBuilder &);
    flatbuffers::Offset<GatherNdOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<GatherNdOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<GatherNdOptions> CreateGatherNdOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    GatherNdOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<GatherNdOptions> CreateGatherNdOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                           const GatherNdOptionsT *_o,
                                                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WhereOptionsT : public flatbuffers::NativeTable {
    typedef WhereOptions TableType;
    WhereOptionsT() {}
};

struct WhereOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef WhereOptionsT NativeTableType;
    typedef WhereOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return WhereOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    WhereOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(WhereOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<WhereOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhereOptionsT *_o,
                                                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WhereOptionsBuilder {
    typedef WhereOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit WhereOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    WhereOptionsBuilder &operator=(const WhereOptionsBuilder &);
    flatbuffers::Offset<WhereOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<WhereOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<WhereOptions> CreateWhereOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    WhereOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<WhereOptions> CreateWhereOptions(flatbuffers::FlatBufferBuilder &_fbb, const WhereOptionsT *_o,
                                                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReverseSequenceOptionsT : public flatbuffers::NativeTable {
    typedef ReverseSequenceOptions TableType;
    int32_t seq_dim;
    int32_t batch_dim;
    ReverseSequenceOptionsT() : seq_dim(0), batch_dim(0) {}
};

struct ReverseSequenceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ReverseSequenceOptionsT NativeTableType;
    typedef ReverseSequenceOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ReverseSequenceOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_SEQ_DIM = 4, VT_BATCH_DIM = 6 };
    int32_t seq_dim() const {
        return GetField<int32_t>(VT_SEQ_DIM, 0);
    }
    int32_t batch_dim() const {
        return GetField<int32_t>(VT_BATCH_DIM, 0);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_SEQ_DIM) &&
               VerifyField<int32_t>(verifier, VT_BATCH_DIM) && verifier.EndTable();
    }
    ReverseSequenceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ReverseSequenceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<ReverseSequenceOptions> Pack(
        flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceOptionsT *_o,
        const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReverseSequenceOptionsBuilder {
    typedef ReverseSequenceOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_seq_dim(int32_t seq_dim) {
        fbb_.AddElement<int32_t>(ReverseSequenceOptions::VT_SEQ_DIM, seq_dim, 0);
    }
    void add_batch_dim(int32_t batch_dim) {
        fbb_.AddElement<int32_t>(ReverseSequenceOptions::VT_BATCH_DIM, batch_dim, 0);
    }
    explicit ReverseSequenceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ReverseSequenceOptionsBuilder &operator=(const ReverseSequenceOptionsBuilder &);
    flatbuffers::Offset<ReverseSequenceOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<ReverseSequenceOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<ReverseSequenceOptions> CreateReverseSequenceOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                                int32_t seq_dim   = 0,
                                                                                int32_t batch_dim = 0) {
    ReverseSequenceOptionsBuilder builder_(_fbb);
    builder_.add_batch_dim(batch_dim);
    builder_.add_seq_dim(seq_dim);
    return builder_.Finish();
}

flatbuffers::Offset<ReverseSequenceOptions> CreateReverseSequenceOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MatrixDiagOptionsT : public flatbuffers::NativeTable {
    typedef MatrixDiagOptions TableType;
    MatrixDiagOptionsT() {}
};

struct MatrixDiagOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef MatrixDiagOptionsT NativeTableType;
    typedef MatrixDiagOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return MatrixDiagOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    MatrixDiagOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(MatrixDiagOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<MatrixDiagOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                       const MatrixDiagOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MatrixDiagOptionsBuilder {
    typedef MatrixDiagOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit MatrixDiagOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    MatrixDiagOptionsBuilder &operator=(const MatrixDiagOptionsBuilder &);
    flatbuffers::Offset<MatrixDiagOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<MatrixDiagOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<MatrixDiagOptions> CreateMatrixDiagOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    MatrixDiagOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<MatrixDiagOptions> CreateMatrixDiagOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QuantizeOptionsT : public flatbuffers::NativeTable {
    typedef QuantizeOptions TableType;
    QuantizeOptionsT() {}
};

struct QuantizeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef QuantizeOptionsT NativeTableType;
    typedef QuantizeOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return QuantizeOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    QuantizeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(QuantizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<QuantizeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeOptionsT *_o,
                                                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QuantizeOptionsBuilder {
    typedef QuantizeOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit QuantizeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    QuantizeOptionsBuilder &operator=(const QuantizeOptionsBuilder &);
    flatbuffers::Offset<QuantizeOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<QuantizeOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<QuantizeOptions> CreateQuantizeOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    QuantizeOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<QuantizeOptions> CreateQuantizeOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                           const QuantizeOptionsT *_o,
                                                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MatrixSetDiagOptionsT : public flatbuffers::NativeTable {
    typedef MatrixSetDiagOptions TableType;
    MatrixSetDiagOptionsT() {}
};

struct MatrixSetDiagOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef MatrixSetDiagOptionsT NativeTableType;
    typedef MatrixSetDiagOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return MatrixSetDiagOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    MatrixSetDiagOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(MatrixSetDiagOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<MatrixSetDiagOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                          const MatrixSetDiagOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MatrixSetDiagOptionsBuilder {
    typedef MatrixSetDiagOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit MatrixSetDiagOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    MatrixSetDiagOptionsBuilder &operator=(const MatrixSetDiagOptionsBuilder &);
    flatbuffers::Offset<MatrixSetDiagOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<MatrixSetDiagOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<MatrixSetDiagOptions> CreateMatrixSetDiagOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    MatrixSetDiagOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<MatrixSetDiagOptions> CreateMatrixSetDiagOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const MatrixSetDiagOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IfOptionsT : public flatbuffers::NativeTable {
    typedef IfOptions TableType;
    int32_t then_subgraph_index;
    int32_t else_subgraph_index;
    IfOptionsT() : then_subgraph_index(0), else_subgraph_index(0) {}
};

struct IfOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef IfOptionsT NativeTableType;
    typedef IfOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return IfOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_THEN_SUBGRAPH_INDEX = 4,
        VT_ELSE_SUBGRAPH_INDEX = 6
    };
    int32_t then_subgraph_index() const {
        return GetField<int32_t>(VT_THEN_SUBGRAPH_INDEX, 0);
    }
    int32_t else_subgraph_index() const {
        return GetField<int32_t>(VT_ELSE_SUBGRAPH_INDEX, 0);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_THEN_SUBGRAPH_INDEX) &&
               VerifyField<int32_t>(verifier, VT_ELSE_SUBGRAPH_INDEX) && verifier.EndTable();
    }
    IfOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(IfOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<IfOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT *_o,
                                               const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IfOptionsBuilder {
    typedef IfOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_then_subgraph_index(int32_t then_subgraph_index) {
        fbb_.AddElement<int32_t>(IfOptions::VT_THEN_SUBGRAPH_INDEX, then_subgraph_index, 0);
    }
    void add_else_subgraph_index(int32_t else_subgraph_index) {
        fbb_.AddElement<int32_t>(IfOptions::VT_ELSE_SUBGRAPH_INDEX, else_subgraph_index, 0);
    }
    explicit IfOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    IfOptionsBuilder &operator=(const IfOptionsBuilder &);
    flatbuffers::Offset<IfOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<IfOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<IfOptions> CreateIfOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                      int32_t then_subgraph_index = 0,
                                                      int32_t else_subgraph_index = 0) {
    IfOptionsBuilder builder_(_fbb);
    builder_.add_else_subgraph_index(else_subgraph_index);
    builder_.add_then_subgraph_index(then_subgraph_index);
    return builder_.Finish();
}

flatbuffers::Offset<IfOptions> CreateIfOptions(flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT *_o,
                                               const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WhileOptionsT : public flatbuffers::NativeTable {
    typedef WhileOptions TableType;
    int32_t cond_subgraph_index;
    int32_t body_subgraph_index;
    WhileOptionsT() : cond_subgraph_index(0), body_subgraph_index(0) {}
};

struct WhileOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef WhileOptionsT NativeTableType;
    typedef WhileOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return WhileOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_COND_SUBGRAPH_INDEX = 4,
        VT_BODY_SUBGRAPH_INDEX = 6
    };
    int32_t cond_subgraph_index() const {
        return GetField<int32_t>(VT_COND_SUBGRAPH_INDEX, 0);
    }
    int32_t body_subgraph_index() const {
        return GetField<int32_t>(VT_BODY_SUBGRAPH_INDEX, 0);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_COND_SUBGRAPH_INDEX) &&
               VerifyField<int32_t>(verifier, VT_BODY_SUBGRAPH_INDEX) && verifier.EndTable();
    }
    WhileOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(WhileOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<WhileOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhileOptionsT *_o,
                                                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WhileOptionsBuilder {
    typedef WhileOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_cond_subgraph_index(int32_t cond_subgraph_index) {
        fbb_.AddElement<int32_t>(WhileOptions::VT_COND_SUBGRAPH_INDEX, cond_subgraph_index, 0);
    }
    void add_body_subgraph_index(int32_t body_subgraph_index) {
        fbb_.AddElement<int32_t>(WhileOptions::VT_BODY_SUBGRAPH_INDEX, body_subgraph_index, 0);
    }
    explicit WhileOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    WhileOptionsBuilder &operator=(const WhileOptionsBuilder &);
    flatbuffers::Offset<WhileOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<WhileOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<WhileOptions> CreateWhileOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                            int32_t cond_subgraph_index = 0,
                                                            int32_t body_subgraph_index = 0) {
    WhileOptionsBuilder builder_(_fbb);
    builder_.add_body_subgraph_index(body_subgraph_index);
    builder_.add_cond_subgraph_index(cond_subgraph_index);
    return builder_.Finish();
}

flatbuffers::Offset<WhileOptions> CreateWhileOptions(flatbuffers::FlatBufferBuilder &_fbb, const WhileOptionsT *_o,
                                                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NonMaxSuppressionV4OptionsT : public flatbuffers::NativeTable {
    typedef NonMaxSuppressionV4Options TableType;
    NonMaxSuppressionV4OptionsT() {}
};

struct NonMaxSuppressionV4Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef NonMaxSuppressionV4OptionsT NativeTableType;
    typedef NonMaxSuppressionV4OptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return NonMaxSuppressionV4OptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    NonMaxSuppressionV4OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(NonMaxSuppressionV4OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<NonMaxSuppressionV4Options> Pack(
        flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV4OptionsT *_o,
        const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NonMaxSuppressionV4OptionsBuilder {
    typedef NonMaxSuppressionV4Options Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit NonMaxSuppressionV4OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    NonMaxSuppressionV4OptionsBuilder &operator=(const NonMaxSuppressionV4OptionsBuilder &);
    flatbuffers::Offset<NonMaxSuppressionV4Options> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<NonMaxSuppressionV4Options>(end);
        return o;
    }
};

inline flatbuffers::Offset<NonMaxSuppressionV4Options> CreateNonMaxSuppressionV4Options(
    flatbuffers::FlatBufferBuilder &_fbb) {
    NonMaxSuppressionV4OptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<NonMaxSuppressionV4Options> CreateNonMaxSuppressionV4Options(
    flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV4OptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NonMaxSuppressionV5OptionsT : public flatbuffers::NativeTable {
    typedef NonMaxSuppressionV5Options TableType;
    NonMaxSuppressionV5OptionsT() {}
};

struct NonMaxSuppressionV5Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef NonMaxSuppressionV5OptionsT NativeTableType;
    typedef NonMaxSuppressionV5OptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return NonMaxSuppressionV5OptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    NonMaxSuppressionV5OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(NonMaxSuppressionV5OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<NonMaxSuppressionV5Options> Pack(
        flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV5OptionsT *_o,
        const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NonMaxSuppressionV5OptionsBuilder {
    typedef NonMaxSuppressionV5Options Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit NonMaxSuppressionV5OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    NonMaxSuppressionV5OptionsBuilder &operator=(const NonMaxSuppressionV5OptionsBuilder &);
    flatbuffers::Offset<NonMaxSuppressionV5Options> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<NonMaxSuppressionV5Options>(end);
        return o;
    }
};

inline flatbuffers::Offset<NonMaxSuppressionV5Options> CreateNonMaxSuppressionV5Options(
    flatbuffers::FlatBufferBuilder &_fbb) {
    NonMaxSuppressionV5OptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<NonMaxSuppressionV5Options> CreateNonMaxSuppressionV5Options(
    flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV5OptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ScatterNdOptionsT : public flatbuffers::NativeTable {
    typedef ScatterNdOptions TableType;
    ScatterNdOptionsT() {}
};

struct ScatterNdOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ScatterNdOptionsT NativeTableType;
    typedef ScatterNdOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ScatterNdOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    ScatterNdOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ScatterNdOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<ScatterNdOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdOptionsT *_o,
                                                      const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ScatterNdOptionsBuilder {
    typedef ScatterNdOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit ScatterNdOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ScatterNdOptionsBuilder &operator=(const ScatterNdOptionsBuilder &);
    flatbuffers::Offset<ScatterNdOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<ScatterNdOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<ScatterNdOptions> CreateScatterNdOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    ScatterNdOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<ScatterNdOptions> CreateScatterNdOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SelectV2OptionsT : public flatbuffers::NativeTable {
    typedef SelectV2Options TableType;
    SelectV2OptionsT() {}
};

struct SelectV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SelectV2OptionsT NativeTableType;
    typedef SelectV2OptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SelectV2OptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    SelectV2OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SelectV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SelectV2Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectV2OptionsT *_o,
                                                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SelectV2OptionsBuilder {
    typedef SelectV2Options Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit SelectV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SelectV2OptionsBuilder &operator=(const SelectV2OptionsBuilder &);
    flatbuffers::Offset<SelectV2Options> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SelectV2Options>(end);
        return o;
    }
};

inline flatbuffers::Offset<SelectV2Options> CreateSelectV2Options(flatbuffers::FlatBufferBuilder &_fbb) {
    SelectV2OptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<SelectV2Options> CreateSelectV2Options(flatbuffers::FlatBufferBuilder &_fbb,
                                                           const SelectV2OptionsT *_o,
                                                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DensifyOptionsT : public flatbuffers::NativeTable {
    typedef DensifyOptions TableType;
    DensifyOptionsT() {}
};

struct DensifyOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef DensifyOptionsT NativeTableType;
    typedef DensifyOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return DensifyOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    DensifyOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(DensifyOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<DensifyOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DensifyOptionsT *_o,
                                                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DensifyOptionsBuilder {
    typedef DensifyOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit DensifyOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    DensifyOptionsBuilder &operator=(const DensifyOptionsBuilder &);
    flatbuffers::Offset<DensifyOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<DensifyOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<DensifyOptions> CreateDensifyOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    DensifyOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<DensifyOptions> CreateDensifyOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                         const DensifyOptionsT *_o,
                                                         const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SegmentSumOptionsT : public flatbuffers::NativeTable {
    typedef SegmentSumOptions TableType;
    SegmentSumOptionsT() {}
};

struct SegmentSumOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SegmentSumOptionsT NativeTableType;
    typedef SegmentSumOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SegmentSumOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    SegmentSumOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SegmentSumOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SegmentSumOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                       const SegmentSumOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SegmentSumOptionsBuilder {
    typedef SegmentSumOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit SegmentSumOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SegmentSumOptionsBuilder &operator=(const SegmentSumOptionsBuilder &);
    flatbuffers::Offset<SegmentSumOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SegmentSumOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SegmentSumOptions> CreateSegmentSumOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    SegmentSumOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<SegmentSumOptions> CreateSegmentSumOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const SegmentSumOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchMatMulOptionsT : public flatbuffers::NativeTable {
    typedef BatchMatMulOptions TableType;
    bool adj_x;
    bool adj_y;
    BatchMatMulOptionsT() : adj_x(false), adj_y(false) {}
};

struct BatchMatMulOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef BatchMatMulOptionsT NativeTableType;
    typedef BatchMatMulOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return BatchMatMulOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_ADJ_X = 4, VT_ADJ_Y = 6 };
    bool adj_x() const {
        return GetField<uint8_t>(VT_ADJ_X, 0) != 0;
    }
    bool adj_y() const {
        return GetField<uint8_t>(VT_ADJ_Y, 0) != 0;
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_ADJ_X) &&
               VerifyField<uint8_t>(verifier, VT_ADJ_Y) && verifier.EndTable();
    }
    BatchMatMulOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(BatchMatMulOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<BatchMatMulOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                        const BatchMatMulOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchMatMulOptionsBuilder {
    typedef BatchMatMulOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_adj_x(bool adj_x) {
        fbb_.AddElement<uint8_t>(BatchMatMulOptions::VT_ADJ_X, static_cast<uint8_t>(adj_x), 0);
    }
    void add_adj_y(bool adj_y) {
        fbb_.AddElement<uint8_t>(BatchMatMulOptions::VT_ADJ_Y, static_cast<uint8_t>(adj_y), 0);
    }
    explicit BatchMatMulOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    BatchMatMulOptionsBuilder &operator=(const BatchMatMulOptionsBuilder &);
    flatbuffers::Offset<BatchMatMulOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<BatchMatMulOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<BatchMatMulOptions> CreateBatchMatMulOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                        bool adj_x = false, bool adj_y = false) {
    BatchMatMulOptionsBuilder builder_(_fbb);
    builder_.add_adj_y(adj_y);
    builder_.add_adj_x(adj_x);
    return builder_.Finish();
}

flatbuffers::Offset<BatchMatMulOptions> CreateBatchMatMulOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OperatorCodeT : public flatbuffers::NativeTable {
    typedef OperatorCode TableType;
    tflite::BuiltinOperator builtin_code;
    std::string custom_code;
    int32_t version;
    OperatorCodeT() : builtin_code(tflite::BuiltinOperator_ADD), version(1) {}
};

struct OperatorCode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef OperatorCodeT NativeTableType;
    typedef OperatorCodeBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return OperatorCodeTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_BUILTIN_CODE = 4,
        VT_CUSTOM_CODE  = 6,
        VT_VERSION      = 8
    };
    tflite::BuiltinOperator builtin_code() const {
        return static_cast<tflite::BuiltinOperator>(GetField<int8_t>(VT_BUILTIN_CODE, 0));
    }
    const flatbuffers::String *custom_code() const {
        return GetPointer<const flatbuffers::String *>(VT_CUSTOM_CODE);
    }
    int32_t version() const {
        return GetField<int32_t>(VT_VERSION, 1);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_BUILTIN_CODE) &&
               VerifyOffset(verifier, VT_CUSTOM_CODE) && verifier.VerifyString(custom_code()) &&
               VerifyField<int32_t>(verifier, VT_VERSION) && verifier.EndTable();
    }
    OperatorCodeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(OperatorCodeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<OperatorCode> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT *_o,
                                                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OperatorCodeBuilder {
    typedef OperatorCode Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_builtin_code(tflite::BuiltinOperator builtin_code) {
        fbb_.AddElement<int8_t>(OperatorCode::VT_BUILTIN_CODE, static_cast<int8_t>(builtin_code), 0);
    }
    void add_custom_code(flatbuffers::Offset<flatbuffers::String> custom_code) {
        fbb_.AddOffset(OperatorCode::VT_CUSTOM_CODE, custom_code);
    }
    void add_version(int32_t version) {
        fbb_.AddElement<int32_t>(OperatorCode::VT_VERSION, version, 1);
    }
    explicit OperatorCodeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    OperatorCodeBuilder &operator=(const OperatorCodeBuilder &);
    flatbuffers::Offset<OperatorCode> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<OperatorCode>(end);
        return o;
    }
};

inline flatbuffers::Offset<OperatorCode> CreateOperatorCode(
    flatbuffers::FlatBufferBuilder &_fbb, tflite::BuiltinOperator builtin_code = tflite::BuiltinOperator_ADD,
    flatbuffers::Offset<flatbuffers::String> custom_code = 0, int32_t version = 1) {
    OperatorCodeBuilder builder_(_fbb);
    builder_.add_version(version);
    builder_.add_custom_code(custom_code);
    builder_.add_builtin_code(builtin_code);
    return builder_.Finish();
}

inline flatbuffers::Offset<OperatorCode> CreateOperatorCodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb, tflite::BuiltinOperator builtin_code = tflite::BuiltinOperator_ADD,
    const char *custom_code = nullptr, int32_t version = 1) {
    auto custom_code__ = custom_code ? _fbb.CreateString(custom_code) : 0;
    return tflite::CreateOperatorCode(_fbb, builtin_code, custom_code__, version);
}

flatbuffers::Offset<OperatorCode> CreateOperatorCode(flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT *_o,
                                                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OperatorT : public flatbuffers::NativeTable {
    typedef Operator TableType;
    uint32_t opcode_index;
    std::vector<int32_t> inputs;
    std::vector<int32_t> outputs;
    tflite::BuiltinOptionsUnion builtin_options;
    std::vector<uint8_t> custom_options;
    tflite::CustomOptionsFormat custom_options_format;
    std::vector<bool> mutating_variable_inputs;
    std::vector<int32_t> intermediates;
    OperatorT() : opcode_index(0), custom_options_format(tflite::CustomOptionsFormat_FLEXBUFFERS) {}
};

struct Operator FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef OperatorT NativeTableType;
    typedef OperatorBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return OperatorTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_OPCODE_INDEX             = 4,
        VT_INPUTS                   = 6,
        VT_OUTPUTS                  = 8,
        VT_BUILTIN_OPTIONS_TYPE     = 10,
        VT_BUILTIN_OPTIONS          = 12,
        VT_CUSTOM_OPTIONS           = 14,
        VT_CUSTOM_OPTIONS_FORMAT    = 16,
        VT_MUTATING_VARIABLE_INPUTS = 18,
        VT_INTERMEDIATES            = 20
    };
    uint32_t opcode_index() const {
        return GetField<uint32_t>(VT_OPCODE_INDEX, 0);
    }
    const flatbuffers::Vector<int32_t> *inputs() const {
        return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUTS);
    }
    const flatbuffers::Vector<int32_t> *outputs() const {
        return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
    }
    tflite::BuiltinOptions builtin_options_type() const {
        return static_cast<tflite::BuiltinOptions>(GetField<uint8_t>(VT_BUILTIN_OPTIONS_TYPE, 0));
    }
    const void *builtin_options() const {
        return GetPointer<const void *>(VT_BUILTIN_OPTIONS);
    }
    template <typename T>
    const T *builtin_options_as() const;
    const tflite::Conv2DOptions *builtin_options_as_Conv2DOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_Conv2DOptions
                   ? static_cast<const tflite::Conv2DOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::DepthwiseConv2DOptions *builtin_options_as_DepthwiseConv2DOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_DepthwiseConv2DOptions
                   ? static_cast<const tflite::DepthwiseConv2DOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::ConcatEmbeddingsOptions *builtin_options_as_ConcatEmbeddingsOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_ConcatEmbeddingsOptions
                   ? static_cast<const tflite::ConcatEmbeddingsOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::LSHProjectionOptions *builtin_options_as_LSHProjectionOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_LSHProjectionOptions
                   ? static_cast<const tflite::LSHProjectionOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::Pool2DOptions *builtin_options_as_Pool2DOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_Pool2DOptions
                   ? static_cast<const tflite::Pool2DOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SVDFOptions *builtin_options_as_SVDFOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SVDFOptions
                   ? static_cast<const tflite::SVDFOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::RNNOptions *builtin_options_as_RNNOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_RNNOptions
                   ? static_cast<const tflite::RNNOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::FullyConnectedOptions *builtin_options_as_FullyConnectedOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_FullyConnectedOptions
                   ? static_cast<const tflite::FullyConnectedOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SoftmaxOptions *builtin_options_as_SoftmaxOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SoftmaxOptions
                   ? static_cast<const tflite::SoftmaxOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::ConcatenationOptions *builtin_options_as_ConcatenationOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_ConcatenationOptions
                   ? static_cast<const tflite::ConcatenationOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::AddOptions *builtin_options_as_AddOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_AddOptions
                   ? static_cast<const tflite::AddOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::L2NormOptions *builtin_options_as_L2NormOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_L2NormOptions
                   ? static_cast<const tflite::L2NormOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::LocalResponseNormalizationOptions *builtin_options_as_LocalResponseNormalizationOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_LocalResponseNormalizationOptions
                   ? static_cast<const tflite::LocalResponseNormalizationOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::LSTMOptions *builtin_options_as_LSTMOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_LSTMOptions
                   ? static_cast<const tflite::LSTMOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::ResizeBilinearOptions *builtin_options_as_ResizeBilinearOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_ResizeBilinearOptions
                   ? static_cast<const tflite::ResizeBilinearOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::CallOptions *builtin_options_as_CallOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_CallOptions
                   ? static_cast<const tflite::CallOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::ReshapeOptions *builtin_options_as_ReshapeOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_ReshapeOptions
                   ? static_cast<const tflite::ReshapeOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SkipGramOptions *builtin_options_as_SkipGramOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SkipGramOptions
                   ? static_cast<const tflite::SkipGramOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SpaceToDepthOptions *builtin_options_as_SpaceToDepthOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SpaceToDepthOptions
                   ? static_cast<const tflite::SpaceToDepthOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::EmbeddingLookupSparseOptions *builtin_options_as_EmbeddingLookupSparseOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_EmbeddingLookupSparseOptions
                   ? static_cast<const tflite::EmbeddingLookupSparseOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::MulOptions *builtin_options_as_MulOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_MulOptions
                   ? static_cast<const tflite::MulOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::PadOptions *builtin_options_as_PadOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_PadOptions
                   ? static_cast<const tflite::PadOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::GatherOptions *builtin_options_as_GatherOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_GatherOptions
                   ? static_cast<const tflite::GatherOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::BatchToSpaceNDOptions *builtin_options_as_BatchToSpaceNDOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_BatchToSpaceNDOptions
                   ? static_cast<const tflite::BatchToSpaceNDOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SpaceToBatchNDOptions *builtin_options_as_SpaceToBatchNDOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SpaceToBatchNDOptions
                   ? static_cast<const tflite::SpaceToBatchNDOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::TransposeOptions *builtin_options_as_TransposeOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_TransposeOptions
                   ? static_cast<const tflite::TransposeOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::ReducerOptions *builtin_options_as_ReducerOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_ReducerOptions
                   ? static_cast<const tflite::ReducerOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SubOptions *builtin_options_as_SubOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SubOptions
                   ? static_cast<const tflite::SubOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::DivOptions *builtin_options_as_DivOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_DivOptions
                   ? static_cast<const tflite::DivOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SqueezeOptions *builtin_options_as_SqueezeOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SqueezeOptions
                   ? static_cast<const tflite::SqueezeOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SequenceRNNOptions *builtin_options_as_SequenceRNNOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SequenceRNNOptions
                   ? static_cast<const tflite::SequenceRNNOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::StridedSliceOptions *builtin_options_as_StridedSliceOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_StridedSliceOptions
                   ? static_cast<const tflite::StridedSliceOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::ExpOptions *builtin_options_as_ExpOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_ExpOptions
                   ? static_cast<const tflite::ExpOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::TopKV2Options *builtin_options_as_TopKV2Options() const {
        return builtin_options_type() == tflite::BuiltinOptions_TopKV2Options
                   ? static_cast<const tflite::TopKV2Options *>(builtin_options())
                   : nullptr;
    }
    const tflite::SplitOptions *builtin_options_as_SplitOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SplitOptions
                   ? static_cast<const tflite::SplitOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::LogSoftmaxOptions *builtin_options_as_LogSoftmaxOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_LogSoftmaxOptions
                   ? static_cast<const tflite::LogSoftmaxOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::CastOptions *builtin_options_as_CastOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_CastOptions
                   ? static_cast<const tflite::CastOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::DequantizeOptions *builtin_options_as_DequantizeOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_DequantizeOptions
                   ? static_cast<const tflite::DequantizeOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::MaximumMinimumOptions *builtin_options_as_MaximumMinimumOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_MaximumMinimumOptions
                   ? static_cast<const tflite::MaximumMinimumOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::ArgMaxOptions *builtin_options_as_ArgMaxOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_ArgMaxOptions
                   ? static_cast<const tflite::ArgMaxOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::LessOptions *builtin_options_as_LessOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_LessOptions
                   ? static_cast<const tflite::LessOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::NegOptions *builtin_options_as_NegOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_NegOptions
                   ? static_cast<const tflite::NegOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::PadV2Options *builtin_options_as_PadV2Options() const {
        return builtin_options_type() == tflite::BuiltinOptions_PadV2Options
                   ? static_cast<const tflite::PadV2Options *>(builtin_options())
                   : nullptr;
    }
    const tflite::GreaterOptions *builtin_options_as_GreaterOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_GreaterOptions
                   ? static_cast<const tflite::GreaterOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::GreaterEqualOptions *builtin_options_as_GreaterEqualOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_GreaterEqualOptions
                   ? static_cast<const tflite::GreaterEqualOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::LessEqualOptions *builtin_options_as_LessEqualOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_LessEqualOptions
                   ? static_cast<const tflite::LessEqualOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SelectOptions *builtin_options_as_SelectOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SelectOptions
                   ? static_cast<const tflite::SelectOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SliceOptions *builtin_options_as_SliceOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SliceOptions
                   ? static_cast<const tflite::SliceOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::TransposeConvOptions *builtin_options_as_TransposeConvOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_TransposeConvOptions
                   ? static_cast<const tflite::TransposeConvOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SparseToDenseOptions *builtin_options_as_SparseToDenseOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SparseToDenseOptions
                   ? static_cast<const tflite::SparseToDenseOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::TileOptions *builtin_options_as_TileOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_TileOptions
                   ? static_cast<const tflite::TileOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::ExpandDimsOptions *builtin_options_as_ExpandDimsOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_ExpandDimsOptions
                   ? static_cast<const tflite::ExpandDimsOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::EqualOptions *builtin_options_as_EqualOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_EqualOptions
                   ? static_cast<const tflite::EqualOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::NotEqualOptions *builtin_options_as_NotEqualOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_NotEqualOptions
                   ? static_cast<const tflite::NotEqualOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::ShapeOptions *builtin_options_as_ShapeOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_ShapeOptions
                   ? static_cast<const tflite::ShapeOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::PowOptions *builtin_options_as_PowOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_PowOptions
                   ? static_cast<const tflite::PowOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::ArgMinOptions *builtin_options_as_ArgMinOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_ArgMinOptions
                   ? static_cast<const tflite::ArgMinOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::FakeQuantOptions *builtin_options_as_FakeQuantOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_FakeQuantOptions
                   ? static_cast<const tflite::FakeQuantOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::PackOptions *builtin_options_as_PackOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_PackOptions
                   ? static_cast<const tflite::PackOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::LogicalOrOptions *builtin_options_as_LogicalOrOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_LogicalOrOptions
                   ? static_cast<const tflite::LogicalOrOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::OneHotOptions *builtin_options_as_OneHotOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_OneHotOptions
                   ? static_cast<const tflite::OneHotOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::LogicalAndOptions *builtin_options_as_LogicalAndOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_LogicalAndOptions
                   ? static_cast<const tflite::LogicalAndOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::LogicalNotOptions *builtin_options_as_LogicalNotOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_LogicalNotOptions
                   ? static_cast<const tflite::LogicalNotOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::UnpackOptions *builtin_options_as_UnpackOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_UnpackOptions
                   ? static_cast<const tflite::UnpackOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::FloorDivOptions *builtin_options_as_FloorDivOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_FloorDivOptions
                   ? static_cast<const tflite::FloorDivOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SquareOptions *builtin_options_as_SquareOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SquareOptions
                   ? static_cast<const tflite::SquareOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::ZerosLikeOptions *builtin_options_as_ZerosLikeOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_ZerosLikeOptions
                   ? static_cast<const tflite::ZerosLikeOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::FillOptions *builtin_options_as_FillOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_FillOptions
                   ? static_cast<const tflite::FillOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::BidirectionalSequenceLSTMOptions *builtin_options_as_BidirectionalSequenceLSTMOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_BidirectionalSequenceLSTMOptions
                   ? static_cast<const tflite::BidirectionalSequenceLSTMOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::BidirectionalSequenceRNNOptions *builtin_options_as_BidirectionalSequenceRNNOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_BidirectionalSequenceRNNOptions
                   ? static_cast<const tflite::BidirectionalSequenceRNNOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::UnidirectionalSequenceLSTMOptions *builtin_options_as_UnidirectionalSequenceLSTMOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_UnidirectionalSequenceLSTMOptions
                   ? static_cast<const tflite::UnidirectionalSequenceLSTMOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::FloorModOptions *builtin_options_as_FloorModOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_FloorModOptions
                   ? static_cast<const tflite::FloorModOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::RangeOptions *builtin_options_as_RangeOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_RangeOptions
                   ? static_cast<const tflite::RangeOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::ResizeNearestNeighborOptions *builtin_options_as_ResizeNearestNeighborOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_ResizeNearestNeighborOptions
                   ? static_cast<const tflite::ResizeNearestNeighborOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::LeakyReluOptions *builtin_options_as_LeakyReluOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_LeakyReluOptions
                   ? static_cast<const tflite::LeakyReluOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SquaredDifferenceOptions *builtin_options_as_SquaredDifferenceOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SquaredDifferenceOptions
                   ? static_cast<const tflite::SquaredDifferenceOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::MirrorPadOptions *builtin_options_as_MirrorPadOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_MirrorPadOptions
                   ? static_cast<const tflite::MirrorPadOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::AbsOptions *builtin_options_as_AbsOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_AbsOptions
                   ? static_cast<const tflite::AbsOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SplitVOptions *builtin_options_as_SplitVOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SplitVOptions
                   ? static_cast<const tflite::SplitVOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::UniqueOptions *builtin_options_as_UniqueOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_UniqueOptions
                   ? static_cast<const tflite::UniqueOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::ReverseV2Options *builtin_options_as_ReverseV2Options() const {
        return builtin_options_type() == tflite::BuiltinOptions_ReverseV2Options
                   ? static_cast<const tflite::ReverseV2Options *>(builtin_options())
                   : nullptr;
    }
    const tflite::AddNOptions *builtin_options_as_AddNOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_AddNOptions
                   ? static_cast<const tflite::AddNOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::GatherNdOptions *builtin_options_as_GatherNdOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_GatherNdOptions
                   ? static_cast<const tflite::GatherNdOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::CosOptions *builtin_options_as_CosOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_CosOptions
                   ? static_cast<const tflite::CosOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::WhereOptions *builtin_options_as_WhereOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_WhereOptions
                   ? static_cast<const tflite::WhereOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::RankOptions *builtin_options_as_RankOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_RankOptions
                   ? static_cast<const tflite::RankOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::ReverseSequenceOptions *builtin_options_as_ReverseSequenceOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_ReverseSequenceOptions
                   ? static_cast<const tflite::ReverseSequenceOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::MatrixDiagOptions *builtin_options_as_MatrixDiagOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_MatrixDiagOptions
                   ? static_cast<const tflite::MatrixDiagOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::QuantizeOptions *builtin_options_as_QuantizeOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_QuantizeOptions
                   ? static_cast<const tflite::QuantizeOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::MatrixSetDiagOptions *builtin_options_as_MatrixSetDiagOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_MatrixSetDiagOptions
                   ? static_cast<const tflite::MatrixSetDiagOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::HardSwishOptions *builtin_options_as_HardSwishOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_HardSwishOptions
                   ? static_cast<const tflite::HardSwishOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::IfOptions *builtin_options_as_IfOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_IfOptions
                   ? static_cast<const tflite::IfOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::WhileOptions *builtin_options_as_WhileOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_WhileOptions
                   ? static_cast<const tflite::WhileOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::DepthToSpaceOptions *builtin_options_as_DepthToSpaceOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_DepthToSpaceOptions
                   ? static_cast<const tflite::DepthToSpaceOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::NonMaxSuppressionV4Options *builtin_options_as_NonMaxSuppressionV4Options() const {
        return builtin_options_type() == tflite::BuiltinOptions_NonMaxSuppressionV4Options
                   ? static_cast<const tflite::NonMaxSuppressionV4Options *>(builtin_options())
                   : nullptr;
    }
    const tflite::NonMaxSuppressionV5Options *builtin_options_as_NonMaxSuppressionV5Options() const {
        return builtin_options_type() == tflite::BuiltinOptions_NonMaxSuppressionV5Options
                   ? static_cast<const tflite::NonMaxSuppressionV5Options *>(builtin_options())
                   : nullptr;
    }
    const tflite::ScatterNdOptions *builtin_options_as_ScatterNdOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_ScatterNdOptions
                   ? static_cast<const tflite::ScatterNdOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SelectV2Options *builtin_options_as_SelectV2Options() const {
        return builtin_options_type() == tflite::BuiltinOptions_SelectV2Options
                   ? static_cast<const tflite::SelectV2Options *>(builtin_options())
                   : nullptr;
    }
    const tflite::DensifyOptions *builtin_options_as_DensifyOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_DensifyOptions
                   ? static_cast<const tflite::DensifyOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SegmentSumOptions *builtin_options_as_SegmentSumOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SegmentSumOptions
                   ? static_cast<const tflite::SegmentSumOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::BatchMatMulOptions *builtin_options_as_BatchMatMulOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_BatchMatMulOptions
                   ? static_cast<const tflite::BatchMatMulOptions *>(builtin_options())
                   : nullptr;
    }
    const flatbuffers::Vector<uint8_t> *custom_options() const {
        return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CUSTOM_OPTIONS);
    }
    tflite::CustomOptionsFormat custom_options_format() const {
        return static_cast<tflite::CustomOptionsFormat>(GetField<int8_t>(VT_CUSTOM_OPTIONS_FORMAT, 0));
    }
    const flatbuffers::Vector<uint8_t> *mutating_variable_inputs() const {
        return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_MUTATING_VARIABLE_INPUTS);
    }
    const flatbuffers::Vector<int32_t> *intermediates() const {
        return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INTERMEDIATES);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_OPCODE_INDEX) &&
               VerifyOffset(verifier, VT_INPUTS) && verifier.VerifyVector(inputs()) &&
               VerifyOffset(verifier, VT_OUTPUTS) && verifier.VerifyVector(outputs()) &&
               VerifyField<uint8_t>(verifier, VT_BUILTIN_OPTIONS_TYPE) && VerifyOffset(verifier, VT_BUILTIN_OPTIONS) &&
               VerifyBuiltinOptions(verifier, builtin_options(), builtin_options_type()) &&
               VerifyOffset(verifier, VT_CUSTOM_OPTIONS) && verifier.VerifyVector(custom_options()) &&
               VerifyField<int8_t>(verifier, VT_CUSTOM_OPTIONS_FORMAT) &&
               VerifyOffset(verifier, VT_MUTATING_VARIABLE_INPUTS) &&
               verifier.VerifyVector(mutating_variable_inputs()) && VerifyOffset(verifier, VT_INTERMEDIATES) &&
               verifier.VerifyVector(intermediates()) && verifier.EndTable();
    }
    OperatorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(OperatorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<Operator> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT *_o,
                                              const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template <>
inline const tflite::Conv2DOptions *Operator::builtin_options_as<tflite::Conv2DOptions>() const {
    return builtin_options_as_Conv2DOptions();
}

template <>
inline const tflite::DepthwiseConv2DOptions *Operator::builtin_options_as<tflite::DepthwiseConv2DOptions>() const {
    return builtin_options_as_DepthwiseConv2DOptions();
}

template <>
inline const tflite::ConcatEmbeddingsOptions *Operator::builtin_options_as<tflite::ConcatEmbeddingsOptions>() const {
    return builtin_options_as_ConcatEmbeddingsOptions();
}

template <>
inline const tflite::LSHProjectionOptions *Operator::builtin_options_as<tflite::LSHProjectionOptions>() const {
    return builtin_options_as_LSHProjectionOptions();
}

template <>
inline const tflite::Pool2DOptions *Operator::builtin_options_as<tflite::Pool2DOptions>() const {
    return builtin_options_as_Pool2DOptions();
}

template <>
inline const tflite::SVDFOptions *Operator::builtin_options_as<tflite::SVDFOptions>() const {
    return builtin_options_as_SVDFOptions();
}

template <>
inline const tflite::RNNOptions *Operator::builtin_options_as<tflite::RNNOptions>() const {
    return builtin_options_as_RNNOptions();
}

template <>
inline const tflite::FullyConnectedOptions *Operator::builtin_options_as<tflite::FullyConnectedOptions>() const {
    return builtin_options_as_FullyConnectedOptions();
}

template <>
inline const tflite::SoftmaxOptions *Operator::builtin_options_as<tflite::SoftmaxOptions>() const {
    return builtin_options_as_SoftmaxOptions();
}

template <>
inline const tflite::ConcatenationOptions *Operator::builtin_options_as<tflite::ConcatenationOptions>() const {
    return builtin_options_as_ConcatenationOptions();
}

template <>
inline const tflite::AddOptions *Operator::builtin_options_as<tflite::AddOptions>() const {
    return builtin_options_as_AddOptions();
}

template <>
inline const tflite::L2NormOptions *Operator::builtin_options_as<tflite::L2NormOptions>() const {
    return builtin_options_as_L2NormOptions();
}

template <>
inline const tflite::LocalResponseNormalizationOptions *
Operator::builtin_options_as<tflite::LocalResponseNormalizationOptions>() const {
    return builtin_options_as_LocalResponseNormalizationOptions();
}

template <>
inline const tflite::LSTMOptions *Operator::builtin_options_as<tflite::LSTMOptions>() const {
    return builtin_options_as_LSTMOptions();
}

template <>
inline const tflite::ResizeBilinearOptions *Operator::builtin_options_as<tflite::ResizeBilinearOptions>() const {
    return builtin_options_as_ResizeBilinearOptions();
}

template <>
inline const tflite::CallOptions *Operator::builtin_options_as<tflite::CallOptions>() const {
    return builtin_options_as_CallOptions();
}

template <>
inline const tflite::ReshapeOptions *Operator::builtin_options_as<tflite::ReshapeOptions>() const {
    return builtin_options_as_ReshapeOptions();
}

template <>
inline const tflite::SkipGramOptions *Operator::builtin_options_as<tflite::SkipGramOptions>() const {
    return builtin_options_as_SkipGramOptions();
}

template <>
inline const tflite::SpaceToDepthOptions *Operator::builtin_options_as<tflite::SpaceToDepthOptions>() const {
    return builtin_options_as_SpaceToDepthOptions();
}

template <>
inline const tflite::EmbeddingLookupSparseOptions *Operator::builtin_options_as<tflite::EmbeddingLookupSparseOptions>()
    const {
    return builtin_options_as_EmbeddingLookupSparseOptions();
}

template <>
inline const tflite::MulOptions *Operator::builtin_options_as<tflite::MulOptions>() const {
    return builtin_options_as_MulOptions();
}

template <>
inline const tflite::PadOptions *Operator::builtin_options_as<tflite::PadOptions>() const {
    return builtin_options_as_PadOptions();
}

template <>
inline const tflite::GatherOptions *Operator::builtin_options_as<tflite::GatherOptions>() const {
    return builtin_options_as_GatherOptions();
}

template <>
inline const tflite::BatchToSpaceNDOptions *Operator::builtin_options_as<tflite::BatchToSpaceNDOptions>() const {
    return builtin_options_as_BatchToSpaceNDOptions();
}

template <>
inline const tflite::SpaceToBatchNDOptions *Operator::builtin_options_as<tflite::SpaceToBatchNDOptions>() const {
    return builtin_options_as_SpaceToBatchNDOptions();
}

template <>
inline const tflite::TransposeOptions *Operator::builtin_options_as<tflite::TransposeOptions>() const {
    return builtin_options_as_TransposeOptions();
}

template <>
inline const tflite::ReducerOptions *Operator::builtin_options_as<tflite::ReducerOptions>() const {
    return builtin_options_as_ReducerOptions();
}

template <>
inline const tflite::SubOptions *Operator::builtin_options_as<tflite::SubOptions>() const {
    return builtin_options_as_SubOptions();
}

template <>
inline const tflite::DivOptions *Operator::builtin_options_as<tflite::DivOptions>() const {
    return builtin_options_as_DivOptions();
}

template <>
inline const tflite::SqueezeOptions *Operator::builtin_options_as<tflite::SqueezeOptions>() const {
    return builtin_options_as_SqueezeOptions();
}

template <>
inline const tflite::SequenceRNNOptions *Operator::builtin_options_as<tflite::SequenceRNNOptions>() const {
    return builtin_options_as_SequenceRNNOptions();
}

template <>
inline const tflite::StridedSliceOptions *Operator::builtin_options_as<tflite::StridedSliceOptions>() const {
    return builtin_options_as_StridedSliceOptions();
}

template <>
inline const tflite::ExpOptions *Operator::builtin_options_as<tflite::ExpOptions>() const {
    return builtin_options_as_ExpOptions();
}

template <>
inline const tflite::TopKV2Options *Operator::builtin_options_as<tflite::TopKV2Options>() const {
    return builtin_options_as_TopKV2Options();
}

template <>
inline const tflite::SplitOptions *Operator::builtin_options_as<tflite::SplitOptions>() const {
    return builtin_options_as_SplitOptions();
}

template <>
inline const tflite::LogSoftmaxOptions *Operator::builtin_options_as<tflite::LogSoftmaxOptions>() const {
    return builtin_options_as_LogSoftmaxOptions();
}

template <>
inline const tflite::CastOptions *Operator::builtin_options_as<tflite::CastOptions>() const {
    return builtin_options_as_CastOptions();
}

template <>
inline const tflite::DequantizeOptions *Operator::builtin_options_as<tflite::DequantizeOptions>() const {
    return builtin_options_as_DequantizeOptions();
}

template <>
inline const tflite::MaximumMinimumOptions *Operator::builtin_options_as<tflite::MaximumMinimumOptions>() const {
    return builtin_options_as_MaximumMinimumOptions();
}

template <>
inline const tflite::ArgMaxOptions *Operator::builtin_options_as<tflite::ArgMaxOptions>() const {
    return builtin_options_as_ArgMaxOptions();
}

template <>
inline const tflite::LessOptions *Operator::builtin_options_as<tflite::LessOptions>() const {
    return builtin_options_as_LessOptions();
}

template <>
inline const tflite::NegOptions *Operator::builtin_options_as<tflite::NegOptions>() const {
    return builtin_options_as_NegOptions();
}

template <>
inline const tflite::PadV2Options *Operator::builtin_options_as<tflite::PadV2Options>() const {
    return builtin_options_as_PadV2Options();
}

template <>
inline const tflite::GreaterOptions *Operator::builtin_options_as<tflite::GreaterOptions>() const {
    return builtin_options_as_GreaterOptions();
}

template <>
inline const tflite::GreaterEqualOptions *Operator::builtin_options_as<tflite::GreaterEqualOptions>() const {
    return builtin_options_as_GreaterEqualOptions();
}

template <>
inline const tflite::LessEqualOptions *Operator::builtin_options_as<tflite::LessEqualOptions>() const {
    return builtin_options_as_LessEqualOptions();
}

template <>
inline const tflite::SelectOptions *Operator::builtin_options_as<tflite::SelectOptions>() const {
    return builtin_options_as_SelectOptions();
}

template <>
inline const tflite::SliceOptions *Operator::builtin_options_as<tflite::SliceOptions>() const {
    return builtin_options_as_SliceOptions();
}

template <>
inline const tflite::TransposeConvOptions *Operator::builtin_options_as<tflite::TransposeConvOptions>() const {
    return builtin_options_as_TransposeConvOptions();
}

template <>
inline const tflite::SparseToDenseOptions *Operator::builtin_options_as<tflite::SparseToDenseOptions>() const {
    return builtin_options_as_SparseToDenseOptions();
}

template <>
inline const tflite::TileOptions *Operator::builtin_options_as<tflite::TileOptions>() const {
    return builtin_options_as_TileOptions();
}

template <>
inline const tflite::ExpandDimsOptions *Operator::builtin_options_as<tflite::ExpandDimsOptions>() const {
    return builtin_options_as_ExpandDimsOptions();
}

template <>
inline const tflite::EqualOptions *Operator::builtin_options_as<tflite::EqualOptions>() const {
    return builtin_options_as_EqualOptions();
}

template <>
inline const tflite::NotEqualOptions *Operator::builtin_options_as<tflite::NotEqualOptions>() const {
    return builtin_options_as_NotEqualOptions();
}

template <>
inline const tflite::ShapeOptions *Operator::builtin_options_as<tflite::ShapeOptions>() const {
    return builtin_options_as_ShapeOptions();
}

template <>
inline const tflite::PowOptions *Operator::builtin_options_as<tflite::PowOptions>() const {
    return builtin_options_as_PowOptions();
}

template <>
inline const tflite::ArgMinOptions *Operator::builtin_options_as<tflite::ArgMinOptions>() const {
    return builtin_options_as_ArgMinOptions();
}

template <>
inline const tflite::FakeQuantOptions *Operator::builtin_options_as<tflite::FakeQuantOptions>() const {
    return builtin_options_as_FakeQuantOptions();
}

template <>
inline const tflite::PackOptions *Operator::builtin_options_as<tflite::PackOptions>() const {
    return builtin_options_as_PackOptions();
}

template <>
inline const tflite::LogicalOrOptions *Operator::builtin_options_as<tflite::LogicalOrOptions>() const {
    return builtin_options_as_LogicalOrOptions();
}

template <>
inline const tflite::OneHotOptions *Operator::builtin_options_as<tflite::OneHotOptions>() const {
    return builtin_options_as_OneHotOptions();
}

template <>
inline const tflite::LogicalAndOptions *Operator::builtin_options_as<tflite::LogicalAndOptions>() const {
    return builtin_options_as_LogicalAndOptions();
}

template <>
inline const tflite::LogicalNotOptions *Operator::builtin_options_as<tflite::LogicalNotOptions>() const {
    return builtin_options_as_LogicalNotOptions();
}

template <>
inline const tflite::UnpackOptions *Operator::builtin_options_as<tflite::UnpackOptions>() const {
    return builtin_options_as_UnpackOptions();
}

template <>
inline const tflite::FloorDivOptions *Operator::builtin_options_as<tflite::FloorDivOptions>() const {
    return builtin_options_as_FloorDivOptions();
}

template <>
inline const tflite::SquareOptions *Operator::builtin_options_as<tflite::SquareOptions>() const {
    return builtin_options_as_SquareOptions();
}

template <>
inline const tflite::ZerosLikeOptions *Operator::builtin_options_as<tflite::ZerosLikeOptions>() const {
    return builtin_options_as_ZerosLikeOptions();
}

template <>
inline const tflite::FillOptions *Operator::builtin_options_as<tflite::FillOptions>() const {
    return builtin_options_as_FillOptions();
}

template <>
inline const tflite::BidirectionalSequenceLSTMOptions *
Operator::builtin_options_as<tflite::BidirectionalSequenceLSTMOptions>() const {
    return builtin_options_as_BidirectionalSequenceLSTMOptions();
}

template <>
inline const tflite::BidirectionalSequenceRNNOptions *
Operator::builtin_options_as<tflite::BidirectionalSequenceRNNOptions>() const {
    return builtin_options_as_BidirectionalSequenceRNNOptions();
}

template <>
inline const tflite::UnidirectionalSequenceLSTMOptions *
Operator::builtin_options_as<tflite::UnidirectionalSequenceLSTMOptions>() const {
    return builtin_options_as_UnidirectionalSequenceLSTMOptions();
}

template <>
inline const tflite::FloorModOptions *Operator::builtin_options_as<tflite::FloorModOptions>() const {
    return builtin_options_as_FloorModOptions();
}

template <>
inline const tflite::RangeOptions *Operator::builtin_options_as<tflite::RangeOptions>() const {
    return builtin_options_as_RangeOptions();
}

template <>
inline const tflite::ResizeNearestNeighborOptions *Operator::builtin_options_as<tflite::ResizeNearestNeighborOptions>()
    const {
    return builtin_options_as_ResizeNearestNeighborOptions();
}

template <>
inline const tflite::LeakyReluOptions *Operator::builtin_options_as<tflite::LeakyReluOptions>() const {
    return builtin_options_as_LeakyReluOptions();
}

template <>
inline const tflite::SquaredDifferenceOptions *Operator::builtin_options_as<tflite::SquaredDifferenceOptions>() const {
    return builtin_options_as_SquaredDifferenceOptions();
}

template <>
inline const tflite::MirrorPadOptions *Operator::builtin_options_as<tflite::MirrorPadOptions>() const {
    return builtin_options_as_MirrorPadOptions();
}

template <>
inline const tflite::AbsOptions *Operator::builtin_options_as<tflite::AbsOptions>() const {
    return builtin_options_as_AbsOptions();
}

template <>
inline const tflite::SplitVOptions *Operator::builtin_options_as<tflite::SplitVOptions>() const {
    return builtin_options_as_SplitVOptions();
}

template <>
inline const tflite::UniqueOptions *Operator::builtin_options_as<tflite::UniqueOptions>() const {
    return builtin_options_as_UniqueOptions();
}

template <>
inline const tflite::ReverseV2Options *Operator::builtin_options_as<tflite::ReverseV2Options>() const {
    return builtin_options_as_ReverseV2Options();
}

template <>
inline const tflite::AddNOptions *Operator::builtin_options_as<tflite::AddNOptions>() const {
    return builtin_options_as_AddNOptions();
}

template <>
inline const tflite::GatherNdOptions *Operator::builtin_options_as<tflite::GatherNdOptions>() const {
    return builtin_options_as_GatherNdOptions();
}

template <>
inline const tflite::CosOptions *Operator::builtin_options_as<tflite::CosOptions>() const {
    return builtin_options_as_CosOptions();
}

template <>
inline const tflite::WhereOptions *Operator::builtin_options_as<tflite::WhereOptions>() const {
    return builtin_options_as_WhereOptions();
}

template <>
inline const tflite::RankOptions *Operator::builtin_options_as<tflite::RankOptions>() const {
    return builtin_options_as_RankOptions();
}

template <>
inline const tflite::ReverseSequenceOptions *Operator::builtin_options_as<tflite::ReverseSequenceOptions>() const {
    return builtin_options_as_ReverseSequenceOptions();
}

template <>
inline const tflite::MatrixDiagOptions *Operator::builtin_options_as<tflite::MatrixDiagOptions>() const {
    return builtin_options_as_MatrixDiagOptions();
}

template <>
inline const tflite::QuantizeOptions *Operator::builtin_options_as<tflite::QuantizeOptions>() const {
    return builtin_options_as_QuantizeOptions();
}

template <>
inline const tflite::MatrixSetDiagOptions *Operator::builtin_options_as<tflite::MatrixSetDiagOptions>() const {
    return builtin_options_as_MatrixSetDiagOptions();
}

template <>
inline const tflite::HardSwishOptions *Operator::builtin_options_as<tflite::HardSwishOptions>() const {
    return builtin_options_as_HardSwishOptions();
}

template <>
inline const tflite::IfOptions *Operator::builtin_options_as<tflite::IfOptions>() const {
    return builtin_options_as_IfOptions();
}

template <>
inline const tflite::WhileOptions *Operator::builtin_options_as<tflite::WhileOptions>() const {
    return builtin_options_as_WhileOptions();
}

template <>
inline const tflite::DepthToSpaceOptions *Operator::builtin_options_as<tflite::DepthToSpaceOptions>() const {
    return builtin_options_as_DepthToSpaceOptions();
}

template <>
inline const tflite::NonMaxSuppressionV4Options *Operator::builtin_options_as<tflite::NonMaxSuppressionV4Options>()
    const {
    return builtin_options_as_NonMaxSuppressionV4Options();
}

template <>
inline const tflite::NonMaxSuppressionV5Options *Operator::builtin_options_as<tflite::NonMaxSuppressionV5Options>()
    const {
    return builtin_options_as_NonMaxSuppressionV5Options();
}

template <>
inline const tflite::ScatterNdOptions *Operator::builtin_options_as<tflite::ScatterNdOptions>() const {
    return builtin_options_as_ScatterNdOptions();
}

template <>
inline const tflite::SelectV2Options *Operator::builtin_options_as<tflite::SelectV2Options>() const {
    return builtin_options_as_SelectV2Options();
}

template <>
inline const tflite::DensifyOptions *Operator::builtin_options_as<tflite::DensifyOptions>() const {
    return builtin_options_as_DensifyOptions();
}

template <>
inline const tflite::SegmentSumOptions *Operator::builtin_options_as<tflite::SegmentSumOptions>() const {
    return builtin_options_as_SegmentSumOptions();
}

template <>
inline const tflite::BatchMatMulOptions *Operator::builtin_options_as<tflite::BatchMatMulOptions>() const {
    return builtin_options_as_BatchMatMulOptions();
}

struct OperatorBuilder {
    typedef Operator Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_opcode_index(uint32_t opcode_index) {
        fbb_.AddElement<uint32_t>(Operator::VT_OPCODE_INDEX, opcode_index, 0);
    }
    void add_inputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs) {
        fbb_.AddOffset(Operator::VT_INPUTS, inputs);
    }
    void add_outputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs) {
        fbb_.AddOffset(Operator::VT_OUTPUTS, outputs);
    }
    void add_builtin_options_type(tflite::BuiltinOptions builtin_options_type) {
        fbb_.AddElement<uint8_t>(Operator::VT_BUILTIN_OPTIONS_TYPE, static_cast<uint8_t>(builtin_options_type), 0);
    }
    void add_builtin_options(flatbuffers::Offset<void> builtin_options) {
        fbb_.AddOffset(Operator::VT_BUILTIN_OPTIONS, builtin_options);
    }
    void add_custom_options(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom_options) {
        fbb_.AddOffset(Operator::VT_CUSTOM_OPTIONS, custom_options);
    }
    void add_custom_options_format(tflite::CustomOptionsFormat custom_options_format) {
        fbb_.AddElement<int8_t>(Operator::VT_CUSTOM_OPTIONS_FORMAT, static_cast<int8_t>(custom_options_format), 0);
    }
    void add_mutating_variable_inputs(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mutating_variable_inputs) {
        fbb_.AddOffset(Operator::VT_MUTATING_VARIABLE_INPUTS, mutating_variable_inputs);
    }
    void add_intermediates(flatbuffers::Offset<flatbuffers::Vector<int32_t>> intermediates) {
        fbb_.AddOffset(Operator::VT_INTERMEDIATES, intermediates);
    }
    explicit OperatorBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    OperatorBuilder &operator=(const OperatorBuilder &);
    flatbuffers::Offset<Operator> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<Operator>(end);
        return o;
    }
};

inline flatbuffers::Offset<Operator> CreateOperator(
    flatbuffers::FlatBufferBuilder &_fbb, uint32_t opcode_index = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs  = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs = 0,
    tflite::BuiltinOptions builtin_options_type               = tflite::BuiltinOptions_NONE,
    flatbuffers::Offset<void> builtin_options = 0, flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom_options = 0,
    tflite::CustomOptionsFormat custom_options_format = tflite::CustomOptionsFormat_FLEXBUFFERS,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mutating_variable_inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> intermediates            = 0) {
    OperatorBuilder builder_(_fbb);
    builder_.add_intermediates(intermediates);
    builder_.add_mutating_variable_inputs(mutating_variable_inputs);
    builder_.add_custom_options(custom_options);
    builder_.add_builtin_options(builtin_options);
    builder_.add_outputs(outputs);
    builder_.add_inputs(inputs);
    builder_.add_opcode_index(opcode_index);
    builder_.add_custom_options_format(custom_options_format);
    builder_.add_builtin_options_type(builtin_options_type);
    return builder_.Finish();
}

inline flatbuffers::Offset<Operator> CreateOperatorDirect(
    flatbuffers::FlatBufferBuilder &_fbb, uint32_t opcode_index = 0, const std::vector<int32_t> *inputs = nullptr,
    const std::vector<int32_t> *outputs         = nullptr,
    tflite::BuiltinOptions builtin_options_type = tflite::BuiltinOptions_NONE,
    flatbuffers::Offset<void> builtin_options = 0, const std::vector<uint8_t> *custom_options = nullptr,
    tflite::CustomOptionsFormat custom_options_format    = tflite::CustomOptionsFormat_FLEXBUFFERS,
    const std::vector<uint8_t> *mutating_variable_inputs = nullptr,
    const std::vector<int32_t> *intermediates            = nullptr) {
    auto inputs__         = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;
    auto outputs__        = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
    auto custom_options__ = custom_options ? _fbb.CreateVector<uint8_t>(*custom_options) : 0;
    auto mutating_variable_inputs__ =
        mutating_variable_inputs ? _fbb.CreateVector<uint8_t>(*mutating_variable_inputs) : 0;
    auto intermediates__ = intermediates ? _fbb.CreateVector<int32_t>(*intermediates) : 0;
    return tflite::CreateOperator(_fbb, opcode_index, inputs__, outputs__, builtin_options_type, builtin_options,
                                  custom_options__, custom_options_format, mutating_variable_inputs__, intermediates__);
}

flatbuffers::Offset<Operator> CreateOperator(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT *_o,
                                             const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubGraphT : public flatbuffers::NativeTable {
    typedef SubGraph TableType;
    std::vector<std::unique_ptr<tflite::TensorT>> tensors;
    std::vector<int32_t> inputs;
    std::vector<int32_t> outputs;
    std::vector<std::unique_ptr<tflite::OperatorT>> operators;
    std::string name;
    SubGraphT() {}
};

struct SubGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SubGraphT NativeTableType;
    typedef SubGraphBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SubGraphTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_TENSORS   = 4,
        VT_INPUTS    = 6,
        VT_OUTPUTS   = 8,
        VT_OPERATORS = 10,
        VT_NAME      = 12
    };
    const flatbuffers::Vector<flatbuffers::Offset<tflite::Tensor>> *tensors() const {
        return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::Tensor>> *>(VT_TENSORS);
    }
    const flatbuffers::Vector<int32_t> *inputs() const {
        return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUTS);
    }
    const flatbuffers::Vector<int32_t> *outputs() const {
        return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
    }
    const flatbuffers::Vector<flatbuffers::Offset<tflite::Operator>> *operators() const {
        return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::Operator>> *>(VT_OPERATORS);
    }
    const flatbuffers::String *name() const {
        return GetPointer<const flatbuffers::String *>(VT_NAME);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TENSORS) && verifier.VerifyVector(tensors()) &&
               verifier.VerifyVectorOfTables(tensors()) && VerifyOffset(verifier, VT_INPUTS) &&
               verifier.VerifyVector(inputs()) && VerifyOffset(verifier, VT_OUTPUTS) &&
               verifier.VerifyVector(outputs()) && VerifyOffset(verifier, VT_OPERATORS) &&
               verifier.VerifyVector(operators()) && verifier.VerifyVectorOfTables(operators()) &&
               VerifyOffset(verifier, VT_NAME) && verifier.VerifyString(name()) && verifier.EndTable();
    }
    SubGraphT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SubGraphT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SubGraph> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o,
                                              const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubGraphBuilder {
    typedef SubGraph Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_tensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Tensor>>> tensors) {
        fbb_.AddOffset(SubGraph::VT_TENSORS, tensors);
    }
    void add_inputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs) {
        fbb_.AddOffset(SubGraph::VT_INPUTS, inputs);
    }
    void add_outputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs) {
        fbb_.AddOffset(SubGraph::VT_OUTPUTS, outputs);
    }
    void add_operators(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Operator>>> operators) {
        fbb_.AddOffset(SubGraph::VT_OPERATORS, operators);
    }
    void add_name(flatbuffers::Offset<flatbuffers::String> name) {
        fbb_.AddOffset(SubGraph::VT_NAME, name);
    }
    explicit SubGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SubGraphBuilder &operator=(const SubGraphBuilder &);
    flatbuffers::Offset<SubGraph> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SubGraph>(end);
        return o;
    }
};

inline flatbuffers::Offset<SubGraph> CreateSubGraph(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Tensor>>> tensors     = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs                                  = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs                                 = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Operator>>> operators = 0,
    flatbuffers::Offset<flatbuffers::String> name                                             = 0) {
    SubGraphBuilder builder_(_fbb);
    builder_.add_name(name);
    builder_.add_operators(operators);
    builder_.add_outputs(outputs);
    builder_.add_inputs(inputs);
    builder_.add_tensors(tensors);
    return builder_.Finish();
}

inline flatbuffers::Offset<SubGraph> CreateSubGraphDirect(
    flatbuffers::FlatBufferBuilder &_fbb, const std::vector<flatbuffers::Offset<tflite::Tensor>> *tensors = nullptr,
    const std::vector<int32_t> *inputs = nullptr, const std::vector<int32_t> *outputs = nullptr,
    const std::vector<flatbuffers::Offset<tflite::Operator>> *operators = nullptr, const char *name = nullptr) {
    auto tensors__   = tensors ? _fbb.CreateVector<flatbuffers::Offset<tflite::Tensor>>(*tensors) : 0;
    auto inputs__    = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;
    auto outputs__   = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
    auto operators__ = operators ? _fbb.CreateVector<flatbuffers::Offset<tflite::Operator>>(*operators) : 0;
    auto name__      = name ? _fbb.CreateString(name) : 0;
    return tflite::CreateSubGraph(_fbb, tensors__, inputs__, outputs__, operators__, name__);
}

flatbuffers::Offset<SubGraph> CreateSubGraph(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o,
                                             const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BufferT : public flatbuffers::NativeTable {
    typedef Buffer TableType;
    std::vector<uint8_t> data;
    BufferT() {}
};

struct Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef BufferT NativeTableType;
    typedef BufferBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return BufferTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_DATA = 4 };
    const flatbuffers::Vector<uint8_t> *data() const {
        return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_DATA) && verifier.VerifyVector(data()) &&
               verifier.EndTable();
    }
    BufferT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(BufferT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<Buffer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BufferT *_o,
                                            const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BufferBuilder {
    typedef Buffer Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
        fbb_.AddOffset(Buffer::VT_DATA, data);
    }
    explicit BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    BufferBuilder &operator=(const BufferBuilder &);
    flatbuffers::Offset<Buffer> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<Buffer>(end);
        return o;
    }
};

inline flatbuffers::Offset<Buffer> CreateBuffer(flatbuffers::FlatBufferBuilder &_fbb,
                                                flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
    BufferBuilder builder_(_fbb);
    builder_.add_data(data);
    return builder_.Finish();
}

inline flatbuffers::Offset<Buffer> CreateBufferDirect(flatbuffers::FlatBufferBuilder &_fbb,
                                                      const std::vector<uint8_t> *data = nullptr) {
    if (data) {
        _fbb.ForceVectorAlignment(data->size(), sizeof(uint8_t), 16);
    }
    auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
    return tflite::CreateBuffer(_fbb, data__);
}

flatbuffers::Offset<Buffer> CreateBuffer(flatbuffers::FlatBufferBuilder &_fbb, const BufferT *_o,
                                         const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MetadataT : public flatbuffers::NativeTable {
    typedef Metadata TableType;
    std::string name;
    uint32_t buffer;
    MetadataT() : buffer(0) {}
};

struct Metadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef MetadataT NativeTableType;
    typedef MetadataBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return MetadataTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_NAME = 4, VT_BUFFER = 6 };
    const flatbuffers::String *name() const {
        return GetPointer<const flatbuffers::String *>(VT_NAME);
    }
    uint32_t buffer() const {
        return GetField<uint32_t>(VT_BUFFER, 0);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NAME) && verifier.VerifyString(name()) &&
               VerifyField<uint32_t>(verifier, VT_BUFFER) && verifier.EndTable();
    }
    MetadataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(MetadataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<Metadata> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o,
                                              const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MetadataBuilder {
    typedef Metadata Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_name(flatbuffers::Offset<flatbuffers::String> name) {
        fbb_.AddOffset(Metadata::VT_NAME, name);
    }
    void add_buffer(uint32_t buffer) {
        fbb_.AddElement<uint32_t>(Metadata::VT_BUFFER, buffer, 0);
    }
    explicit MetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    MetadataBuilder &operator=(const MetadataBuilder &);
    flatbuffers::Offset<Metadata> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<Metadata>(end);
        return o;
    }
};

inline flatbuffers::Offset<Metadata> CreateMetadata(flatbuffers::FlatBufferBuilder &_fbb,
                                                    flatbuffers::Offset<flatbuffers::String> name = 0,
                                                    uint32_t buffer                               = 0) {
    MetadataBuilder builder_(_fbb);
    builder_.add_buffer(buffer);
    builder_.add_name(name);
    return builder_.Finish();
}

inline flatbuffers::Offset<Metadata> CreateMetadataDirect(flatbuffers::FlatBufferBuilder &_fbb,
                                                          const char *name = nullptr, uint32_t buffer = 0) {
    auto name__ = name ? _fbb.CreateString(name) : 0;
    return tflite::CreateMetadata(_fbb, name__, buffer);
}

flatbuffers::Offset<Metadata> CreateMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o,
                                             const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ModelT : public flatbuffers::NativeTable {
    typedef Model TableType;
    uint32_t version;
    std::vector<std::unique_ptr<tflite::OperatorCodeT>> operator_codes;
    std::vector<std::unique_ptr<tflite::SubGraphT>> subgraphs;
    std::string description;
    std::vector<std::unique_ptr<tflite::BufferT>> buffers;
    std::vector<int32_t> metadata_buffer;
    std::vector<std::unique_ptr<tflite::MetadataT>> metadata;
    ModelT() : version(0) {}
};

struct Model FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ModelT NativeTableType;
    typedef ModelBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ModelTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_VERSION         = 4,
        VT_OPERATOR_CODES  = 6,
        VT_SUBGRAPHS       = 8,
        VT_DESCRIPTION     = 10,
        VT_BUFFERS         = 12,
        VT_METADATA_BUFFER = 14,
        VT_METADATA        = 16
    };
    uint32_t version() const {
        return GetField<uint32_t>(VT_VERSION, 0);
    }
    const flatbuffers::Vector<flatbuffers::Offset<tflite::OperatorCode>> *operator_codes() const {
        return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::OperatorCode>> *>(VT_OPERATOR_CODES);
    }
    const flatbuffers::Vector<flatbuffers::Offset<tflite::SubGraph>> *subgraphs() const {
        return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::SubGraph>> *>(VT_SUBGRAPHS);
    }
    const flatbuffers::String *description() const {
        return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
    }
    const flatbuffers::Vector<flatbuffers::Offset<tflite::Buffer>> *buffers() const {
        return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::Buffer>> *>(VT_BUFFERS);
    }
    const flatbuffers::Vector<int32_t> *metadata_buffer() const {
        return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_METADATA_BUFFER);
    }
    const flatbuffers::Vector<flatbuffers::Offset<tflite::Metadata>> *metadata() const {
        return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::Metadata>> *>(VT_METADATA);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_VERSION) &&
               VerifyOffset(verifier, VT_OPERATOR_CODES) && verifier.VerifyVector(operator_codes()) &&
               verifier.VerifyVectorOfTables(operator_codes()) && VerifyOffset(verifier, VT_SUBGRAPHS) &&
               verifier.VerifyVector(subgraphs()) && verifier.VerifyVectorOfTables(subgraphs()) &&
               VerifyOffset(verifier, VT_DESCRIPTION) && verifier.VerifyString(description()) &&
               VerifyOffset(verifier, VT_BUFFERS) && verifier.VerifyVector(buffers()) &&
               verifier.VerifyVectorOfTables(buffers()) && VerifyOffset(verifier, VT_METADATA_BUFFER) &&
               verifier.VerifyVector(metadata_buffer()) && VerifyOffset(verifier, VT_METADATA) &&
               verifier.VerifyVector(metadata()) && verifier.VerifyVectorOfTables(metadata()) && verifier.EndTable();
    }
    ModelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ModelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<Model> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o,
                                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ModelBuilder {
    typedef Model Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_version(uint32_t version) {
        fbb_.AddElement<uint32_t>(Model::VT_VERSION, version, 0);
    }
    void add_operator_codes(
        flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::OperatorCode>>> operator_codes) {
        fbb_.AddOffset(Model::VT_OPERATOR_CODES, operator_codes);
    }
    void add_subgraphs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::SubGraph>>> subgraphs) {
        fbb_.AddOffset(Model::VT_SUBGRAPHS, subgraphs);
    }
    void add_description(flatbuffers::Offset<flatbuffers::String> description) {
        fbb_.AddOffset(Model::VT_DESCRIPTION, description);
    }
    void add_buffers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Buffer>>> buffers) {
        fbb_.AddOffset(Model::VT_BUFFERS, buffers);
    }
    void add_metadata_buffer(flatbuffers::Offset<flatbuffers::Vector<int32_t>> metadata_buffer) {
        fbb_.AddOffset(Model::VT_METADATA_BUFFER, metadata_buffer);
    }
    void add_metadata(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Metadata>>> metadata) {
        fbb_.AddOffset(Model::VT_METADATA, metadata);
    }
    explicit ModelBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ModelBuilder &operator=(const ModelBuilder &);
    flatbuffers::Offset<Model> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<Model>(end);
        return o;
    }
};

inline flatbuffers::Offset<Model> CreateModel(
    flatbuffers::FlatBufferBuilder &_fbb, uint32_t version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::OperatorCode>>> operator_codes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::SubGraph>>> subgraphs          = 0,
    flatbuffers::Offset<flatbuffers::String> description                                               = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Buffer>>> buffers              = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> metadata_buffer                                  = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Metadata>>> metadata           = 0) {
    ModelBuilder builder_(_fbb);
    builder_.add_metadata(metadata);
    builder_.add_metadata_buffer(metadata_buffer);
    builder_.add_buffers(buffers);
    builder_.add_description(description);
    builder_.add_subgraphs(subgraphs);
    builder_.add_operator_codes(operator_codes);
    builder_.add_version(version);
    return builder_.Finish();
}

inline flatbuffers::Offset<Model> CreateModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb, uint32_t version = 0,
    const std::vector<flatbuffers::Offset<tflite::OperatorCode>> *operator_codes = nullptr,
    const std::vector<flatbuffers::Offset<tflite::SubGraph>> *subgraphs = nullptr, const char *description = nullptr,
    const std::vector<flatbuffers::Offset<tflite::Buffer>> *buffers    = nullptr,
    const std::vector<int32_t> *metadata_buffer                        = nullptr,
    const std::vector<flatbuffers::Offset<tflite::Metadata>> *metadata = nullptr) {
    auto operator_codes__ =
        operator_codes ? _fbb.CreateVector<flatbuffers::Offset<tflite::OperatorCode>>(*operator_codes) : 0;
    auto subgraphs__       = subgraphs ? _fbb.CreateVector<flatbuffers::Offset<tflite::SubGraph>>(*subgraphs) : 0;
    auto description__     = description ? _fbb.CreateString(description) : 0;
    auto buffers__         = buffers ? _fbb.CreateVector<flatbuffers::Offset<tflite::Buffer>>(*buffers) : 0;
    auto metadata_buffer__ = metadata_buffer ? _fbb.CreateVector<int32_t>(*metadata_buffer) : 0;
    auto metadata__        = metadata ? _fbb.CreateVector<flatbuffers::Offset<tflite::Metadata>>(*metadata) : 0;
    return tflite::CreateModel(_fbb, version, operator_codes__, subgraphs__, description__, buffers__,
                               metadata_buffer__, metadata__);
}

flatbuffers::Offset<Model> CreateModel(flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o,
                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline CustomQuantizationT *CustomQuantization::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::CustomQuantizationT> _o =
        std::unique_ptr<tflite::CustomQuantizationT>(new CustomQuantizationT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void CustomQuantization::UnPackTo(CustomQuantizationT *_o,
                                         const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e = custom();
        if (_e) {
            _o->custom.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->custom[_i] = _e->Get(_i);
            }
        }
    }
}

inline flatbuffers::Offset<CustomQuantization> CustomQuantization::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateCustomQuantization(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CustomQuantization> CreateCustomQuantization(
    flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const CustomQuantizationT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    _fbb.ForceVectorAlignment(_o->custom.size(), sizeof(uint8_t), 16);
    auto _custom = _o->custom.size() ? _fbb.CreateVector(_o->custom) : 0;
    return tflite::CreateCustomQuantization(_fbb, _custom);
}

inline QuantizationParametersT *QuantizationParameters::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::QuantizationParametersT> _o =
        std::unique_ptr<tflite::QuantizationParametersT>(new QuantizationParametersT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void QuantizationParameters::UnPackTo(QuantizationParametersT *_o,
                                             const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e = min();
        if (_e) {
            _o->min.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->min[_i] = _e->Get(_i);
            }
        }
    }
    {
        auto _e = max();
        if (_e) {
            _o->max.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->max[_i] = _e->Get(_i);
            }
        }
    }
    {
        auto _e = scale();
        if (_e) {
            _o->scale.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->scale[_i] = _e->Get(_i);
            }
        }
    }
    {
        auto _e = zero_point();
        if (_e) {
            _o->zero_point.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->zero_point[_i] = _e->Get(_i);
            }
        }
    }
    {
        auto _e          = details_type();
        _o->details.type = _e;
    }
    {
        auto _e = details();
        if (_e)
            _o->details.value = tflite::QuantizationDetailsUnion::UnPack(_e, details_type(), _resolver);
    }
    {
        auto _e                 = quantized_dimension();
        _o->quantized_dimension = _e;
    }
}

inline flatbuffers::Offset<QuantizationParameters> QuantizationParameters::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateQuantizationParameters(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(
    flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const QuantizationParametersT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _min                 = _o->min.size() ? _fbb.CreateVector(_o->min) : 0;
    auto _max                 = _o->max.size() ? _fbb.CreateVector(_o->max) : 0;
    auto _scale               = _o->scale.size() ? _fbb.CreateVector(_o->scale) : 0;
    auto _zero_point          = _o->zero_point.size() ? _fbb.CreateVector(_o->zero_point) : 0;
    auto _details_type        = _o->details.type;
    auto _details             = _o->details.Pack(_fbb);
    auto _quantized_dimension = _o->quantized_dimension;
    return tflite::CreateQuantizationParameters(_fbb, _min, _max, _scale, _zero_point, _details_type, _details,
                                                _quantized_dimension);
}

inline Int32VectorT *Int32Vector::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::Int32VectorT> _o = std::unique_ptr<tflite::Int32VectorT>(new Int32VectorT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void Int32Vector::UnPackTo(Int32VectorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e = values();
        if (_e) {
            _o->values.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->values[_i] = _e->Get(_i);
            }
        }
    }
}

inline flatbuffers::Offset<Int32Vector> Int32Vector::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateInt32Vector(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Int32Vector> CreateInt32Vector(flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const Int32VectorT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _values = _o->values.size() ? _fbb.CreateVector(_o->values) : 0;
    return tflite::CreateInt32Vector(_fbb, _values);
}

inline Uint16VectorT *Uint16Vector::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::Uint16VectorT> _o = std::unique_ptr<tflite::Uint16VectorT>(new Uint16VectorT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void Uint16Vector::UnPackTo(Uint16VectorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e = values();
        if (_e) {
            _o->values.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->values[_i] = _e->Get(_i);
            }
        }
    }
}

inline flatbuffers::Offset<Uint16Vector> Uint16Vector::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const Uint16VectorT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateUint16Vector(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Uint16Vector> CreateUint16Vector(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const Uint16VectorT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const Uint16VectorT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    _fbb.ForceVectorAlignment(_o->values.size(), sizeof(uint16_t), 4);
    auto _values = _o->values.size() ? _fbb.CreateVector(_o->values) : 0;
    return tflite::CreateUint16Vector(_fbb, _values);
}

inline Uint8VectorT *Uint8Vector::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::Uint8VectorT> _o = std::unique_ptr<tflite::Uint8VectorT>(new Uint8VectorT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void Uint8Vector::UnPackTo(Uint8VectorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e = values();
        if (_e) {
            _o->values.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->values[_i] = _e->Get(_i);
            }
        }
    }
}

inline flatbuffers::Offset<Uint8Vector> Uint8Vector::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateUint8Vector(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Uint8Vector> CreateUint8Vector(flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const Uint8VectorT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    _fbb.ForceVectorAlignment(_o->values.size(), sizeof(uint8_t), 4);
    auto _values = _o->values.size() ? _fbb.CreateVector(_o->values) : 0;
    return tflite::CreateUint8Vector(_fbb, _values);
}

inline DimensionMetadataT *DimensionMetadata::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::DimensionMetadataT> _o =
        std::unique_ptr<tflite::DimensionMetadataT>(new DimensionMetadataT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void DimensionMetadata::UnPackTo(DimensionMetadataT *_o,
                                        const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e    = format();
        _o->format = _e;
    }
    {
        auto _e        = dense_size();
        _o->dense_size = _e;
    }
    {
        auto _e                 = array_segments_type();
        _o->array_segments.type = _e;
    }
    {
        auto _e = array_segments();
        if (_e)
            _o->array_segments.value = tflite::SparseIndexVectorUnion::UnPack(_e, array_segments_type(), _resolver);
    }
    {
        auto _e                = array_indices_type();
        _o->array_indices.type = _e;
    }
    {
        auto _e = array_indices();
        if (_e)
            _o->array_indices.value = tflite::SparseIndexVectorUnion::UnPack(_e, array_indices_type(), _resolver);
    }
}

inline flatbuffers::Offset<DimensionMetadata> DimensionMetadata::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const DimensionMetadataT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateDimensionMetadata(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DimensionMetadata> CreateDimensionMetadata(
    flatbuffers::FlatBufferBuilder &_fbb, const DimensionMetadataT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const DimensionMetadataT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _format              = _o->format;
    auto _dense_size          = _o->dense_size;
    auto _array_segments_type = _o->array_segments.type;
    auto _array_segments      = _o->array_segments.Pack(_fbb);
    auto _array_indices_type  = _o->array_indices.type;
    auto _array_indices       = _o->array_indices.Pack(_fbb);
    return tflite::CreateDimensionMetadata(_fbb, _format, _dense_size, _array_segments_type, _array_segments,
                                           _array_indices_type, _array_indices);
}

inline SparsityParametersT *SparsityParameters::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SparsityParametersT> _o =
        std::unique_ptr<tflite::SparsityParametersT>(new SparsityParametersT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SparsityParameters::UnPackTo(SparsityParametersT *_o,
                                         const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e = traversal_order();
        if (_e) {
            _o->traversal_order.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->traversal_order[_i] = _e->Get(_i);
            }
        }
    }
    {
        auto _e = block_map();
        if (_e) {
            _o->block_map.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->block_map[_i] = _e->Get(_i);
            }
        }
    }
    {
        auto _e = dim_metadata();
        if (_e) {
            _o->dim_metadata.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->dim_metadata[_i] = std::unique_ptr<tflite::DimensionMetadataT>(_e->Get(_i)->UnPack(_resolver));
            }
        }
    }
}

inline flatbuffers::Offset<SparsityParameters> SparsityParameters::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const SparsityParametersT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSparsityParameters(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SparsityParameters> CreateSparsityParameters(
    flatbuffers::FlatBufferBuilder &_fbb, const SparsityParametersT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SparsityParametersT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _traversal_order = _o->traversal_order.size() ? _fbb.CreateVector(_o->traversal_order) : 0;
    auto _block_map       = _o->block_map.size() ? _fbb.CreateVector(_o->block_map) : 0;
    auto _dim_metadata =
        _o->dim_metadata.size()
            ? _fbb.CreateVector<flatbuffers::Offset<tflite::DimensionMetadata>>(
                  _o->dim_metadata.size(),
                  [](size_t i, _VectorArgs *__va) {
                      return CreateDimensionMetadata(*__va->__fbb, __va->__o->dim_metadata[i].get(), __va->__rehasher);
                  },
                  &_va)
            : 0;
    return tflite::CreateSparsityParameters(_fbb, _traversal_order, _block_map, _dim_metadata);
}

inline TensorT *Tensor::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::TensorT> _o = std::unique_ptr<tflite::TensorT>(new TensorT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void Tensor::UnPackTo(TensorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e = shape();
        if (_e) {
            _o->shape.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->shape[_i] = _e->Get(_i);
            }
        }
    }
    {
        auto _e  = type();
        _o->type = _e;
    }
    {
        auto _e    = buffer();
        _o->buffer = _e;
    }
    {
        auto _e = name();
        if (_e)
            _o->name = _e->str();
    }
    {
        auto _e = quantization();
        if (_e)
            _o->quantization = std::unique_ptr<tflite::QuantizationParametersT>(_e->UnPack(_resolver));
    }
    {
        auto _e         = is_variable();
        _o->is_variable = _e;
    }
    {
        auto _e = sparsity();
        if (_e)
            _o->sparsity = std::unique_ptr<tflite::SparsityParametersT>(_e->UnPack(_resolver));
    }
    {
        auto _e = shape_signature();
        if (_e) {
            _o->shape_signature.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->shape_signature[_i] = _e->Get(_i);
            }
        }
    }
}

inline flatbuffers::Offset<Tensor> Tensor::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateTensor(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Tensor> CreateTensor(flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const TensorT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _shape        = _o->shape.size() ? _fbb.CreateVector(_o->shape) : 0;
    auto _type         = _o->type;
    auto _buffer       = _o->buffer;
    auto _name         = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
    auto _quantization = _o->quantization ? CreateQuantizationParameters(_fbb, _o->quantization.get(), _rehasher) : 0;
    auto _is_variable  = _o->is_variable;
    auto _sparsity     = _o->sparsity ? CreateSparsityParameters(_fbb, _o->sparsity.get(), _rehasher) : 0;
    auto _shape_signature = _o->shape_signature.size() ? _fbb.CreateVector(_o->shape_signature) : 0;
    return tflite::CreateTensor(_fbb, _shape, _type, _buffer, _name, _quantization, _is_variable, _sparsity,
                                _shape_signature);
}

inline Conv2DOptionsT *Conv2DOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::Conv2DOptionsT> _o = std::unique_ptr<tflite::Conv2DOptionsT>(new Conv2DOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void Conv2DOptions::UnPackTo(Conv2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e     = padding();
        _o->padding = _e;
    }
    {
        auto _e      = stride_w();
        _o->stride_w = _e;
    }
    {
        auto _e      = stride_h();
        _o->stride_h = _e;
    }
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
    {
        auto _e               = dilation_w_factor();
        _o->dilation_w_factor = _e;
    }
    {
        auto _e               = dilation_h_factor();
        _o->dilation_h_factor = _e;
    }
}

inline flatbuffers::Offset<Conv2DOptions> Conv2DOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const Conv2DOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateConv2DOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const Conv2DOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const Conv2DOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _padding                   = _o->padding;
    auto _stride_w                  = _o->stride_w;
    auto _stride_h                  = _o->stride_h;
    auto _fused_activation_function = _o->fused_activation_function;
    auto _dilation_w_factor         = _o->dilation_w_factor;
    auto _dilation_h_factor         = _o->dilation_h_factor;
    return tflite::CreateConv2DOptions(_fbb, _padding, _stride_w, _stride_h, _fused_activation_function,
                                       _dilation_w_factor, _dilation_h_factor);
}

inline Pool2DOptionsT *Pool2DOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::Pool2DOptionsT> _o = std::unique_ptr<tflite::Pool2DOptionsT>(new Pool2DOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void Pool2DOptions::UnPackTo(Pool2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e     = padding();
        _o->padding = _e;
    }
    {
        auto _e      = stride_w();
        _o->stride_w = _e;
    }
    {
        auto _e      = stride_h();
        _o->stride_h = _e;
    }
    {
        auto _e          = filter_width();
        _o->filter_width = _e;
    }
    {
        auto _e           = filter_height();
        _o->filter_height = _e;
    }
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
}

inline flatbuffers::Offset<Pool2DOptions> Pool2DOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const Pool2DOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    return CreatePool2DOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const Pool2DOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const Pool2DOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _padding                   = _o->padding;
    auto _stride_w                  = _o->stride_w;
    auto _stride_h                  = _o->stride_h;
    auto _filter_width              = _o->filter_width;
    auto _filter_height             = _o->filter_height;
    auto _fused_activation_function = _o->fused_activation_function;
    return tflite::CreatePool2DOptions(_fbb, _padding, _stride_w, _stride_h, _filter_width, _filter_height,
                                       _fused_activation_function);
}

inline DepthwiseConv2DOptionsT *DepthwiseConv2DOptions::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::DepthwiseConv2DOptionsT> _o =
        std::unique_ptr<tflite::DepthwiseConv2DOptionsT>(new DepthwiseConv2DOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void DepthwiseConv2DOptions::UnPackTo(DepthwiseConv2DOptionsT *_o,
                                             const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e     = padding();
        _o->padding = _e;
    }
    {
        auto _e      = stride_w();
        _o->stride_w = _e;
    }
    {
        auto _e      = stride_h();
        _o->stride_h = _e;
    }
    {
        auto _e              = depth_multiplier();
        _o->depth_multiplier = _e;
    }
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
    {
        auto _e               = dilation_w_factor();
        _o->dilation_w_factor = _e;
    }
    {
        auto _e               = dilation_h_factor();
        _o->dilation_h_factor = _e;
    }
}

inline flatbuffers::Offset<DepthwiseConv2DOptions> DepthwiseConv2DOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateDepthwiseConv2DOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const DepthwiseConv2DOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _padding                   = _o->padding;
    auto _stride_w                  = _o->stride_w;
    auto _stride_h                  = _o->stride_h;
    auto _depth_multiplier          = _o->depth_multiplier;
    auto _fused_activation_function = _o->fused_activation_function;
    auto _dilation_w_factor         = _o->dilation_w_factor;
    auto _dilation_h_factor         = _o->dilation_h_factor;
    return tflite::CreateDepthwiseConv2DOptions(_fbb, _padding, _stride_w, _stride_h, _depth_multiplier,
                                                _fused_activation_function, _dilation_w_factor, _dilation_h_factor);
}

inline ConcatEmbeddingsOptionsT *ConcatEmbeddingsOptions::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ConcatEmbeddingsOptionsT> _o =
        std::unique_ptr<tflite::ConcatEmbeddingsOptionsT>(new ConcatEmbeddingsOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void ConcatEmbeddingsOptions::UnPackTo(ConcatEmbeddingsOptionsT *_o,
                                              const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e          = num_channels();
        _o->num_channels = _e;
    }
    {
        auto _e = num_columns_per_channel();
        if (_e) {
            _o->num_columns_per_channel.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->num_columns_per_channel[_i] = _e->Get(_i);
            }
        }
    }
    {
        auto _e = embedding_dim_per_channel();
        if (_e) {
            _o->embedding_dim_per_channel.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->embedding_dim_per_channel[_i] = _e->Get(_i);
            }
        }
    }
}

inline flatbuffers::Offset<ConcatEmbeddingsOptions> ConcatEmbeddingsOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateConcatEmbeddingsOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ConcatEmbeddingsOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _num_channels = _o->num_channels;
    auto _num_columns_per_channel =
        _o->num_columns_per_channel.size() ? _fbb.CreateVector(_o->num_columns_per_channel) : 0;
    auto _embedding_dim_per_channel =
        _o->embedding_dim_per_channel.size() ? _fbb.CreateVector(_o->embedding_dim_per_channel) : 0;
    return tflite::CreateConcatEmbeddingsOptions(_fbb, _num_channels, _num_columns_per_channel,
                                                 _embedding_dim_per_channel);
}

inline LSHProjectionOptionsT *LSHProjectionOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::LSHProjectionOptionsT> _o =
        std::unique_ptr<tflite::LSHProjectionOptionsT>(new LSHProjectionOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void LSHProjectionOptions::UnPackTo(LSHProjectionOptionsT *_o,
                                           const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e  = type();
        _o->type = _e;
    }
}

inline flatbuffers::Offset<LSHProjectionOptions> LSHProjectionOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateLSHProjectionOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LSHProjectionOptions> CreateLSHProjectionOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const LSHProjectionOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _type = _o->type;
    return tflite::CreateLSHProjectionOptions(_fbb, _type);
}

inline SVDFOptionsT *SVDFOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SVDFOptionsT> _o = std::unique_ptr<tflite::SVDFOptionsT>(new SVDFOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SVDFOptions::UnPackTo(SVDFOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e  = rank();
        _o->rank = _e;
    }
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
    {
        auto _e                        = asymmetric_quantize_inputs();
        _o->asymmetric_quantize_inputs = _e;
    }
}

inline flatbuffers::Offset<SVDFOptions> SVDFOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSVDFOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SVDFOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _rank                       = _o->rank;
    auto _fused_activation_function  = _o->fused_activation_function;
    auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
    return tflite::CreateSVDFOptions(_fbb, _rank, _fused_activation_function, _asymmetric_quantize_inputs);
}

inline RNNOptionsT *RNNOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::RNNOptionsT> _o = std::unique_ptr<tflite::RNNOptionsT>(new RNNOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void RNNOptions::UnPackTo(RNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
    {
        auto _e                        = asymmetric_quantize_inputs();
        _o->asymmetric_quantize_inputs = _e;
    }
}

inline flatbuffers::Offset<RNNOptions> RNNOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateRNNOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RNNOptions> CreateRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const RNNOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _fused_activation_function  = _o->fused_activation_function;
    auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
    return tflite::CreateRNNOptions(_fbb, _fused_activation_function, _asymmetric_quantize_inputs);
}

inline SequenceRNNOptionsT *SequenceRNNOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SequenceRNNOptionsT> _o =
        std::unique_ptr<tflite::SequenceRNNOptionsT>(new SequenceRNNOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SequenceRNNOptions::UnPackTo(SequenceRNNOptionsT *_o,
                                         const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e        = time_major();
        _o->time_major = _e;
    }
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
    {
        auto _e                        = asymmetric_quantize_inputs();
        _o->asymmetric_quantize_inputs = _e;
    }
}

inline flatbuffers::Offset<SequenceRNNOptions> SequenceRNNOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSequenceRNNOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SequenceRNNOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _time_major                 = _o->time_major;
    auto _fused_activation_function  = _o->fused_activation_function;
    auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
    return tflite::CreateSequenceRNNOptions(_fbb, _time_major, _fused_activation_function, _asymmetric_quantize_inputs);
}

inline BidirectionalSequenceRNNOptionsT *BidirectionalSequenceRNNOptions::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::BidirectionalSequenceRNNOptionsT> _o =
        std::unique_ptr<tflite::BidirectionalSequenceRNNOptionsT>(new BidirectionalSequenceRNNOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void BidirectionalSequenceRNNOptions::UnPackTo(BidirectionalSequenceRNNOptionsT *_o,
                                                      const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e        = time_major();
        _o->time_major = _e;
    }
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
    {
        auto _e           = merge_outputs();
        _o->merge_outputs = _e;
    }
    {
        auto _e                        = asymmetric_quantize_inputs();
        _o->asymmetric_quantize_inputs = _e;
    }
}

inline flatbuffers::Offset<BidirectionalSequenceRNNOptions> BidirectionalSequenceRNNOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateBidirectionalSequenceRNNOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const BidirectionalSequenceRNNOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _time_major                 = _o->time_major;
    auto _fused_activation_function  = _o->fused_activation_function;
    auto _merge_outputs              = _o->merge_outputs;
    auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
    return tflite::CreateBidirectionalSequenceRNNOptions(_fbb, _time_major, _fused_activation_function, _merge_outputs,
                                                         _asymmetric_quantize_inputs);
}

inline FullyConnectedOptionsT *FullyConnectedOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::FullyConnectedOptionsT> _o =
        std::unique_ptr<tflite::FullyConnectedOptionsT>(new FullyConnectedOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void FullyConnectedOptions::UnPackTo(FullyConnectedOptionsT *_o,
                                            const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
    {
        auto _e            = weights_format();
        _o->weights_format = _e;
    }
    {
        auto _e           = keep_num_dims();
        _o->keep_num_dims = _e;
    }
    {
        auto _e                        = asymmetric_quantize_inputs();
        _o->asymmetric_quantize_inputs = _e;
    }
}

inline flatbuffers::Offset<FullyConnectedOptions> FullyConnectedOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateFullyConnectedOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const FullyConnectedOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _fused_activation_function  = _o->fused_activation_function;
    auto _weights_format             = _o->weights_format;
    auto _keep_num_dims              = _o->keep_num_dims;
    auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
    return tflite::CreateFullyConnectedOptions(_fbb, _fused_activation_function, _weights_format, _keep_num_dims,
                                               _asymmetric_quantize_inputs);
}

inline SoftmaxOptionsT *SoftmaxOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SoftmaxOptionsT> _o = std::unique_ptr<tflite::SoftmaxOptionsT>(new SoftmaxOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SoftmaxOptions::UnPackTo(SoftmaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e  = beta();
        _o->beta = _e;
    }
}

inline flatbuffers::Offset<SoftmaxOptions> SoftmaxOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                const SoftmaxOptionsT *_o,
                                                                const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSoftmaxOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SoftmaxOptions> CreateSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                const SoftmaxOptionsT *_o,
                                                                const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SoftmaxOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _beta = _o->beta;
    return tflite::CreateSoftmaxOptions(_fbb, _beta);
}

inline ConcatenationOptionsT *ConcatenationOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ConcatenationOptionsT> _o =
        std::unique_ptr<tflite::ConcatenationOptionsT>(new ConcatenationOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void ConcatenationOptions::UnPackTo(ConcatenationOptionsT *_o,
                                           const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e  = axis();
        _o->axis = _e;
    }
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
}

inline flatbuffers::Offset<ConcatenationOptions> ConcatenationOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateConcatenationOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ConcatenationOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _axis                      = _o->axis;
    auto _fused_activation_function = _o->fused_activation_function;
    return tflite::CreateConcatenationOptions(_fbb, _axis, _fused_activation_function);
}

inline AddOptionsT *AddOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::AddOptionsT> _o = std::unique_ptr<tflite::AddOptionsT>(new AddOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void AddOptions::UnPackTo(AddOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
    {
        auto _e             = pot_scale_int16();
        _o->pot_scale_int16 = _e;
    }
}

inline flatbuffers::Offset<AddOptions> AddOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateAddOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AddOptions> CreateAddOptions(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const AddOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _fused_activation_function = _o->fused_activation_function;
    auto _pot_scale_int16           = _o->pot_scale_int16;
    return tflite::CreateAddOptions(_fbb, _fused_activation_function, _pot_scale_int16);
}

inline MulOptionsT *MulOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::MulOptionsT> _o = std::unique_ptr<tflite::MulOptionsT>(new MulOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void MulOptions::UnPackTo(MulOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
}

inline flatbuffers::Offset<MulOptions> MulOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateMulOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MulOptions> CreateMulOptions(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const MulOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _fused_activation_function = _o->fused_activation_function;
    return tflite::CreateMulOptions(_fbb, _fused_activation_function);
}

inline L2NormOptionsT *L2NormOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::L2NormOptionsT> _o = std::unique_ptr<tflite::L2NormOptionsT>(new L2NormOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void L2NormOptions::UnPackTo(L2NormOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
}

inline flatbuffers::Offset<L2NormOptions> L2NormOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const L2NormOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateL2NormOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const L2NormOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const L2NormOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _fused_activation_function = _o->fused_activation_function;
    return tflite::CreateL2NormOptions(_fbb, _fused_activation_function);
}

inline LocalResponseNormalizationOptionsT *LocalResponseNormalizationOptions::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::LocalResponseNormalizationOptionsT> _o =
        std::unique_ptr<tflite::LocalResponseNormalizationOptionsT>(new LocalResponseNormalizationOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void LocalResponseNormalizationOptions::UnPackTo(LocalResponseNormalizationOptionsT *_o,
                                                        const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e    = radius();
        _o->radius = _e;
    }
    {
        auto _e  = bias();
        _o->bias = _e;
    }
    {
        auto _e   = alpha();
        _o->alpha = _e;
    }
    {
        auto _e  = beta();
        _o->beta = _e;
    }
}

inline flatbuffers::Offset<LocalResponseNormalizationOptions> LocalResponseNormalizationOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateLocalResponseNormalizationOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const LocalResponseNormalizationOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _radius = _o->radius;
    auto _bias   = _o->bias;
    auto _alpha  = _o->alpha;
    auto _beta   = _o->beta;
    return tflite::CreateLocalResponseNormalizationOptions(_fbb, _radius, _bias, _alpha, _beta);
}

inline LSTMOptionsT *LSTMOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::LSTMOptionsT> _o = std::unique_ptr<tflite::LSTMOptionsT>(new LSTMOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void LSTMOptions::UnPackTo(LSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
    {
        auto _e       = cell_clip();
        _o->cell_clip = _e;
    }
    {
        auto _e       = proj_clip();
        _o->proj_clip = _e;
    }
    {
        auto _e         = kernel_type();
        _o->kernel_type = _e;
    }
    {
        auto _e                        = asymmetric_quantize_inputs();
        _o->asymmetric_quantize_inputs = _e;
    }
}

inline flatbuffers::Offset<LSTMOptions> LSTMOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateLSTMOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const LSTMOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _fused_activation_function  = _o->fused_activation_function;
    auto _cell_clip                  = _o->cell_clip;
    auto _proj_clip                  = _o->proj_clip;
    auto _kernel_type                = _o->kernel_type;
    auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
    return tflite::CreateLSTMOptions(_fbb, _fused_activation_function, _cell_clip, _proj_clip, _kernel_type,
                                     _asymmetric_quantize_inputs);
}

inline UnidirectionalSequenceLSTMOptionsT *UnidirectionalSequenceLSTMOptions::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::UnidirectionalSequenceLSTMOptionsT> _o =
        std::unique_ptr<tflite::UnidirectionalSequenceLSTMOptionsT>(new UnidirectionalSequenceLSTMOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void UnidirectionalSequenceLSTMOptions::UnPackTo(UnidirectionalSequenceLSTMOptionsT *_o,
                                                        const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
    {
        auto _e       = cell_clip();
        _o->cell_clip = _e;
    }
    {
        auto _e       = proj_clip();
        _o->proj_clip = _e;
    }
    {
        auto _e        = time_major();
        _o->time_major = _e;
    }
    {
        auto _e                        = asymmetric_quantize_inputs();
        _o->asymmetric_quantize_inputs = _e;
    }
}

inline flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> UnidirectionalSequenceLSTMOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateUnidirectionalSequenceLSTMOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> CreateUnidirectionalSequenceLSTMOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const UnidirectionalSequenceLSTMOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _fused_activation_function  = _o->fused_activation_function;
    auto _cell_clip                  = _o->cell_clip;
    auto _proj_clip                  = _o->proj_clip;
    auto _time_major                 = _o->time_major;
    auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
    return tflite::CreateUnidirectionalSequenceLSTMOptions(_fbb, _fused_activation_function, _cell_clip, _proj_clip,
                                                           _time_major, _asymmetric_quantize_inputs);
}

inline BidirectionalSequenceLSTMOptionsT *BidirectionalSequenceLSTMOptions::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::BidirectionalSequenceLSTMOptionsT> _o =
        std::unique_ptr<tflite::BidirectionalSequenceLSTMOptionsT>(new BidirectionalSequenceLSTMOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void BidirectionalSequenceLSTMOptions::UnPackTo(BidirectionalSequenceLSTMOptionsT *_o,
                                                       const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
    {
        auto _e       = cell_clip();
        _o->cell_clip = _e;
    }
    {
        auto _e       = proj_clip();
        _o->proj_clip = _e;
    }
    {
        auto _e           = merge_outputs();
        _o->merge_outputs = _e;
    }
    {
        auto _e        = time_major();
        _o->time_major = _e;
    }
    {
        auto _e                        = asymmetric_quantize_inputs();
        _o->asymmetric_quantize_inputs = _e;
    }
}

inline flatbuffers::Offset<BidirectionalSequenceLSTMOptions> BidirectionalSequenceLSTMOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateBidirectionalSequenceLSTMOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BidirectionalSequenceLSTMOptions> CreateBidirectionalSequenceLSTMOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const BidirectionalSequenceLSTMOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _fused_activation_function  = _o->fused_activation_function;
    auto _cell_clip                  = _o->cell_clip;
    auto _proj_clip                  = _o->proj_clip;
    auto _merge_outputs              = _o->merge_outputs;
    auto _time_major                 = _o->time_major;
    auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;
    return tflite::CreateBidirectionalSequenceLSTMOptions(_fbb, _fused_activation_function, _cell_clip, _proj_clip,
                                                          _merge_outputs, _time_major, _asymmetric_quantize_inputs);
}

inline ResizeBilinearOptionsT *ResizeBilinearOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ResizeBilinearOptionsT> _o =
        std::unique_ptr<tflite::ResizeBilinearOptionsT>(new ResizeBilinearOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void ResizeBilinearOptions::UnPackTo(ResizeBilinearOptionsT *_o,
                                            const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e           = align_corners();
        _o->align_corners = _e;
    }
    {
        auto _e                = half_pixel_centers();
        _o->half_pixel_centers = _e;
    }
}

inline flatbuffers::Offset<ResizeBilinearOptions> ResizeBilinearOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateResizeBilinearOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ResizeBilinearOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _align_corners      = _o->align_corners;
    auto _half_pixel_centers = _o->half_pixel_centers;
    return tflite::CreateResizeBilinearOptions(_fbb, _align_corners, _half_pixel_centers);
}

inline ResizeNearestNeighborOptionsT *ResizeNearestNeighborOptions::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ResizeNearestNeighborOptionsT> _o =
        std::unique_ptr<tflite::ResizeNearestNeighborOptionsT>(new ResizeNearestNeighborOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void ResizeNearestNeighborOptions::UnPackTo(ResizeNearestNeighborOptionsT *_o,
                                                   const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e           = align_corners();
        _o->align_corners = _e;
    }
    {
        auto _e                = half_pixel_centers();
        _o->half_pixel_centers = _e;
    }
}

inline flatbuffers::Offset<ResizeNearestNeighborOptions> ResizeNearestNeighborOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateResizeNearestNeighborOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ResizeNearestNeighborOptions> CreateResizeNearestNeighborOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ResizeNearestNeighborOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _align_corners      = _o->align_corners;
    auto _half_pixel_centers = _o->half_pixel_centers;
    return tflite::CreateResizeNearestNeighborOptions(_fbb, _align_corners, _half_pixel_centers);
}

inline CallOptionsT *CallOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::CallOptionsT> _o = std::unique_ptr<tflite::CallOptionsT>(new CallOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void CallOptions::UnPackTo(CallOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e      = subgraph();
        _o->subgraph = _e;
    }
}

inline flatbuffers::Offset<CallOptions> CallOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateCallOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CallOptions> CreateCallOptions(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const CallOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _subgraph = _o->subgraph;
    return tflite::CreateCallOptions(_fbb, _subgraph);
}

inline PadOptionsT *PadOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::PadOptionsT> _o = std::unique_ptr<tflite::PadOptionsT>(new PadOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void PadOptions::UnPackTo(PadOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<PadOptions> PadOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    return CreatePadOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PadOptions> CreatePadOptions(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const PadOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreatePadOptions(_fbb);
}

inline PadV2OptionsT *PadV2Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::PadV2OptionsT> _o = std::unique_ptr<tflite::PadV2OptionsT>(new PadV2OptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void PadV2Options::UnPackTo(PadV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<PadV2Options> PadV2Options::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const PadV2OptionsT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    return CreatePadV2Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PadV2Options> CreatePadV2Options(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const PadV2OptionsT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const PadV2OptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreatePadV2Options(_fbb);
}

inline ReshapeOptionsT *ReshapeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ReshapeOptionsT> _o = std::unique_ptr<tflite::ReshapeOptionsT>(new ReshapeOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void ReshapeOptions::UnPackTo(ReshapeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e = new_shape();
        if (_e) {
            _o->new_shape.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->new_shape[_i] = _e->Get(_i);
            }
        }
    }
}

inline flatbuffers::Offset<ReshapeOptions> ReshapeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                const ReshapeOptionsT *_o,
                                                                const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateReshapeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReshapeOptions> CreateReshapeOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                const ReshapeOptionsT *_o,
                                                                const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ReshapeOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _new_shape = _o->new_shape.size() ? _fbb.CreateVector(_o->new_shape) : 0;
    return tflite::CreateReshapeOptions(_fbb, _new_shape);
}

inline SpaceToBatchNDOptionsT *SpaceToBatchNDOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SpaceToBatchNDOptionsT> _o =
        std::unique_ptr<tflite::SpaceToBatchNDOptionsT>(new SpaceToBatchNDOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SpaceToBatchNDOptions::UnPackTo(SpaceToBatchNDOptionsT *_o,
                                            const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<SpaceToBatchNDOptions> SpaceToBatchNDOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSpaceToBatchNDOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SpaceToBatchNDOptions> CreateSpaceToBatchNDOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SpaceToBatchNDOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateSpaceToBatchNDOptions(_fbb);
}

inline BatchToSpaceNDOptionsT *BatchToSpaceNDOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::BatchToSpaceNDOptionsT> _o =
        std::unique_ptr<tflite::BatchToSpaceNDOptionsT>(new BatchToSpaceNDOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void BatchToSpaceNDOptions::UnPackTo(BatchToSpaceNDOptionsT *_o,
                                            const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<BatchToSpaceNDOptions> BatchToSpaceNDOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateBatchToSpaceNDOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatchToSpaceNDOptions> CreateBatchToSpaceNDOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const BatchToSpaceNDOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateBatchToSpaceNDOptions(_fbb);
}

inline SkipGramOptionsT *SkipGramOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SkipGramOptionsT> _o = std::unique_ptr<tflite::SkipGramOptionsT>(new SkipGramOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SkipGramOptions::UnPackTo(SkipGramOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e        = ngram_size();
        _o->ngram_size = _e;
    }
    {
        auto _e           = max_skip_size();
        _o->max_skip_size = _e;
    }
    {
        auto _e                = include_all_ngrams();
        _o->include_all_ngrams = _e;
    }
}

inline flatbuffers::Offset<SkipGramOptions> SkipGramOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                  const SkipGramOptionsT *_o,
                                                                  const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSkipGramOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                  const SkipGramOptionsT *_o,
                                                                  const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SkipGramOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _ngram_size         = _o->ngram_size;
    auto _max_skip_size      = _o->max_skip_size;
    auto _include_all_ngrams = _o->include_all_ngrams;
    return tflite::CreateSkipGramOptions(_fbb, _ngram_size, _max_skip_size, _include_all_ngrams);
}

inline SpaceToDepthOptionsT *SpaceToDepthOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SpaceToDepthOptionsT> _o =
        std::unique_ptr<tflite::SpaceToDepthOptionsT>(new SpaceToDepthOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SpaceToDepthOptions::UnPackTo(SpaceToDepthOptionsT *_o,
                                          const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e        = block_size();
        _o->block_size = _e;
    }
}

inline flatbuffers::Offset<SpaceToDepthOptions> SpaceToDepthOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSpaceToDepthOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SpaceToDepthOptions> CreateSpaceToDepthOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SpaceToDepthOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _block_size = _o->block_size;
    return tflite::CreateSpaceToDepthOptions(_fbb, _block_size);
}

inline DepthToSpaceOptionsT *DepthToSpaceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::DepthToSpaceOptionsT> _o =
        std::unique_ptr<tflite::DepthToSpaceOptionsT>(new DepthToSpaceOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void DepthToSpaceOptions::UnPackTo(DepthToSpaceOptionsT *_o,
                                          const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e        = block_size();
        _o->block_size = _e;
    }
}

inline flatbuffers::Offset<DepthToSpaceOptions> DepthToSpaceOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateDepthToSpaceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DepthToSpaceOptions> CreateDepthToSpaceOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const DepthToSpaceOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _block_size = _o->block_size;
    return tflite::CreateDepthToSpaceOptions(_fbb, _block_size);
}

inline SubOptionsT *SubOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SubOptionsT> _o = std::unique_ptr<tflite::SubOptionsT>(new SubOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SubOptions::UnPackTo(SubOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
    {
        auto _e             = pot_scale_int16();
        _o->pot_scale_int16 = _e;
    }
}

inline flatbuffers::Offset<SubOptions> SubOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSubOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SubOptions> CreateSubOptions(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SubOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _fused_activation_function = _o->fused_activation_function;
    auto _pot_scale_int16           = _o->pot_scale_int16;
    return tflite::CreateSubOptions(_fbb, _fused_activation_function, _pot_scale_int16);
}

inline DivOptionsT *DivOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::DivOptionsT> _o = std::unique_ptr<tflite::DivOptionsT>(new DivOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void DivOptions::UnPackTo(DivOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
}

inline flatbuffers::Offset<DivOptions> DivOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateDivOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DivOptions> CreateDivOptions(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const DivOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _fused_activation_function = _o->fused_activation_function;
    return tflite::CreateDivOptions(_fbb, _fused_activation_function);
}

inline TopKV2OptionsT *TopKV2Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::TopKV2OptionsT> _o = std::unique_ptr<tflite::TopKV2OptionsT>(new TopKV2OptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void TopKV2Options::UnPackTo(TopKV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<TopKV2Options> TopKV2Options::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const TopKV2OptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateTopKV2Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const TopKV2OptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const TopKV2OptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateTopKV2Options(_fbb);
}

inline EmbeddingLookupSparseOptionsT *EmbeddingLookupSparseOptions::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::EmbeddingLookupSparseOptionsT> _o =
        std::unique_ptr<tflite::EmbeddingLookupSparseOptionsT>(new EmbeddingLookupSparseOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void EmbeddingLookupSparseOptions::UnPackTo(EmbeddingLookupSparseOptionsT *_o,
                                                   const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e      = combiner();
        _o->combiner = _e;
    }
}

inline flatbuffers::Offset<EmbeddingLookupSparseOptions> EmbeddingLookupSparseOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateEmbeddingLookupSparseOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EmbeddingLookupSparseOptions> CreateEmbeddingLookupSparseOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const EmbeddingLookupSparseOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _combiner = _o->combiner;
    return tflite::CreateEmbeddingLookupSparseOptions(_fbb, _combiner);
}

inline GatherOptionsT *GatherOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::GatherOptionsT> _o = std::unique_ptr<tflite::GatherOptionsT>(new GatherOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void GatherOptions::UnPackTo(GatherOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e  = axis();
        _o->axis = _e;
    }
}

inline flatbuffers::Offset<GatherOptions> GatherOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const GatherOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateGatherOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GatherOptions> CreateGatherOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const GatherOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const GatherOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _axis = _o->axis;
    return tflite::CreateGatherOptions(_fbb, _axis);
}

inline TransposeOptionsT *TransposeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::TransposeOptionsT> _o = std::unique_ptr<tflite::TransposeOptionsT>(new TransposeOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void TransposeOptions::UnPackTo(TransposeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<TransposeOptions> TransposeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const TransposeOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateTransposeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TransposeOptions> CreateTransposeOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const TransposeOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const TransposeOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateTransposeOptions(_fbb);
}

inline ExpOptionsT *ExpOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ExpOptionsT> _o = std::unique_ptr<tflite::ExpOptionsT>(new ExpOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void ExpOptions::UnPackTo(ExpOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<ExpOptions> ExpOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateExpOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExpOptions> CreateExpOptions(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ExpOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateExpOptions(_fbb);
}

inline CosOptionsT *CosOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::CosOptionsT> _o = std::unique_ptr<tflite::CosOptionsT>(new CosOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void CosOptions::UnPackTo(CosOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<CosOptions> CosOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateCosOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CosOptions> CreateCosOptions(flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const CosOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateCosOptions(_fbb);
}

inline ReducerOptionsT *ReducerOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ReducerOptionsT> _o = std::unique_ptr<tflite::ReducerOptionsT>(new ReducerOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void ReducerOptions::UnPackTo(ReducerOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e       = keep_dims();
        _o->keep_dims = _e;
    }
}

inline flatbuffers::Offset<ReducerOptions> ReducerOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                const ReducerOptionsT *_o,
                                                                const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateReducerOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReducerOptions> CreateReducerOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                const ReducerOptionsT *_o,
                                                                const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ReducerOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _keep_dims = _o->keep_dims;
    return tflite::CreateReducerOptions(_fbb, _keep_dims);
}

inline SqueezeOptionsT *SqueezeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SqueezeOptionsT> _o = std::unique_ptr<tflite::SqueezeOptionsT>(new SqueezeOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SqueezeOptions::UnPackTo(SqueezeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e = squeeze_dims();
        if (_e) {
            _o->squeeze_dims.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->squeeze_dims[_i] = _e->Get(_i);
            }
        }
    }
}

inline flatbuffers::Offset<SqueezeOptions> SqueezeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                const SqueezeOptionsT *_o,
                                                                const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSqueezeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                const SqueezeOptionsT *_o,
                                                                const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SqueezeOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _squeeze_dims = _o->squeeze_dims.size() ? _fbb.CreateVector(_o->squeeze_dims) : 0;
    return tflite::CreateSqueezeOptions(_fbb, _squeeze_dims);
}

inline SplitOptionsT *SplitOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SplitOptionsT> _o = std::unique_ptr<tflite::SplitOptionsT>(new SplitOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SplitOptions::UnPackTo(SplitOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e        = num_splits();
        _o->num_splits = _e;
    }
}

inline flatbuffers::Offset<SplitOptions> SplitOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const SplitOptionsT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSplitOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SplitOptions> CreateSplitOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const SplitOptionsT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SplitOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _num_splits = _o->num_splits;
    return tflite::CreateSplitOptions(_fbb, _num_splits);
}

inline SplitVOptionsT *SplitVOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SplitVOptionsT> _o = std::unique_ptr<tflite::SplitVOptionsT>(new SplitVOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SplitVOptions::UnPackTo(SplitVOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e        = num_splits();
        _o->num_splits = _e;
    }
}

inline flatbuffers::Offset<SplitVOptions> SplitVOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const SplitVOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSplitVOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SplitVOptions> CreateSplitVOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const SplitVOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SplitVOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _num_splits = _o->num_splits;
    return tflite::CreateSplitVOptions(_fbb, _num_splits);
}

inline StridedSliceOptionsT *StridedSliceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::StridedSliceOptionsT> _o =
        std::unique_ptr<tflite::StridedSliceOptionsT>(new StridedSliceOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void StridedSliceOptions::UnPackTo(StridedSliceOptionsT *_o,
                                          const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e        = begin_mask();
        _o->begin_mask = _e;
    }
    {
        auto _e      = end_mask();
        _o->end_mask = _e;
    }
    {
        auto _e           = ellipsis_mask();
        _o->ellipsis_mask = _e;
    }
    {
        auto _e           = new_axis_mask();
        _o->new_axis_mask = _e;
    }
    {
        auto _e              = shrink_axis_mask();
        _o->shrink_axis_mask = _e;
    }
}

inline flatbuffers::Offset<StridedSliceOptions> StridedSliceOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateStridedSliceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const StridedSliceOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _begin_mask       = _o->begin_mask;
    auto _end_mask         = _o->end_mask;
    auto _ellipsis_mask    = _o->ellipsis_mask;
    auto _new_axis_mask    = _o->new_axis_mask;
    auto _shrink_axis_mask = _o->shrink_axis_mask;
    return tflite::CreateStridedSliceOptions(_fbb, _begin_mask, _end_mask, _ellipsis_mask, _new_axis_mask,
                                             _shrink_axis_mask);
}

inline LogSoftmaxOptionsT *LogSoftmaxOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::LogSoftmaxOptionsT> _o =
        std::unique_ptr<tflite::LogSoftmaxOptionsT>(new LogSoftmaxOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void LogSoftmaxOptions::UnPackTo(LogSoftmaxOptionsT *_o,
                                        const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<LogSoftmaxOptions> LogSoftmaxOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateLogSoftmaxOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogSoftmaxOptions> CreateLogSoftmaxOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const LogSoftmaxOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateLogSoftmaxOptions(_fbb);
}

inline CastOptionsT *CastOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::CastOptionsT> _o = std::unique_ptr<tflite::CastOptionsT>(new CastOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void CastOptions::UnPackTo(CastOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e          = in_data_type();
        _o->in_data_type = _e;
    }
    {
        auto _e           = out_data_type();
        _o->out_data_type = _e;
    }
}

inline flatbuffers::Offset<CastOptions> CastOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateCastOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CastOptions> CreateCastOptions(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const CastOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _in_data_type  = _o->in_data_type;
    auto _out_data_type = _o->out_data_type;
    return tflite::CreateCastOptions(_fbb, _in_data_type, _out_data_type);
}

inline DequantizeOptionsT *DequantizeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::DequantizeOptionsT> _o =
        std::unique_ptr<tflite::DequantizeOptionsT>(new DequantizeOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void DequantizeOptions::UnPackTo(DequantizeOptionsT *_o,
                                        const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<DequantizeOptions> DequantizeOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateDequantizeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const DequantizeOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateDequantizeOptions(_fbb);
}

inline MaximumMinimumOptionsT *MaximumMinimumOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::MaximumMinimumOptionsT> _o =
        std::unique_ptr<tflite::MaximumMinimumOptionsT>(new MaximumMinimumOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void MaximumMinimumOptions::UnPackTo(MaximumMinimumOptionsT *_o,
                                            const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<MaximumMinimumOptions> MaximumMinimumOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateMaximumMinimumOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const MaximumMinimumOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateMaximumMinimumOptions(_fbb);
}

inline TileOptionsT *TileOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::TileOptionsT> _o = std::unique_ptr<tflite::TileOptionsT>(new TileOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void TileOptions::UnPackTo(TileOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<TileOptions> TileOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateTileOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TileOptions> CreateTileOptions(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const TileOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateTileOptions(_fbb);
}

inline ArgMaxOptionsT *ArgMaxOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ArgMaxOptionsT> _o = std::unique_ptr<tflite::ArgMaxOptionsT>(new ArgMaxOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void ArgMaxOptions::UnPackTo(ArgMaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e         = output_type();
        _o->output_type = _e;
    }
}

inline flatbuffers::Offset<ArgMaxOptions> ArgMaxOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const ArgMaxOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateArgMaxOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ArgMaxOptions> CreateArgMaxOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const ArgMaxOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ArgMaxOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _output_type = _o->output_type;
    return tflite::CreateArgMaxOptions(_fbb, _output_type);
}

inline ArgMinOptionsT *ArgMinOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ArgMinOptionsT> _o = std::unique_ptr<tflite::ArgMinOptionsT>(new ArgMinOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void ArgMinOptions::UnPackTo(ArgMinOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e         = output_type();
        _o->output_type = _e;
    }
}

inline flatbuffers::Offset<ArgMinOptions> ArgMinOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const ArgMinOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateArgMinOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ArgMinOptions> CreateArgMinOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const ArgMinOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ArgMinOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _output_type = _o->output_type;
    return tflite::CreateArgMinOptions(_fbb, _output_type);
}

inline GreaterOptionsT *GreaterOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::GreaterOptionsT> _o = std::unique_ptr<tflite::GreaterOptionsT>(new GreaterOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void GreaterOptions::UnPackTo(GreaterOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<GreaterOptions> GreaterOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                const GreaterOptionsT *_o,
                                                                const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateGreaterOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GreaterOptions> CreateGreaterOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                const GreaterOptionsT *_o,
                                                                const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const GreaterOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateGreaterOptions(_fbb);
}

inline GreaterEqualOptionsT *GreaterEqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::GreaterEqualOptionsT> _o =
        std::unique_ptr<tflite::GreaterEqualOptionsT>(new GreaterEqualOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void GreaterEqualOptions::UnPackTo(GreaterEqualOptionsT *_o,
                                          const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<GreaterEqualOptions> GreaterEqualOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateGreaterEqualOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GreaterEqualOptions> CreateGreaterEqualOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const GreaterEqualOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateGreaterEqualOptions(_fbb);
}

inline LessOptionsT *LessOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::LessOptionsT> _o = std::unique_ptr<tflite::LessOptionsT>(new LessOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void LessOptions::UnPackTo(LessOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<LessOptions> LessOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateLessOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LessOptions> CreateLessOptions(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const LessOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateLessOptions(_fbb);
}

inline LessEqualOptionsT *LessEqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::LessEqualOptionsT> _o = std::unique_ptr<tflite::LessEqualOptionsT>(new LessEqualOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void LessEqualOptions::UnPackTo(LessEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<LessEqualOptions> LessEqualOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const LessEqualOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateLessEqualOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LessEqualOptions> CreateLessEqualOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const LessEqualOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const LessEqualOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateLessEqualOptions(_fbb);
}

inline NegOptionsT *NegOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::NegOptionsT> _o = std::unique_ptr<tflite::NegOptionsT>(new NegOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void NegOptions::UnPackTo(NegOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<NegOptions> NegOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateNegOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NegOptions> CreateNegOptions(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const NegOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateNegOptions(_fbb);
}

inline SelectOptionsT *SelectOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SelectOptionsT> _o = std::unique_ptr<tflite::SelectOptionsT>(new SelectOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SelectOptions::UnPackTo(SelectOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<SelectOptions> SelectOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const SelectOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSelectOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SelectOptions> CreateSelectOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const SelectOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SelectOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateSelectOptions(_fbb);
}

inline SliceOptionsT *SliceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SliceOptionsT> _o = std::unique_ptr<tflite::SliceOptionsT>(new SliceOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SliceOptions::UnPackTo(SliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<SliceOptions> SliceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const SliceOptionsT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSliceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SliceOptions> CreateSliceOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const SliceOptionsT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SliceOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateSliceOptions(_fbb);
}

inline TransposeConvOptionsT *TransposeConvOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::TransposeConvOptionsT> _o =
        std::unique_ptr<tflite::TransposeConvOptionsT>(new TransposeConvOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void TransposeConvOptions::UnPackTo(TransposeConvOptionsT *_o,
                                           const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e     = padding();
        _o->padding = _e;
    }
    {
        auto _e      = stride_w();
        _o->stride_w = _e;
    }
    {
        auto _e      = stride_h();
        _o->stride_h = _e;
    }
}

inline flatbuffers::Offset<TransposeConvOptions> TransposeConvOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateTransposeConvOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const TransposeConvOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _padding  = _o->padding;
    auto _stride_w = _o->stride_w;
    auto _stride_h = _o->stride_h;
    return tflite::CreateTransposeConvOptions(_fbb, _padding, _stride_w, _stride_h);
}

inline ExpandDimsOptionsT *ExpandDimsOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ExpandDimsOptionsT> _o =
        std::unique_ptr<tflite::ExpandDimsOptionsT>(new ExpandDimsOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void ExpandDimsOptions::UnPackTo(ExpandDimsOptionsT *_o,
                                        const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<ExpandDimsOptions> ExpandDimsOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateExpandDimsOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExpandDimsOptions> CreateExpandDimsOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ExpandDimsOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateExpandDimsOptions(_fbb);
}

inline SparseToDenseOptionsT *SparseToDenseOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SparseToDenseOptionsT> _o =
        std::unique_ptr<tflite::SparseToDenseOptionsT>(new SparseToDenseOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SparseToDenseOptions::UnPackTo(SparseToDenseOptionsT *_o,
                                           const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e              = validate_indices();
        _o->validate_indices = _e;
    }
}

inline flatbuffers::Offset<SparseToDenseOptions> SparseToDenseOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSparseToDenseOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SparseToDenseOptions> CreateSparseToDenseOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SparseToDenseOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _validate_indices = _o->validate_indices;
    return tflite::CreateSparseToDenseOptions(_fbb, _validate_indices);
}

inline EqualOptionsT *EqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::EqualOptionsT> _o = std::unique_ptr<tflite::EqualOptionsT>(new EqualOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void EqualOptions::UnPackTo(EqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<EqualOptions> EqualOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const EqualOptionsT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateEqualOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EqualOptions> CreateEqualOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const EqualOptionsT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const EqualOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateEqualOptions(_fbb);
}

inline NotEqualOptionsT *NotEqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::NotEqualOptionsT> _o = std::unique_ptr<tflite::NotEqualOptionsT>(new NotEqualOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void NotEqualOptions::UnPackTo(NotEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<NotEqualOptions> NotEqualOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                  const NotEqualOptionsT *_o,
                                                                  const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateNotEqualOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NotEqualOptions> CreateNotEqualOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                  const NotEqualOptionsT *_o,
                                                                  const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const NotEqualOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateNotEqualOptions(_fbb);
}

inline ShapeOptionsT *ShapeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ShapeOptionsT> _o = std::unique_ptr<tflite::ShapeOptionsT>(new ShapeOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void ShapeOptions::UnPackTo(ShapeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e      = out_type();
        _o->out_type = _e;
    }
}

inline flatbuffers::Offset<ShapeOptions> ShapeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const ShapeOptionsT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateShapeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ShapeOptions> CreateShapeOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const ShapeOptionsT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ShapeOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _out_type = _o->out_type;
    return tflite::CreateShapeOptions(_fbb, _out_type);
}

inline RankOptionsT *RankOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::RankOptionsT> _o = std::unique_ptr<tflite::RankOptionsT>(new RankOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void RankOptions::UnPackTo(RankOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<RankOptions> RankOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateRankOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RankOptions> CreateRankOptions(flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const RankOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateRankOptions(_fbb);
}

inline PowOptionsT *PowOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::PowOptionsT> _o = std::unique_ptr<tflite::PowOptionsT>(new PowOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void PowOptions::UnPackTo(PowOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<PowOptions> PowOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    return CreatePowOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PowOptions> CreatePowOptions(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const PowOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreatePowOptions(_fbb);
}

inline FakeQuantOptionsT *FakeQuantOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::FakeQuantOptionsT> _o = std::unique_ptr<tflite::FakeQuantOptionsT>(new FakeQuantOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void FakeQuantOptions::UnPackTo(FakeQuantOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e = min();
        _o->min = _e;
    }
    {
        auto _e = max();
        _o->max = _e;
    }
    {
        auto _e      = num_bits();
        _o->num_bits = _e;
    }
    {
        auto _e          = narrow_range();
        _o->narrow_range = _e;
    }
}

inline flatbuffers::Offset<FakeQuantOptions> FakeQuantOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const FakeQuantOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateFakeQuantOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const FakeQuantOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const FakeQuantOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _min          = _o->min;
    auto _max          = _o->max;
    auto _num_bits     = _o->num_bits;
    auto _narrow_range = _o->narrow_range;
    return tflite::CreateFakeQuantOptions(_fbb, _min, _max, _num_bits, _narrow_range);
}

inline PackOptionsT *PackOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::PackOptionsT> _o = std::unique_ptr<tflite::PackOptionsT>(new PackOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void PackOptions::UnPackTo(PackOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e          = values_count();
        _o->values_count = _e;
    }
    {
        auto _e  = axis();
        _o->axis = _e;
    }
}

inline flatbuffers::Offset<PackOptions> PackOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    return CreatePackOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PackOptions> CreatePackOptions(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const PackOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _values_count = _o->values_count;
    auto _axis         = _o->axis;
    return tflite::CreatePackOptions(_fbb, _values_count, _axis);
}

inline LogicalOrOptionsT *LogicalOrOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::LogicalOrOptionsT> _o = std::unique_ptr<tflite::LogicalOrOptionsT>(new LogicalOrOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void LogicalOrOptions::UnPackTo(LogicalOrOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<LogicalOrOptions> LogicalOrOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const LogicalOrOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateLogicalOrOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogicalOrOptions> CreateLogicalOrOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const LogicalOrOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const LogicalOrOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateLogicalOrOptions(_fbb);
}

inline OneHotOptionsT *OneHotOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::OneHotOptionsT> _o = std::unique_ptr<tflite::OneHotOptionsT>(new OneHotOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void OneHotOptions::UnPackTo(OneHotOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e  = axis();
        _o->axis = _e;
    }
}

inline flatbuffers::Offset<OneHotOptions> OneHotOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const OneHotOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateOneHotOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const OneHotOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const OneHotOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _axis = _o->axis;
    return tflite::CreateOneHotOptions(_fbb, _axis);
}

inline AbsOptionsT *AbsOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::AbsOptionsT> _o = std::unique_ptr<tflite::AbsOptionsT>(new AbsOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void AbsOptions::UnPackTo(AbsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<AbsOptions> AbsOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateAbsOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AbsOptions> CreateAbsOptions(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const AbsOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateAbsOptions(_fbb);
}

inline HardSwishOptionsT *HardSwishOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::HardSwishOptionsT> _o = std::unique_ptr<tflite::HardSwishOptionsT>(new HardSwishOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void HardSwishOptions::UnPackTo(HardSwishOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<HardSwishOptions> HardSwishOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const HardSwishOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateHardSwishOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HardSwishOptions> CreateHardSwishOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const HardSwishOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const HardSwishOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateHardSwishOptions(_fbb);
}

inline LogicalAndOptionsT *LogicalAndOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::LogicalAndOptionsT> _o =
        std::unique_ptr<tflite::LogicalAndOptionsT>(new LogicalAndOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void LogicalAndOptions::UnPackTo(LogicalAndOptionsT *_o,
                                        const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<LogicalAndOptions> LogicalAndOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateLogicalAndOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogicalAndOptions> CreateLogicalAndOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const LogicalAndOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateLogicalAndOptions(_fbb);
}

inline LogicalNotOptionsT *LogicalNotOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::LogicalNotOptionsT> _o =
        std::unique_ptr<tflite::LogicalNotOptionsT>(new LogicalNotOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void LogicalNotOptions::UnPackTo(LogicalNotOptionsT *_o,
                                        const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<LogicalNotOptions> LogicalNotOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateLogicalNotOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogicalNotOptions> CreateLogicalNotOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const LogicalNotOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateLogicalNotOptions(_fbb);
}

inline UnpackOptionsT *UnpackOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::UnpackOptionsT> _o = std::unique_ptr<tflite::UnpackOptionsT>(new UnpackOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void UnpackOptions::UnPackTo(UnpackOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e = num();
        _o->num = _e;
    }
    {
        auto _e  = axis();
        _o->axis = _e;
    }
}

inline flatbuffers::Offset<UnpackOptions> UnpackOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const UnpackOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateUnpackOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const UnpackOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const UnpackOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _num  = _o->num;
    auto _axis = _o->axis;
    return tflite::CreateUnpackOptions(_fbb, _num, _axis);
}

inline FloorDivOptionsT *FloorDivOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::FloorDivOptionsT> _o = std::unique_ptr<tflite::FloorDivOptionsT>(new FloorDivOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void FloorDivOptions::UnPackTo(FloorDivOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<FloorDivOptions> FloorDivOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                  const FloorDivOptionsT *_o,
                                                                  const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateFloorDivOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FloorDivOptions> CreateFloorDivOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                  const FloorDivOptionsT *_o,
                                                                  const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const FloorDivOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateFloorDivOptions(_fbb);
}

inline SquareOptionsT *SquareOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SquareOptionsT> _o = std::unique_ptr<tflite::SquareOptionsT>(new SquareOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SquareOptions::UnPackTo(SquareOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<SquareOptions> SquareOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const SquareOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSquareOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SquareOptions> CreateSquareOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const SquareOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SquareOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateSquareOptions(_fbb);
}

inline ZerosLikeOptionsT *ZerosLikeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ZerosLikeOptionsT> _o = std::unique_ptr<tflite::ZerosLikeOptionsT>(new ZerosLikeOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void ZerosLikeOptions::UnPackTo(ZerosLikeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<ZerosLikeOptions> ZerosLikeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const ZerosLikeOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateZerosLikeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ZerosLikeOptions> CreateZerosLikeOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const ZerosLikeOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ZerosLikeOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateZerosLikeOptions(_fbb);
}

inline FillOptionsT *FillOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::FillOptionsT> _o = std::unique_ptr<tflite::FillOptionsT>(new FillOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void FillOptions::UnPackTo(FillOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<FillOptions> FillOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateFillOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FillOptions> CreateFillOptions(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const FillOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateFillOptions(_fbb);
}

inline FloorModOptionsT *FloorModOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::FloorModOptionsT> _o = std::unique_ptr<tflite::FloorModOptionsT>(new FloorModOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void FloorModOptions::UnPackTo(FloorModOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<FloorModOptions> FloorModOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                  const FloorModOptionsT *_o,
                                                                  const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateFloorModOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FloorModOptions> CreateFloorModOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                  const FloorModOptionsT *_o,
                                                                  const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const FloorModOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateFloorModOptions(_fbb);
}

inline RangeOptionsT *RangeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::RangeOptionsT> _o = std::unique_ptr<tflite::RangeOptionsT>(new RangeOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void RangeOptions::UnPackTo(RangeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<RangeOptions> RangeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const RangeOptionsT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateRangeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RangeOptions> CreateRangeOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const RangeOptionsT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const RangeOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateRangeOptions(_fbb);
}

inline LeakyReluOptionsT *LeakyReluOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::LeakyReluOptionsT> _o = std::unique_ptr<tflite::LeakyReluOptionsT>(new LeakyReluOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void LeakyReluOptions::UnPackTo(LeakyReluOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e   = alpha();
        _o->alpha = _e;
    }
}

inline flatbuffers::Offset<LeakyReluOptions> LeakyReluOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const LeakyReluOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateLeakyReluOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LeakyReluOptions> CreateLeakyReluOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const LeakyReluOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const LeakyReluOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _alpha = _o->alpha;
    return tflite::CreateLeakyReluOptions(_fbb, _alpha);
}

inline SquaredDifferenceOptionsT *SquaredDifferenceOptions::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SquaredDifferenceOptionsT> _o =
        std::unique_ptr<tflite::SquaredDifferenceOptionsT>(new SquaredDifferenceOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SquaredDifferenceOptions::UnPackTo(SquaredDifferenceOptionsT *_o,
                                               const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<SquaredDifferenceOptions> SquaredDifferenceOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSquaredDifferenceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SquaredDifferenceOptions> CreateSquaredDifferenceOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SquaredDifferenceOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateSquaredDifferenceOptions(_fbb);
}

inline MirrorPadOptionsT *MirrorPadOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::MirrorPadOptionsT> _o = std::unique_ptr<tflite::MirrorPadOptionsT>(new MirrorPadOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void MirrorPadOptions::UnPackTo(MirrorPadOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e  = mode();
        _o->mode = _e;
    }
}

inline flatbuffers::Offset<MirrorPadOptions> MirrorPadOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const MirrorPadOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateMirrorPadOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MirrorPadOptions> CreateMirrorPadOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const MirrorPadOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const MirrorPadOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _mode = _o->mode;
    return tflite::CreateMirrorPadOptions(_fbb, _mode);
}

inline UniqueOptionsT *UniqueOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::UniqueOptionsT> _o = std::unique_ptr<tflite::UniqueOptionsT>(new UniqueOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void UniqueOptions::UnPackTo(UniqueOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e          = idx_out_type();
        _o->idx_out_type = _e;
    }
}

inline flatbuffers::Offset<UniqueOptions> UniqueOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const UniqueOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateUniqueOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UniqueOptions> CreateUniqueOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const UniqueOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const UniqueOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _idx_out_type = _o->idx_out_type;
    return tflite::CreateUniqueOptions(_fbb, _idx_out_type);
}

inline ReverseV2OptionsT *ReverseV2Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ReverseV2OptionsT> _o = std::unique_ptr<tflite::ReverseV2OptionsT>(new ReverseV2OptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void ReverseV2Options::UnPackTo(ReverseV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<ReverseV2Options> ReverseV2Options::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const ReverseV2OptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateReverseV2Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReverseV2Options> CreateReverseV2Options(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const ReverseV2OptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ReverseV2OptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateReverseV2Options(_fbb);
}

inline AddNOptionsT *AddNOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::AddNOptionsT> _o = std::unique_ptr<tflite::AddNOptionsT>(new AddNOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void AddNOptions::UnPackTo(AddNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<AddNOptions> AddNOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateAddNOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AddNOptions> CreateAddNOptions(flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const AddNOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateAddNOptions(_fbb);
}

inline GatherNdOptionsT *GatherNdOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::GatherNdOptionsT> _o = std::unique_ptr<tflite::GatherNdOptionsT>(new GatherNdOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void GatherNdOptions::UnPackTo(GatherNdOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<GatherNdOptions> GatherNdOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                  const GatherNdOptionsT *_o,
                                                                  const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateGatherNdOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GatherNdOptions> CreateGatherNdOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                  const GatherNdOptionsT *_o,
                                                                  const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const GatherNdOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateGatherNdOptions(_fbb);
}

inline WhereOptionsT *WhereOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::WhereOptionsT> _o = std::unique_ptr<tflite::WhereOptionsT>(new WhereOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void WhereOptions::UnPackTo(WhereOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<WhereOptions> WhereOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const WhereOptionsT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateWhereOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<WhereOptions> CreateWhereOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const WhereOptionsT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const WhereOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateWhereOptions(_fbb);
}

inline ReverseSequenceOptionsT *ReverseSequenceOptions::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ReverseSequenceOptionsT> _o =
        std::unique_ptr<tflite::ReverseSequenceOptionsT>(new ReverseSequenceOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void ReverseSequenceOptions::UnPackTo(ReverseSequenceOptionsT *_o,
                                             const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e     = seq_dim();
        _o->seq_dim = _e;
    }
    {
        auto _e       = batch_dim();
        _o->batch_dim = _e;
    }
}

inline flatbuffers::Offset<ReverseSequenceOptions> ReverseSequenceOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateReverseSequenceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReverseSequenceOptions> CreateReverseSequenceOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ReverseSequenceOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _seq_dim   = _o->seq_dim;
    auto _batch_dim = _o->batch_dim;
    return tflite::CreateReverseSequenceOptions(_fbb, _seq_dim, _batch_dim);
}

inline MatrixDiagOptionsT *MatrixDiagOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::MatrixDiagOptionsT> _o =
        std::unique_ptr<tflite::MatrixDiagOptionsT>(new MatrixDiagOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void MatrixDiagOptions::UnPackTo(MatrixDiagOptionsT *_o,
                                        const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<MatrixDiagOptions> MatrixDiagOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateMatrixDiagOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MatrixDiagOptions> CreateMatrixDiagOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const MatrixDiagOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateMatrixDiagOptions(_fbb);
}

inline QuantizeOptionsT *QuantizeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::QuantizeOptionsT> _o = std::unique_ptr<tflite::QuantizeOptionsT>(new QuantizeOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void QuantizeOptions::UnPackTo(QuantizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<QuantizeOptions> QuantizeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                  const QuantizeOptionsT *_o,
                                                                  const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateQuantizeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<QuantizeOptions> CreateQuantizeOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                  const QuantizeOptionsT *_o,
                                                                  const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const QuantizeOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateQuantizeOptions(_fbb);
}

inline MatrixSetDiagOptionsT *MatrixSetDiagOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::MatrixSetDiagOptionsT> _o =
        std::unique_ptr<tflite::MatrixSetDiagOptionsT>(new MatrixSetDiagOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void MatrixSetDiagOptions::UnPackTo(MatrixSetDiagOptionsT *_o,
                                           const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<MatrixSetDiagOptions> MatrixSetDiagOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const MatrixSetDiagOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateMatrixSetDiagOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MatrixSetDiagOptions> CreateMatrixSetDiagOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const MatrixSetDiagOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const MatrixSetDiagOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateMatrixSetDiagOptions(_fbb);
}

inline IfOptionsT *IfOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::IfOptionsT> _o = std::unique_ptr<tflite::IfOptionsT>(new IfOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void IfOptions::UnPackTo(IfOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e                 = then_subgraph_index();
        _o->then_subgraph_index = _e;
    }
    {
        auto _e                 = else_subgraph_index();
        _o->else_subgraph_index = _e;
    }
}

inline flatbuffers::Offset<IfOptions> IfOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT *_o,
                                                      const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateIfOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<IfOptions> CreateIfOptions(flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT *_o,
                                                      const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const IfOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _then_subgraph_index = _o->then_subgraph_index;
    auto _else_subgraph_index = _o->else_subgraph_index;
    return tflite::CreateIfOptions(_fbb, _then_subgraph_index, _else_subgraph_index);
}

inline WhileOptionsT *WhileOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::WhileOptionsT> _o = std::unique_ptr<tflite::WhileOptionsT>(new WhileOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void WhileOptions::UnPackTo(WhileOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e                 = cond_subgraph_index();
        _o->cond_subgraph_index = _e;
    }
    {
        auto _e                 = body_subgraph_index();
        _o->body_subgraph_index = _e;
    }
}

inline flatbuffers::Offset<WhileOptions> WhileOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const WhileOptionsT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateWhileOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<WhileOptions> CreateWhileOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const WhileOptionsT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const WhileOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _cond_subgraph_index = _o->cond_subgraph_index;
    auto _body_subgraph_index = _o->body_subgraph_index;
    return tflite::CreateWhileOptions(_fbb, _cond_subgraph_index, _body_subgraph_index);
}

inline NonMaxSuppressionV4OptionsT *NonMaxSuppressionV4Options::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::NonMaxSuppressionV4OptionsT> _o =
        std::unique_ptr<tflite::NonMaxSuppressionV4OptionsT>(new NonMaxSuppressionV4OptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void NonMaxSuppressionV4Options::UnPackTo(NonMaxSuppressionV4OptionsT *_o,
                                                 const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<NonMaxSuppressionV4Options> NonMaxSuppressionV4Options::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV4OptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateNonMaxSuppressionV4Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NonMaxSuppressionV4Options> CreateNonMaxSuppressionV4Options(
    flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV4OptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const NonMaxSuppressionV4OptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateNonMaxSuppressionV4Options(_fbb);
}

inline NonMaxSuppressionV5OptionsT *NonMaxSuppressionV5Options::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::NonMaxSuppressionV5OptionsT> _o =
        std::unique_ptr<tflite::NonMaxSuppressionV5OptionsT>(new NonMaxSuppressionV5OptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void NonMaxSuppressionV5Options::UnPackTo(NonMaxSuppressionV5OptionsT *_o,
                                                 const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<NonMaxSuppressionV5Options> NonMaxSuppressionV5Options::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV5OptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateNonMaxSuppressionV5Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NonMaxSuppressionV5Options> CreateNonMaxSuppressionV5Options(
    flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV5OptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const NonMaxSuppressionV5OptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateNonMaxSuppressionV5Options(_fbb);
}

inline ScatterNdOptionsT *ScatterNdOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ScatterNdOptionsT> _o = std::unique_ptr<tflite::ScatterNdOptionsT>(new ScatterNdOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void ScatterNdOptions::UnPackTo(ScatterNdOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<ScatterNdOptions> ScatterNdOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const ScatterNdOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateScatterNdOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ScatterNdOptions> CreateScatterNdOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const ScatterNdOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ScatterNdOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateScatterNdOptions(_fbb);
}

inline SelectV2OptionsT *SelectV2Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SelectV2OptionsT> _o = std::unique_ptr<tflite::SelectV2OptionsT>(new SelectV2OptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SelectV2Options::UnPackTo(SelectV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<SelectV2Options> SelectV2Options::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                  const SelectV2OptionsT *_o,
                                                                  const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSelectV2Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SelectV2Options> CreateSelectV2Options(flatbuffers::FlatBufferBuilder &_fbb,
                                                                  const SelectV2OptionsT *_o,
                                                                  const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SelectV2OptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateSelectV2Options(_fbb);
}

inline DensifyOptionsT *DensifyOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::DensifyOptionsT> _o = std::unique_ptr<tflite::DensifyOptionsT>(new DensifyOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void DensifyOptions::UnPackTo(DensifyOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<DensifyOptions> DensifyOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                const DensifyOptionsT *_o,
                                                                const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateDensifyOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DensifyOptions> CreateDensifyOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                const DensifyOptionsT *_o,
                                                                const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const DensifyOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateDensifyOptions(_fbb);
}

inline SegmentSumOptionsT *SegmentSumOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SegmentSumOptionsT> _o =
        std::unique_ptr<tflite::SegmentSumOptionsT>(new SegmentSumOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SegmentSumOptions::UnPackTo(SegmentSumOptionsT *_o,
                                        const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<SegmentSumOptions> SegmentSumOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const SegmentSumOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSegmentSumOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SegmentSumOptions> CreateSegmentSumOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const SegmentSumOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SegmentSumOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateSegmentSumOptions(_fbb);
}

inline BatchMatMulOptionsT *BatchMatMulOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::BatchMatMulOptionsT> _o =
        std::unique_ptr<tflite::BatchMatMulOptionsT>(new BatchMatMulOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void BatchMatMulOptions::UnPackTo(BatchMatMulOptionsT *_o,
                                         const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e   = adj_x();
        _o->adj_x = _e;
    }
    {
        auto _e   = adj_y();
        _o->adj_y = _e;
    }
}

inline flatbuffers::Offset<BatchMatMulOptions> BatchMatMulOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateBatchMatMulOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatchMatMulOptions> CreateBatchMatMulOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const BatchMatMulOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _adj_x = _o->adj_x;
    auto _adj_y = _o->adj_y;
    return tflite::CreateBatchMatMulOptions(_fbb, _adj_x, _adj_y);
}

inline OperatorCodeT *OperatorCode::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::OperatorCodeT> _o = std::unique_ptr<tflite::OperatorCodeT>(new OperatorCodeT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void OperatorCode::UnPackTo(OperatorCodeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e          = builtin_code();
        _o->builtin_code = _e;
    }
    {
        auto _e = custom_code();
        if (_e)
            _o->custom_code = _e->str();
    }
    {
        auto _e     = version();
        _o->version = _e;
    }
}

inline flatbuffers::Offset<OperatorCode> OperatorCode::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const OperatorCodeT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateOperatorCode(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OperatorCode> CreateOperatorCode(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const OperatorCodeT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const OperatorCodeT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _builtin_code = _o->builtin_code;
    auto _custom_code  = _o->custom_code.empty() ? 0 : _fbb.CreateString(_o->custom_code);
    auto _version      = _o->version;
    return tflite::CreateOperatorCode(_fbb, _builtin_code, _custom_code, _version);
}

inline OperatorT *Operator::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::OperatorT> _o = std::unique_ptr<tflite::OperatorT>(new OperatorT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void Operator::UnPackTo(OperatorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e          = opcode_index();
        _o->opcode_index = _e;
    }
    {
        auto _e = inputs();
        if (_e) {
            _o->inputs.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->inputs[_i] = _e->Get(_i);
            }
        }
    }
    {
        auto _e = outputs();
        if (_e) {
            _o->outputs.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->outputs[_i] = _e->Get(_i);
            }
        }
    }
    {
        auto _e                  = builtin_options_type();
        _o->builtin_options.type = _e;
    }
    {
        auto _e = builtin_options();
        if (_e)
            _o->builtin_options.value = tflite::BuiltinOptionsUnion::UnPack(_e, builtin_options_type(), _resolver);
    }
    {
        auto _e = custom_options();
        if (_e) {
            _o->custom_options.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->custom_options[_i] = _e->Get(_i);
            }
        }
    }
    {
        auto _e                   = custom_options_format();
        _o->custom_options_format = _e;
    }
    {
        auto _e = mutating_variable_inputs();
        if (_e) {
            _o->mutating_variable_inputs.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->mutating_variable_inputs[_i] = _e->Get(_i) != 0;
            }
        }
    }
    {
        auto _e = intermediates();
        if (_e) {
            _o->intermediates.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->intermediates[_i] = _e->Get(_i);
            }
        }
    }
}

inline flatbuffers::Offset<Operator> Operator::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT *_o,
                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateOperator(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Operator> CreateOperator(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT *_o,
                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const OperatorT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _opcode_index          = _o->opcode_index;
    auto _inputs                = _o->inputs.size() ? _fbb.CreateVector(_o->inputs) : 0;
    auto _outputs               = _o->outputs.size() ? _fbb.CreateVector(_o->outputs) : 0;
    auto _builtin_options_type  = _o->builtin_options.type;
    auto _builtin_options       = _o->builtin_options.Pack(_fbb);
    auto _custom_options        = _o->custom_options.size() ? _fbb.CreateVector(_o->custom_options) : 0;
    auto _custom_options_format = _o->custom_options_format;
    auto _mutating_variable_inputs =
        _o->mutating_variable_inputs.size() ? _fbb.CreateVector(_o->mutating_variable_inputs) : 0;
    auto _intermediates = _o->intermediates.size() ? _fbb.CreateVector(_o->intermediates) : 0;
    return tflite::CreateOperator(_fbb, _opcode_index, _inputs, _outputs, _builtin_options_type, _builtin_options,
                                  _custom_options, _custom_options_format, _mutating_variable_inputs, _intermediates);
}

inline SubGraphT *SubGraph::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SubGraphT> _o = std::unique_ptr<tflite::SubGraphT>(new SubGraphT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SubGraph::UnPackTo(SubGraphT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e = tensors();
        if (_e) {
            _o->tensors.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->tensors[_i] = std::unique_ptr<tflite::TensorT>(_e->Get(_i)->UnPack(_resolver));
            }
        }
    }
    {
        auto _e = inputs();
        if (_e) {
            _o->inputs.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->inputs[_i] = _e->Get(_i);
            }
        }
    }
    {
        auto _e = outputs();
        if (_e) {
            _o->outputs.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->outputs[_i] = _e->Get(_i);
            }
        }
    }
    {
        auto _e = operators();
        if (_e) {
            _o->operators.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->operators[_i] = std::unique_ptr<tflite::OperatorT>(_e->Get(_i)->UnPack(_resolver));
            }
        }
    }
    {
        auto _e = name();
        if (_e)
            _o->name = _e->str();
    }
}

inline flatbuffers::Offset<SubGraph> SubGraph::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o,
                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSubGraph(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SubGraph> CreateSubGraph(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o,
                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SubGraphT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _tensors = _o->tensors.size()
                        ? _fbb.CreateVector<flatbuffers::Offset<tflite::Tensor>>(
                              _o->tensors.size(),
                              [](size_t i, _VectorArgs *__va) {
                                  return CreateTensor(*__va->__fbb, __va->__o->tensors[i].get(), __va->__rehasher);
                              },
                              &_va)
                        : 0;
    auto _inputs    = _o->inputs.size() ? _fbb.CreateVector(_o->inputs) : 0;
    auto _outputs   = _o->outputs.size() ? _fbb.CreateVector(_o->outputs) : 0;
    auto _operators = _o->operators.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::Operator>>(
                                                 _o->operators.size(),
                                                 [](size_t i, _VectorArgs *__va) {
                                                     return CreateOperator(*__va->__fbb, __va->__o->operators[i].get(),
                                                                           __va->__rehasher);
                                                 },
                                                 &_va)
                                           : 0;
    auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
    return tflite::CreateSubGraph(_fbb, _tensors, _inputs, _outputs, _operators, _name);
}

inline BufferT *Buffer::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::BufferT> _o = std::unique_ptr<tflite::BufferT>(new BufferT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void Buffer::UnPackTo(BufferT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e = data();
        if (_e) {
            _o->data.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->data[_i] = _e->Get(_i);
            }
        }
    }
}

inline flatbuffers::Offset<Buffer> Buffer::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BufferT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateBuffer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Buffer> CreateBuffer(flatbuffers::FlatBufferBuilder &_fbb, const BufferT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const BufferT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    _fbb.ForceVectorAlignment(_o->data.size(), sizeof(uint8_t), 16);
    auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
    return tflite::CreateBuffer(_fbb, _data);
}

inline MetadataT *Metadata::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::MetadataT> _o = std::unique_ptr<tflite::MetadataT>(new MetadataT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void Metadata::UnPackTo(MetadataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e = name();
        if (_e)
            _o->name = _e->str();
    }
    {
        auto _e    = buffer();
        _o->buffer = _e;
    }
}

inline flatbuffers::Offset<Metadata> Metadata::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o,
                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateMetadata(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Metadata> CreateMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o,
                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const MetadataT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _name   = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
    auto _buffer = _o->buffer;
    return tflite::CreateMetadata(_fbb, _name, _buffer);
}

inline ModelT *Model::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ModelT> _o = std::unique_ptr<tflite::ModelT>(new ModelT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void Model::UnPackTo(ModelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e     = version();
        _o->version = _e;
    }
    {
        auto _e = operator_codes();
        if (_e) {
            _o->operator_codes.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->operator_codes[_i] = std::unique_ptr<tflite::OperatorCodeT>(_e->Get(_i)->UnPack(_resolver));
            }
        }
    }
    {
        auto _e = subgraphs();
        if (_e) {
            _o->subgraphs.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->subgraphs[_i] = std::unique_ptr<tflite::SubGraphT>(_e->Get(_i)->UnPack(_resolver));
            }
        }
    }
    {
        auto _e = description();
        if (_e)
            _o->description = _e->str();
    }
    {
        auto _e = buffers();
        if (_e) {
            _o->buffers.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->buffers[_i] = std::unique_ptr<tflite::BufferT>(_e->Get(_i)->UnPack(_resolver));
            }
        }
    }
    {
        auto _e = metadata_buffer();
        if (_e) {
            _o->metadata_buffer.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->metadata_buffer[_i] = _e->Get(_i);
            }
        }
    }
    {
        auto _e = metadata();
        if (_e) {
            _o->metadata.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->metadata[_i] = std::unique_ptr<tflite::MetadataT>(_e->Get(_i)->UnPack(_resolver));
            }
        }
    }
}

inline flatbuffers::Offset<Model> Model::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o,
                                              const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateModel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Model> CreateModel(flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o,
                                              const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ModelT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _version = _o->version;
    auto _operator_codes =
        _o->operator_codes.size()
            ? _fbb.CreateVector<flatbuffers::Offset<tflite::OperatorCode>>(
                  _o->operator_codes.size(),
                  [](size_t i, _VectorArgs *__va) {
                      return CreateOperatorCode(*__va->__fbb, __va->__o->operator_codes[i].get(), __va->__rehasher);
                  },
                  &_va)
            : 0;
    auto _subgraphs = _o->subgraphs.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::SubGraph>>(
                                                 _o->subgraphs.size(),
                                                 [](size_t i, _VectorArgs *__va) {
                                                     return CreateSubGraph(*__va->__fbb, __va->__o->subgraphs[i].get(),
                                                                           __va->__rehasher);
                                                 },
                                                 &_va)
                                           : 0;
    auto _description = _o->description.empty() ? 0 : _fbb.CreateString(_o->description);
    auto _buffers     = _o->buffers.size()
                        ? _fbb.CreateVector<flatbuffers::Offset<tflite::Buffer>>(
                              _o->buffers.size(),
                              [](size_t i, _VectorArgs *__va) {
                                  return CreateBuffer(*__va->__fbb, __va->__o->buffers[i].get(), __va->__rehasher);
                              },
                              &_va)
                        : 0;
    auto _metadata_buffer = _o->metadata_buffer.size() ? _fbb.CreateVector(_o->metadata_buffer) : 0;
    auto _metadata        = _o->metadata.size()
                         ? _fbb.CreateVector<flatbuffers::Offset<tflite::Metadata>>(
                               _o->metadata.size(),
                               [](size_t i, _VectorArgs *__va) {
                                   return CreateMetadata(*__va->__fbb, __va->__o->metadata[i].get(), __va->__rehasher);
                               },
                               &_va)
                         : 0;
    return tflite::CreateModel(_fbb, _version, _operator_codes, _subgraphs, _description, _buffers, _metadata_buffer,
                               _metadata);
}

inline bool VerifyQuantizationDetails(flatbuffers::Verifier &verifier, const void *obj, QuantizationDetails type) {
    switch (type) {
        case QuantizationDetails_NONE: {
            return true;
        }
        case QuantizationDetails_CustomQuantization: {
            auto ptr = reinterpret_cast<const tflite::CustomQuantization *>(obj);
            return verifier.VerifyTable(ptr);
        }
        default:
            return true;
    }
}

inline bool VerifyQuantizationDetailsVector(flatbuffers::Verifier &verifier,
                                            const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                                            const flatbuffers::Vector<uint8_t> *types) {
    if (!values || !types)
        return !values && !types;
    if (values->size() != types->size())
        return false;
    for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
        if (!VerifyQuantizationDetails(verifier, values->Get(i), types->GetEnum<QuantizationDetails>(i))) {
            return false;
        }
    }
    return true;
}

inline void *QuantizationDetailsUnion::UnPack(const void *obj, QuantizationDetails type,
                                              const flatbuffers::resolver_function_t *resolver) {
    switch (type) {
        case QuantizationDetails_CustomQuantization: {
            auto ptr = reinterpret_cast<const tflite::CustomQuantization *>(obj);
            return ptr->UnPack(resolver);
        }
        default:
            return nullptr;
    }
}

inline flatbuffers::Offset<void> QuantizationDetailsUnion::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
    switch (type) {
        case QuantizationDetails_CustomQuantization: {
            auto ptr = reinterpret_cast<const tflite::CustomQuantizationT *>(value);
            return CreateCustomQuantization(_fbb, ptr, _rehasher).Union();
        }
        default:
            return 0;
    }
}

inline QuantizationDetailsUnion::QuantizationDetailsUnion(const QuantizationDetailsUnion &u)
    : type(u.type), value(nullptr) {
    switch (type) {
        case QuantizationDetails_CustomQuantization: {
            value = new tflite::CustomQuantizationT(*reinterpret_cast<tflite::CustomQuantizationT *>(u.value));
            break;
        }
        default:
            break;
    }
}

inline void QuantizationDetailsUnion::Reset() {
    switch (type) {
        case QuantizationDetails_CustomQuantization: {
            auto ptr = reinterpret_cast<tflite::CustomQuantizationT *>(value);
            delete ptr;
            break;
        }
        default:
            break;
    }
    value = nullptr;
    type  = QuantizationDetails_NONE;
}

inline bool VerifySparseIndexVector(flatbuffers::Verifier &verifier, const void *obj, SparseIndexVector type) {
    switch (type) {
        case SparseIndexVector_NONE: {
            return true;
        }
        case SparseIndexVector_Int32Vector: {
            auto ptr = reinterpret_cast<const tflite::Int32Vector *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case SparseIndexVector_Uint16Vector: {
            auto ptr = reinterpret_cast<const tflite::Uint16Vector *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case SparseIndexVector_Uint8Vector: {
            auto ptr = reinterpret_cast<const tflite::Uint8Vector *>(obj);
            return verifier.VerifyTable(ptr);
        }
        default:
            return true;
    }
}

inline bool VerifySparseIndexVectorVector(flatbuffers::Verifier &verifier,
                                          const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                                          const flatbuffers::Vector<uint8_t> *types) {
    if (!values || !types)
        return !values && !types;
    if (values->size() != types->size())
        return false;
    for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
        if (!VerifySparseIndexVector(verifier, values->Get(i), types->GetEnum<SparseIndexVector>(i))) {
            return false;
        }
    }
    return true;
}

inline void *SparseIndexVectorUnion::UnPack(const void *obj, SparseIndexVector type,
                                            const flatbuffers::resolver_function_t *resolver) {
    switch (type) {
        case SparseIndexVector_Int32Vector: {
            auto ptr = reinterpret_cast<const tflite::Int32Vector *>(obj);
            return ptr->UnPack(resolver);
        }
        case SparseIndexVector_Uint16Vector: {
            auto ptr = reinterpret_cast<const tflite::Uint16Vector *>(obj);
            return ptr->UnPack(resolver);
        }
        case SparseIndexVector_Uint8Vector: {
            auto ptr = reinterpret_cast<const tflite::Uint8Vector *>(obj);
            return ptr->UnPack(resolver);
        }
        default:
            return nullptr;
    }
}

inline flatbuffers::Offset<void> SparseIndexVectorUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const flatbuffers::rehasher_function_t *_rehasher) const {
    switch (type) {
        case SparseIndexVector_Int32Vector: {
            auto ptr = reinterpret_cast<const tflite::Int32VectorT *>(value);
            return CreateInt32Vector(_fbb, ptr, _rehasher).Union();
        }
        case SparseIndexVector_Uint16Vector: {
            auto ptr = reinterpret_cast<const tflite::Uint16VectorT *>(value);
            return CreateUint16Vector(_fbb, ptr, _rehasher).Union();
        }
        case SparseIndexVector_Uint8Vector: {
            auto ptr = reinterpret_cast<const tflite::Uint8VectorT *>(value);
            return CreateUint8Vector(_fbb, ptr, _rehasher).Union();
        }
        default:
            return 0;
    }
}

inline SparseIndexVectorUnion::SparseIndexVectorUnion(const SparseIndexVectorUnion &u) : type(u.type), value(nullptr) {
    switch (type) {
        case SparseIndexVector_Int32Vector: {
            value = new tflite::Int32VectorT(*reinterpret_cast<tflite::Int32VectorT *>(u.value));
            break;
        }
        case SparseIndexVector_Uint16Vector: {
            value = new tflite::Uint16VectorT(*reinterpret_cast<tflite::Uint16VectorT *>(u.value));
            break;
        }
        case SparseIndexVector_Uint8Vector: {
            value = new tflite::Uint8VectorT(*reinterpret_cast<tflite::Uint8VectorT *>(u.value));
            break;
        }
        default:
            break;
    }
}

inline void SparseIndexVectorUnion::Reset() {
    switch (type) {
        case SparseIndexVector_Int32Vector: {
            auto ptr = reinterpret_cast<tflite::Int32VectorT *>(value);
            delete ptr;
            break;
        }
        case SparseIndexVector_Uint16Vector: {
            auto ptr = reinterpret_cast<tflite::Uint16VectorT *>(value);
            delete ptr;
            break;
        }
        case SparseIndexVector_Uint8Vector: {
            auto ptr = reinterpret_cast<tflite::Uint8VectorT *>(value);
            delete ptr;
            break;
        }
        default:
            break;
    }
    value = nullptr;
    type  = SparseIndexVector_NONE;
}

inline bool VerifyBuiltinOptions(flatbuffers::Verifier &verifier, const void *obj, BuiltinOptions type) {
    switch (type) {
        case BuiltinOptions_NONE: {
            return true;
        }
        case BuiltinOptions_Conv2DOptions: {
            auto ptr = reinterpret_cast<const tflite::Conv2DOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_DepthwiseConv2DOptions: {
            auto ptr = reinterpret_cast<const tflite::DepthwiseConv2DOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_ConcatEmbeddingsOptions: {
            auto ptr = reinterpret_cast<const tflite::ConcatEmbeddingsOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_LSHProjectionOptions: {
            auto ptr = reinterpret_cast<const tflite::LSHProjectionOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_Pool2DOptions: {
            auto ptr = reinterpret_cast<const tflite::Pool2DOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SVDFOptions: {
            auto ptr = reinterpret_cast<const tflite::SVDFOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_RNNOptions: {
            auto ptr = reinterpret_cast<const tflite::RNNOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_FullyConnectedOptions: {
            auto ptr = reinterpret_cast<const tflite::FullyConnectedOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SoftmaxOptions: {
            auto ptr = reinterpret_cast<const tflite::SoftmaxOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_ConcatenationOptions: {
            auto ptr = reinterpret_cast<const tflite::ConcatenationOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_AddOptions: {
            auto ptr = reinterpret_cast<const tflite::AddOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_L2NormOptions: {
            auto ptr = reinterpret_cast<const tflite::L2NormOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_LocalResponseNormalizationOptions: {
            auto ptr = reinterpret_cast<const tflite::LocalResponseNormalizationOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_LSTMOptions: {
            auto ptr = reinterpret_cast<const tflite::LSTMOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_ResizeBilinearOptions: {
            auto ptr = reinterpret_cast<const tflite::ResizeBilinearOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_CallOptions: {
            auto ptr = reinterpret_cast<const tflite::CallOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_ReshapeOptions: {
            auto ptr = reinterpret_cast<const tflite::ReshapeOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SkipGramOptions: {
            auto ptr = reinterpret_cast<const tflite::SkipGramOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SpaceToDepthOptions: {
            auto ptr = reinterpret_cast<const tflite::SpaceToDepthOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_EmbeddingLookupSparseOptions: {
            auto ptr = reinterpret_cast<const tflite::EmbeddingLookupSparseOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_MulOptions: {
            auto ptr = reinterpret_cast<const tflite::MulOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_PadOptions: {
            auto ptr = reinterpret_cast<const tflite::PadOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_GatherOptions: {
            auto ptr = reinterpret_cast<const tflite::GatherOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_BatchToSpaceNDOptions: {
            auto ptr = reinterpret_cast<const tflite::BatchToSpaceNDOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SpaceToBatchNDOptions: {
            auto ptr = reinterpret_cast<const tflite::SpaceToBatchNDOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_TransposeOptions: {
            auto ptr = reinterpret_cast<const tflite::TransposeOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_ReducerOptions: {
            auto ptr = reinterpret_cast<const tflite::ReducerOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SubOptions: {
            auto ptr = reinterpret_cast<const tflite::SubOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_DivOptions: {
            auto ptr = reinterpret_cast<const tflite::DivOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SqueezeOptions: {
            auto ptr = reinterpret_cast<const tflite::SqueezeOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SequenceRNNOptions: {
            auto ptr = reinterpret_cast<const tflite::SequenceRNNOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_StridedSliceOptions: {
            auto ptr = reinterpret_cast<const tflite::StridedSliceOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_ExpOptions: {
            auto ptr = reinterpret_cast<const tflite::ExpOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_TopKV2Options: {
            auto ptr = reinterpret_cast<const tflite::TopKV2Options *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SplitOptions: {
            auto ptr = reinterpret_cast<const tflite::SplitOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_LogSoftmaxOptions: {
            auto ptr = reinterpret_cast<const tflite::LogSoftmaxOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_CastOptions: {
            auto ptr = reinterpret_cast<const tflite::CastOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_DequantizeOptions: {
            auto ptr = reinterpret_cast<const tflite::DequantizeOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_MaximumMinimumOptions: {
            auto ptr = reinterpret_cast<const tflite::MaximumMinimumOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_ArgMaxOptions: {
            auto ptr = reinterpret_cast<const tflite::ArgMaxOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_LessOptions: {
            auto ptr = reinterpret_cast<const tflite::LessOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_NegOptions: {
            auto ptr = reinterpret_cast<const tflite::NegOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_PadV2Options: {
            auto ptr = reinterpret_cast<const tflite::PadV2Options *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_GreaterOptions: {
            auto ptr = reinterpret_cast<const tflite::GreaterOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_GreaterEqualOptions: {
            auto ptr = reinterpret_cast<const tflite::GreaterEqualOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_LessEqualOptions: {
            auto ptr = reinterpret_cast<const tflite::LessEqualOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SelectOptions: {
            auto ptr = reinterpret_cast<const tflite::SelectOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SliceOptions: {
            auto ptr = reinterpret_cast<const tflite::SliceOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_TransposeConvOptions: {
            auto ptr = reinterpret_cast<const tflite::TransposeConvOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SparseToDenseOptions: {
            auto ptr = reinterpret_cast<const tflite::SparseToDenseOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_TileOptions: {
            auto ptr = reinterpret_cast<const tflite::TileOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_ExpandDimsOptions: {
            auto ptr = reinterpret_cast<const tflite::ExpandDimsOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_EqualOptions: {
            auto ptr = reinterpret_cast<const tflite::EqualOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_NotEqualOptions: {
            auto ptr = reinterpret_cast<const tflite::NotEqualOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_ShapeOptions: {
            auto ptr = reinterpret_cast<const tflite::ShapeOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_PowOptions: {
            auto ptr = reinterpret_cast<const tflite::PowOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_ArgMinOptions: {
            auto ptr = reinterpret_cast<const tflite::ArgMinOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_FakeQuantOptions: {
            auto ptr = reinterpret_cast<const tflite::FakeQuantOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_PackOptions: {
            auto ptr = reinterpret_cast<const tflite::PackOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_LogicalOrOptions: {
            auto ptr = reinterpret_cast<const tflite::LogicalOrOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_OneHotOptions: {
            auto ptr = reinterpret_cast<const tflite::OneHotOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_LogicalAndOptions: {
            auto ptr = reinterpret_cast<const tflite::LogicalAndOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_LogicalNotOptions: {
            auto ptr = reinterpret_cast<const tflite::LogicalNotOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_UnpackOptions: {
            auto ptr = reinterpret_cast<const tflite::UnpackOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_FloorDivOptions: {
            auto ptr = reinterpret_cast<const tflite::FloorDivOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SquareOptions: {
            auto ptr = reinterpret_cast<const tflite::SquareOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_ZerosLikeOptions: {
            auto ptr = reinterpret_cast<const tflite::ZerosLikeOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_FillOptions: {
            auto ptr = reinterpret_cast<const tflite::FillOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
            auto ptr = reinterpret_cast<const tflite::BidirectionalSequenceLSTMOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_BidirectionalSequenceRNNOptions: {
            auto ptr = reinterpret_cast<const tflite::BidirectionalSequenceRNNOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
            auto ptr = reinterpret_cast<const tflite::UnidirectionalSequenceLSTMOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_FloorModOptions: {
            auto ptr = reinterpret_cast<const tflite::FloorModOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_RangeOptions: {
            auto ptr = reinterpret_cast<const tflite::RangeOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_ResizeNearestNeighborOptions: {
            auto ptr = reinterpret_cast<const tflite::ResizeNearestNeighborOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_LeakyReluOptions: {
            auto ptr = reinterpret_cast<const tflite::LeakyReluOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SquaredDifferenceOptions: {
            auto ptr = reinterpret_cast<const tflite::SquaredDifferenceOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_MirrorPadOptions: {
            auto ptr = reinterpret_cast<const tflite::MirrorPadOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_AbsOptions: {
            auto ptr = reinterpret_cast<const tflite::AbsOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SplitVOptions: {
            auto ptr = reinterpret_cast<const tflite::SplitVOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_UniqueOptions: {
            auto ptr = reinterpret_cast<const tflite::UniqueOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_ReverseV2Options: {
            auto ptr = reinterpret_cast<const tflite::ReverseV2Options *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_AddNOptions: {
            auto ptr = reinterpret_cast<const tflite::AddNOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_GatherNdOptions: {
            auto ptr = reinterpret_cast<const tflite::GatherNdOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_CosOptions: {
            auto ptr = reinterpret_cast<const tflite::CosOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_WhereOptions: {
            auto ptr = reinterpret_cast<const tflite::WhereOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_RankOptions: {
            auto ptr = reinterpret_cast<const tflite::RankOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_ReverseSequenceOptions: {
            auto ptr = reinterpret_cast<const tflite::ReverseSequenceOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_MatrixDiagOptions: {
            auto ptr = reinterpret_cast<const tflite::MatrixDiagOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_QuantizeOptions: {
            auto ptr = reinterpret_cast<const tflite::QuantizeOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_MatrixSetDiagOptions: {
            auto ptr = reinterpret_cast<const tflite::MatrixSetDiagOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_HardSwishOptions: {
            auto ptr = reinterpret_cast<const tflite::HardSwishOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_IfOptions: {
            auto ptr = reinterpret_cast<const tflite::IfOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_WhileOptions: {
            auto ptr = reinterpret_cast<const tflite::WhileOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_DepthToSpaceOptions: {
            auto ptr = reinterpret_cast<const tflite::DepthToSpaceOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_NonMaxSuppressionV4Options: {
            auto ptr = reinterpret_cast<const tflite::NonMaxSuppressionV4Options *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_NonMaxSuppressionV5Options: {
            auto ptr = reinterpret_cast<const tflite::NonMaxSuppressionV5Options *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_ScatterNdOptions: {
            auto ptr = reinterpret_cast<const tflite::ScatterNdOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SelectV2Options: {
            auto ptr = reinterpret_cast<const tflite::SelectV2Options *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_DensifyOptions: {
            auto ptr = reinterpret_cast<const tflite::DensifyOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SegmentSumOptions: {
            auto ptr = reinterpret_cast<const tflite::SegmentSumOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_BatchMatMulOptions: {
            auto ptr = reinterpret_cast<const tflite::BatchMatMulOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        default:
            return true;
    }
}

inline bool VerifyBuiltinOptionsVector(flatbuffers::Verifier &verifier,
                                       const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                                       const flatbuffers::Vector<uint8_t> *types) {
    if (!values || !types)
        return !values && !types;
    if (values->size() != types->size())
        return false;
    for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
        if (!VerifyBuiltinOptions(verifier, values->Get(i), types->GetEnum<BuiltinOptions>(i))) {
            return false;
        }
    }
    return true;
}

inline void *BuiltinOptionsUnion::UnPack(const void *obj, BuiltinOptions type,
                                         const flatbuffers::resolver_function_t *resolver) {
    switch (type) {
        case BuiltinOptions_Conv2DOptions: {
            auto ptr = reinterpret_cast<const tflite::Conv2DOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_DepthwiseConv2DOptions: {
            auto ptr = reinterpret_cast<const tflite::DepthwiseConv2DOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_ConcatEmbeddingsOptions: {
            auto ptr = reinterpret_cast<const tflite::ConcatEmbeddingsOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_LSHProjectionOptions: {
            auto ptr = reinterpret_cast<const tflite::LSHProjectionOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_Pool2DOptions: {
            auto ptr = reinterpret_cast<const tflite::Pool2DOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SVDFOptions: {
            auto ptr = reinterpret_cast<const tflite::SVDFOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_RNNOptions: {
            auto ptr = reinterpret_cast<const tflite::RNNOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_FullyConnectedOptions: {
            auto ptr = reinterpret_cast<const tflite::FullyConnectedOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SoftmaxOptions: {
            auto ptr = reinterpret_cast<const tflite::SoftmaxOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_ConcatenationOptions: {
            auto ptr = reinterpret_cast<const tflite::ConcatenationOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_AddOptions: {
            auto ptr = reinterpret_cast<const tflite::AddOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_L2NormOptions: {
            auto ptr = reinterpret_cast<const tflite::L2NormOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_LocalResponseNormalizationOptions: {
            auto ptr = reinterpret_cast<const tflite::LocalResponseNormalizationOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_LSTMOptions: {
            auto ptr = reinterpret_cast<const tflite::LSTMOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_ResizeBilinearOptions: {
            auto ptr = reinterpret_cast<const tflite::ResizeBilinearOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_CallOptions: {
            auto ptr = reinterpret_cast<const tflite::CallOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_ReshapeOptions: {
            auto ptr = reinterpret_cast<const tflite::ReshapeOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SkipGramOptions: {
            auto ptr = reinterpret_cast<const tflite::SkipGramOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SpaceToDepthOptions: {
            auto ptr = reinterpret_cast<const tflite::SpaceToDepthOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_EmbeddingLookupSparseOptions: {
            auto ptr = reinterpret_cast<const tflite::EmbeddingLookupSparseOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_MulOptions: {
            auto ptr = reinterpret_cast<const tflite::MulOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_PadOptions: {
            auto ptr = reinterpret_cast<const tflite::PadOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_GatherOptions: {
            auto ptr = reinterpret_cast<const tflite::GatherOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_BatchToSpaceNDOptions: {
            auto ptr = reinterpret_cast<const tflite::BatchToSpaceNDOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SpaceToBatchNDOptions: {
            auto ptr = reinterpret_cast<const tflite::SpaceToBatchNDOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_TransposeOptions: {
            auto ptr = reinterpret_cast<const tflite::TransposeOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_ReducerOptions: {
            auto ptr = reinterpret_cast<const tflite::ReducerOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SubOptions: {
            auto ptr = reinterpret_cast<const tflite::SubOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_DivOptions: {
            auto ptr = reinterpret_cast<const tflite::DivOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SqueezeOptions: {
            auto ptr = reinterpret_cast<const tflite::SqueezeOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SequenceRNNOptions: {
            auto ptr = reinterpret_cast<const tflite::SequenceRNNOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_StridedSliceOptions: {
            auto ptr = reinterpret_cast<const tflite::StridedSliceOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_ExpOptions: {
            auto ptr = reinterpret_cast<const tflite::ExpOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_TopKV2Options: {
            auto ptr = reinterpret_cast<const tflite::TopKV2Options *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SplitOptions: {
            auto ptr = reinterpret_cast<const tflite::SplitOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_LogSoftmaxOptions: {
            auto ptr = reinterpret_cast<const tflite::LogSoftmaxOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_CastOptions: {
            auto ptr = reinterpret_cast<const tflite::CastOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_DequantizeOptions: {
            auto ptr = reinterpret_cast<const tflite::DequantizeOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_MaximumMinimumOptions: {
            auto ptr = reinterpret_cast<const tflite::MaximumMinimumOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_ArgMaxOptions: {
            auto ptr = reinterpret_cast<const tflite::ArgMaxOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_LessOptions: {
            auto ptr = reinterpret_cast<const tflite::LessOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_NegOptions: {
            auto ptr = reinterpret_cast<const tflite::NegOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_PadV2Options: {
            auto ptr = reinterpret_cast<const tflite::PadV2Options *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_GreaterOptions: {
            auto ptr = reinterpret_cast<const tflite::GreaterOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_GreaterEqualOptions: {
            auto ptr = reinterpret_cast<const tflite::GreaterEqualOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_LessEqualOptions: {
            auto ptr = reinterpret_cast<const tflite::LessEqualOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SelectOptions: {
            auto ptr = reinterpret_cast<const tflite::SelectOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SliceOptions: {
            auto ptr = reinterpret_cast<const tflite::SliceOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_TransposeConvOptions: {
            auto ptr = reinterpret_cast<const tflite::TransposeConvOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SparseToDenseOptions: {
            auto ptr = reinterpret_cast<const tflite::SparseToDenseOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_TileOptions: {
            auto ptr = reinterpret_cast<const tflite::TileOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_ExpandDimsOptions: {
            auto ptr = reinterpret_cast<const tflite::ExpandDimsOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_EqualOptions: {
            auto ptr = reinterpret_cast<const tflite::EqualOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_NotEqualOptions: {
            auto ptr = reinterpret_cast<const tflite::NotEqualOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_ShapeOptions: {
            auto ptr = reinterpret_cast<const tflite::ShapeOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_PowOptions: {
            auto ptr = reinterpret_cast<const tflite::PowOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_ArgMinOptions: {
            auto ptr = reinterpret_cast<const tflite::ArgMinOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_FakeQuantOptions: {
            auto ptr = reinterpret_cast<const tflite::FakeQuantOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_PackOptions: {
            auto ptr = reinterpret_cast<const tflite::PackOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_LogicalOrOptions: {
            auto ptr = reinterpret_cast<const tflite::LogicalOrOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_OneHotOptions: {
            auto ptr = reinterpret_cast<const tflite::OneHotOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_LogicalAndOptions: {
            auto ptr = reinterpret_cast<const tflite::LogicalAndOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_LogicalNotOptions: {
            auto ptr = reinterpret_cast<const tflite::LogicalNotOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_UnpackOptions: {
            auto ptr = reinterpret_cast<const tflite::UnpackOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_FloorDivOptions: {
            auto ptr = reinterpret_cast<const tflite::FloorDivOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SquareOptions: {
            auto ptr = reinterpret_cast<const tflite::SquareOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_ZerosLikeOptions: {
            auto ptr = reinterpret_cast<const tflite::ZerosLikeOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_FillOptions: {
            auto ptr = reinterpret_cast<const tflite::FillOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
            auto ptr = reinterpret_cast<const tflite::BidirectionalSequenceLSTMOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_BidirectionalSequenceRNNOptions: {
            auto ptr = reinterpret_cast<const tflite::BidirectionalSequenceRNNOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
            auto ptr = reinterpret_cast<const tflite::UnidirectionalSequenceLSTMOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_FloorModOptions: {
            auto ptr = reinterpret_cast<const tflite::FloorModOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_RangeOptions: {
            auto ptr = reinterpret_cast<const tflite::RangeOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_ResizeNearestNeighborOptions: {
            auto ptr = reinterpret_cast<const tflite::ResizeNearestNeighborOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_LeakyReluOptions: {
            auto ptr = reinterpret_cast<const tflite::LeakyReluOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SquaredDifferenceOptions: {
            auto ptr = reinterpret_cast<const tflite::SquaredDifferenceOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_MirrorPadOptions: {
            auto ptr = reinterpret_cast<const tflite::MirrorPadOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_AbsOptions: {
            auto ptr = reinterpret_cast<const tflite::AbsOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SplitVOptions: {
            auto ptr = reinterpret_cast<const tflite::SplitVOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_UniqueOptions: {
            auto ptr = reinterpret_cast<const tflite::UniqueOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_ReverseV2Options: {
            auto ptr = reinterpret_cast<const tflite::ReverseV2Options *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_AddNOptions: {
            auto ptr = reinterpret_cast<const tflite::AddNOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_GatherNdOptions: {
            auto ptr = reinterpret_cast<const tflite::GatherNdOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_CosOptions: {
            auto ptr = reinterpret_cast<const tflite::CosOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_WhereOptions: {
            auto ptr = reinterpret_cast<const tflite::WhereOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_RankOptions: {
            auto ptr = reinterpret_cast<const tflite::RankOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_ReverseSequenceOptions: {
            auto ptr = reinterpret_cast<const tflite::ReverseSequenceOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_MatrixDiagOptions: {
            auto ptr = reinterpret_cast<const tflite::MatrixDiagOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_QuantizeOptions: {
            auto ptr = reinterpret_cast<const tflite::QuantizeOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_MatrixSetDiagOptions: {
            auto ptr = reinterpret_cast<const tflite::MatrixSetDiagOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_HardSwishOptions: {
            auto ptr = reinterpret_cast<const tflite::HardSwishOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_IfOptions: {
            auto ptr = reinterpret_cast<const tflite::IfOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_WhileOptions: {
            auto ptr = reinterpret_cast<const tflite::WhileOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_DepthToSpaceOptions: {
            auto ptr = reinterpret_cast<const tflite::DepthToSpaceOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_NonMaxSuppressionV4Options: {
            auto ptr = reinterpret_cast<const tflite::NonMaxSuppressionV4Options *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_NonMaxSuppressionV5Options: {
            auto ptr = reinterpret_cast<const tflite::NonMaxSuppressionV5Options *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_ScatterNdOptions: {
            auto ptr = reinterpret_cast<const tflite::ScatterNdOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SelectV2Options: {
            auto ptr = reinterpret_cast<const tflite::SelectV2Options *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_DensifyOptions: {
            auto ptr = reinterpret_cast<const tflite::DensifyOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SegmentSumOptions: {
            auto ptr = reinterpret_cast<const tflite::SegmentSumOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_BatchMatMulOptions: {
            auto ptr = reinterpret_cast<const tflite::BatchMatMulOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        default:
            return nullptr;
    }
}

inline flatbuffers::Offset<void> BuiltinOptionsUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                           const flatbuffers::rehasher_function_t *_rehasher) const {
    switch (type) {
        case BuiltinOptions_Conv2DOptions: {
            auto ptr = reinterpret_cast<const tflite::Conv2DOptionsT *>(value);
            return CreateConv2DOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_DepthwiseConv2DOptions: {
            auto ptr = reinterpret_cast<const tflite::DepthwiseConv2DOptionsT *>(value);
            return CreateDepthwiseConv2DOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_ConcatEmbeddingsOptions: {
            auto ptr = reinterpret_cast<const tflite::ConcatEmbeddingsOptionsT *>(value);
            return CreateConcatEmbeddingsOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_LSHProjectionOptions: {
            auto ptr = reinterpret_cast<const tflite::LSHProjectionOptionsT *>(value);
            return CreateLSHProjectionOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_Pool2DOptions: {
            auto ptr = reinterpret_cast<const tflite::Pool2DOptionsT *>(value);
            return CreatePool2DOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SVDFOptions: {
            auto ptr = reinterpret_cast<const tflite::SVDFOptionsT *>(value);
            return CreateSVDFOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_RNNOptions: {
            auto ptr = reinterpret_cast<const tflite::RNNOptionsT *>(value);
            return CreateRNNOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_FullyConnectedOptions: {
            auto ptr = reinterpret_cast<const tflite::FullyConnectedOptionsT *>(value);
            return CreateFullyConnectedOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SoftmaxOptions: {
            auto ptr = reinterpret_cast<const tflite::SoftmaxOptionsT *>(value);
            return CreateSoftmaxOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_ConcatenationOptions: {
            auto ptr = reinterpret_cast<const tflite::ConcatenationOptionsT *>(value);
            return CreateConcatenationOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_AddOptions: {
            auto ptr = reinterpret_cast<const tflite::AddOptionsT *>(value);
            return CreateAddOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_L2NormOptions: {
            auto ptr = reinterpret_cast<const tflite::L2NormOptionsT *>(value);
            return CreateL2NormOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_LocalResponseNormalizationOptions: {
            auto ptr = reinterpret_cast<const tflite::LocalResponseNormalizationOptionsT *>(value);
            return CreateLocalResponseNormalizationOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_LSTMOptions: {
            auto ptr = reinterpret_cast<const tflite::LSTMOptionsT *>(value);
            return CreateLSTMOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_ResizeBilinearOptions: {
            auto ptr = reinterpret_cast<const tflite::ResizeBilinearOptionsT *>(value);
            return CreateResizeBilinearOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_CallOptions: {
            auto ptr = reinterpret_cast<const tflite::CallOptionsT *>(value);
            return CreateCallOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_ReshapeOptions: {
            auto ptr = reinterpret_cast<const tflite::ReshapeOptionsT *>(value);
            return CreateReshapeOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SkipGramOptions: {
            auto ptr = reinterpret_cast<const tflite::SkipGramOptionsT *>(value);
            return CreateSkipGramOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SpaceToDepthOptions: {
            auto ptr = reinterpret_cast<const tflite::SpaceToDepthOptionsT *>(value);
            return CreateSpaceToDepthOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_EmbeddingLookupSparseOptions: {
            auto ptr = reinterpret_cast<const tflite::EmbeddingLookupSparseOptionsT *>(value);
            return CreateEmbeddingLookupSparseOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_MulOptions: {
            auto ptr = reinterpret_cast<const tflite::MulOptionsT *>(value);
            return CreateMulOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_PadOptions: {
            auto ptr = reinterpret_cast<const tflite::PadOptionsT *>(value);
            return CreatePadOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_GatherOptions: {
            auto ptr = reinterpret_cast<const tflite::GatherOptionsT *>(value);
            return CreateGatherOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_BatchToSpaceNDOptions: {
            auto ptr = reinterpret_cast<const tflite::BatchToSpaceNDOptionsT *>(value);
            return CreateBatchToSpaceNDOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SpaceToBatchNDOptions: {
            auto ptr = reinterpret_cast<const tflite::SpaceToBatchNDOptionsT *>(value);
            return CreateSpaceToBatchNDOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_TransposeOptions: {
            auto ptr = reinterpret_cast<const tflite::TransposeOptionsT *>(value);
            return CreateTransposeOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_ReducerOptions: {
            auto ptr = reinterpret_cast<const tflite::ReducerOptionsT *>(value);
            return CreateReducerOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SubOptions: {
            auto ptr = reinterpret_cast<const tflite::SubOptionsT *>(value);
            return CreateSubOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_DivOptions: {
            auto ptr = reinterpret_cast<const tflite::DivOptionsT *>(value);
            return CreateDivOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SqueezeOptions: {
            auto ptr = reinterpret_cast<const tflite::SqueezeOptionsT *>(value);
            return CreateSqueezeOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SequenceRNNOptions: {
            auto ptr = reinterpret_cast<const tflite::SequenceRNNOptionsT *>(value);
            return CreateSequenceRNNOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_StridedSliceOptions: {
            auto ptr = reinterpret_cast<const tflite::StridedSliceOptionsT *>(value);
            return CreateStridedSliceOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_ExpOptions: {
            auto ptr = reinterpret_cast<const tflite::ExpOptionsT *>(value);
            return CreateExpOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_TopKV2Options: {
            auto ptr = reinterpret_cast<const tflite::TopKV2OptionsT *>(value);
            return CreateTopKV2Options(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SplitOptions: {
            auto ptr = reinterpret_cast<const tflite::SplitOptionsT *>(value);
            return CreateSplitOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_LogSoftmaxOptions: {
            auto ptr = reinterpret_cast<const tflite::LogSoftmaxOptionsT *>(value);
            return CreateLogSoftmaxOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_CastOptions: {
            auto ptr = reinterpret_cast<const tflite::CastOptionsT *>(value);
            return CreateCastOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_DequantizeOptions: {
            auto ptr = reinterpret_cast<const tflite::DequantizeOptionsT *>(value);
            return CreateDequantizeOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_MaximumMinimumOptions: {
            auto ptr = reinterpret_cast<const tflite::MaximumMinimumOptionsT *>(value);
            return CreateMaximumMinimumOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_ArgMaxOptions: {
            auto ptr = reinterpret_cast<const tflite::ArgMaxOptionsT *>(value);
            return CreateArgMaxOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_LessOptions: {
            auto ptr = reinterpret_cast<const tflite::LessOptionsT *>(value);
            return CreateLessOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_NegOptions: {
            auto ptr = reinterpret_cast<const tflite::NegOptionsT *>(value);
            return CreateNegOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_PadV2Options: {
            auto ptr = reinterpret_cast<const tflite::PadV2OptionsT *>(value);
            return CreatePadV2Options(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_GreaterOptions: {
            auto ptr = reinterpret_cast<const tflite::GreaterOptionsT *>(value);
            return CreateGreaterOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_GreaterEqualOptions: {
            auto ptr = reinterpret_cast<const tflite::GreaterEqualOptionsT *>(value);
            return CreateGreaterEqualOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_LessEqualOptions: {
            auto ptr = reinterpret_cast<const tflite::LessEqualOptionsT *>(value);
            return CreateLessEqualOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SelectOptions: {
            auto ptr = reinterpret_cast<const tflite::SelectOptionsT *>(value);
            return CreateSelectOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SliceOptions: {
            auto ptr = reinterpret_cast<const tflite::SliceOptionsT *>(value);
            return CreateSliceOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_TransposeConvOptions: {
            auto ptr = reinterpret_cast<const tflite::TransposeConvOptionsT *>(value);
            return CreateTransposeConvOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SparseToDenseOptions: {
            auto ptr = reinterpret_cast<const tflite::SparseToDenseOptionsT *>(value);
            return CreateSparseToDenseOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_TileOptions: {
            auto ptr = reinterpret_cast<const tflite::TileOptionsT *>(value);
            return CreateTileOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_ExpandDimsOptions: {
            auto ptr = reinterpret_cast<const tflite::ExpandDimsOptionsT *>(value);
            return CreateExpandDimsOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_EqualOptions: {
            auto ptr = reinterpret_cast<const tflite::EqualOptionsT *>(value);
            return CreateEqualOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_NotEqualOptions: {
            auto ptr = reinterpret_cast<const tflite::NotEqualOptionsT *>(value);
            return CreateNotEqualOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_ShapeOptions: {
            auto ptr = reinterpret_cast<const tflite::ShapeOptionsT *>(value);
            return CreateShapeOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_PowOptions: {
            auto ptr = reinterpret_cast<const tflite::PowOptionsT *>(value);
            return CreatePowOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_ArgMinOptions: {
            auto ptr = reinterpret_cast<const tflite::ArgMinOptionsT *>(value);
            return CreateArgMinOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_FakeQuantOptions: {
            auto ptr = reinterpret_cast<const tflite::FakeQuantOptionsT *>(value);
            return CreateFakeQuantOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_PackOptions: {
            auto ptr = reinterpret_cast<const tflite::PackOptionsT *>(value);
            return CreatePackOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_LogicalOrOptions: {
            auto ptr = reinterpret_cast<const tflite::LogicalOrOptionsT *>(value);
            return CreateLogicalOrOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_OneHotOptions: {
            auto ptr = reinterpret_cast<const tflite::OneHotOptionsT *>(value);
            return CreateOneHotOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_LogicalAndOptions: {
            auto ptr = reinterpret_cast<const tflite::LogicalAndOptionsT *>(value);
            return CreateLogicalAndOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_LogicalNotOptions: {
            auto ptr = reinterpret_cast<const tflite::LogicalNotOptionsT *>(value);
            return CreateLogicalNotOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_UnpackOptions: {
            auto ptr = reinterpret_cast<const tflite::UnpackOptionsT *>(value);
            return CreateUnpackOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_FloorDivOptions: {
            auto ptr = reinterpret_cast<const tflite::FloorDivOptionsT *>(value);
            return CreateFloorDivOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SquareOptions: {
            auto ptr = reinterpret_cast<const tflite::SquareOptionsT *>(value);
            return CreateSquareOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_ZerosLikeOptions: {
            auto ptr = reinterpret_cast<const tflite::ZerosLikeOptionsT *>(value);
            return CreateZerosLikeOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_FillOptions: {
            auto ptr = reinterpret_cast<const tflite::FillOptionsT *>(value);
            return CreateFillOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
            auto ptr = reinterpret_cast<const tflite::BidirectionalSequenceLSTMOptionsT *>(value);
            return CreateBidirectionalSequenceLSTMOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_BidirectionalSequenceRNNOptions: {
            auto ptr = reinterpret_cast<const tflite::BidirectionalSequenceRNNOptionsT *>(value);
            return CreateBidirectionalSequenceRNNOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
            auto ptr = reinterpret_cast<const tflite::UnidirectionalSequenceLSTMOptionsT *>(value);
            return CreateUnidirectionalSequenceLSTMOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_FloorModOptions: {
            auto ptr = reinterpret_cast<const tflite::FloorModOptionsT *>(value);
            return CreateFloorModOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_RangeOptions: {
            auto ptr = reinterpret_cast<const tflite::RangeOptionsT *>(value);
            return CreateRangeOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_ResizeNearestNeighborOptions: {
            auto ptr = reinterpret_cast<const tflite::ResizeNearestNeighborOptionsT *>(value);
            return CreateResizeNearestNeighborOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_LeakyReluOptions: {
            auto ptr = reinterpret_cast<const tflite::LeakyReluOptionsT *>(value);
            return CreateLeakyReluOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SquaredDifferenceOptions: {
            auto ptr = reinterpret_cast<const tflite::SquaredDifferenceOptionsT *>(value);
            return CreateSquaredDifferenceOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_MirrorPadOptions: {
            auto ptr = reinterpret_cast<const tflite::MirrorPadOptionsT *>(value);
            return CreateMirrorPadOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_AbsOptions: {
            auto ptr = reinterpret_cast<const tflite::AbsOptionsT *>(value);
            return CreateAbsOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SplitVOptions: {
            auto ptr = reinterpret_cast<const tflite::SplitVOptionsT *>(value);
            return CreateSplitVOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_UniqueOptions: {
            auto ptr = reinterpret_cast<const tflite::UniqueOptionsT *>(value);
            return CreateUniqueOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_ReverseV2Options: {
            auto ptr = reinterpret_cast<const tflite::ReverseV2OptionsT *>(value);
            return CreateReverseV2Options(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_AddNOptions: {
            auto ptr = reinterpret_cast<const tflite::AddNOptionsT *>(value);
            return CreateAddNOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_GatherNdOptions: {
            auto ptr = reinterpret_cast<const tflite::GatherNdOptionsT *>(value);
            return CreateGatherNdOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_CosOptions: {
            auto ptr = reinterpret_cast<const tflite::CosOptionsT *>(value);
            return CreateCosOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_WhereOptions: {
            auto ptr = reinterpret_cast<const tflite::WhereOptionsT *>(value);
            return CreateWhereOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_RankOptions: {
            auto ptr = reinterpret_cast<const tflite::RankOptionsT *>(value);
            return CreateRankOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_ReverseSequenceOptions: {
            auto ptr = reinterpret_cast<const tflite::ReverseSequenceOptionsT *>(value);
            return CreateReverseSequenceOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_MatrixDiagOptions: {
            auto ptr = reinterpret_cast<const tflite::MatrixDiagOptionsT *>(value);
            return CreateMatrixDiagOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_QuantizeOptions: {
            auto ptr = reinterpret_cast<const tflite::QuantizeOptionsT *>(value);
            return CreateQuantizeOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_MatrixSetDiagOptions: {
            auto ptr = reinterpret_cast<const tflite::MatrixSetDiagOptionsT *>(value);
            return CreateMatrixSetDiagOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_HardSwishOptions: {
            auto ptr = reinterpret_cast<const tflite::HardSwishOptionsT *>(value);
            return CreateHardSwishOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_IfOptions: {
            auto ptr = reinterpret_cast<const tflite::IfOptionsT *>(value);
            return CreateIfOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_WhileOptions: {
            auto ptr = reinterpret_cast<const tflite::WhileOptionsT *>(value);
            return CreateWhileOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_DepthToSpaceOptions: {
            auto ptr = reinterpret_cast<const tflite::DepthToSpaceOptionsT *>(value);
            return CreateDepthToSpaceOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_NonMaxSuppressionV4Options: {
            auto ptr = reinterpret_cast<const tflite::NonMaxSuppressionV4OptionsT *>(value);
            return CreateNonMaxSuppressionV4Options(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_NonMaxSuppressionV5Options: {
            auto ptr = reinterpret_cast<const tflite::NonMaxSuppressionV5OptionsT *>(value);
            return CreateNonMaxSuppressionV5Options(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_ScatterNdOptions: {
            auto ptr = reinterpret_cast<const tflite::ScatterNdOptionsT *>(value);
            return CreateScatterNdOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SelectV2Options: {
            auto ptr = reinterpret_cast<const tflite::SelectV2OptionsT *>(value);
            return CreateSelectV2Options(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_DensifyOptions: {
            auto ptr = reinterpret_cast<const tflite::DensifyOptionsT *>(value);
            return CreateDensifyOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SegmentSumOptions: {
            auto ptr = reinterpret_cast<const tflite::SegmentSumOptionsT *>(value);
            return CreateSegmentSumOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_BatchMatMulOptions: {
            auto ptr = reinterpret_cast<const tflite::BatchMatMulOptionsT *>(value);
            return CreateBatchMatMulOptions(_fbb, ptr, _rehasher).Union();
        }
        default:
            return 0;
    }
}

inline BuiltinOptionsUnion::BuiltinOptionsUnion(const BuiltinOptionsUnion &u) : type(u.type), value(nullptr) {
    switch (type) {
        case BuiltinOptions_Conv2DOptions: {
            value = new tflite::Conv2DOptionsT(*reinterpret_cast<tflite::Conv2DOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_DepthwiseConv2DOptions: {
            value = new tflite::DepthwiseConv2DOptionsT(*reinterpret_cast<tflite::DepthwiseConv2DOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_ConcatEmbeddingsOptions: {
            value =
                new tflite::ConcatEmbeddingsOptionsT(*reinterpret_cast<tflite::ConcatEmbeddingsOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_LSHProjectionOptions: {
            value = new tflite::LSHProjectionOptionsT(*reinterpret_cast<tflite::LSHProjectionOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_Pool2DOptions: {
            value = new tflite::Pool2DOptionsT(*reinterpret_cast<tflite::Pool2DOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SVDFOptions: {
            value = new tflite::SVDFOptionsT(*reinterpret_cast<tflite::SVDFOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_RNNOptions: {
            value = new tflite::RNNOptionsT(*reinterpret_cast<tflite::RNNOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_FullyConnectedOptions: {
            value = new tflite::FullyConnectedOptionsT(*reinterpret_cast<tflite::FullyConnectedOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SoftmaxOptions: {
            value = new tflite::SoftmaxOptionsT(*reinterpret_cast<tflite::SoftmaxOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_ConcatenationOptions: {
            value = new tflite::ConcatenationOptionsT(*reinterpret_cast<tflite::ConcatenationOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_AddOptions: {
            value = new tflite::AddOptionsT(*reinterpret_cast<tflite::AddOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_L2NormOptions: {
            value = new tflite::L2NormOptionsT(*reinterpret_cast<tflite::L2NormOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_LocalResponseNormalizationOptions: {
            value = new tflite::LocalResponseNormalizationOptionsT(
                *reinterpret_cast<tflite::LocalResponseNormalizationOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_LSTMOptions: {
            value = new tflite::LSTMOptionsT(*reinterpret_cast<tflite::LSTMOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_ResizeBilinearOptions: {
            value = new tflite::ResizeBilinearOptionsT(*reinterpret_cast<tflite::ResizeBilinearOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_CallOptions: {
            value = new tflite::CallOptionsT(*reinterpret_cast<tflite::CallOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_ReshapeOptions: {
            value = new tflite::ReshapeOptionsT(*reinterpret_cast<tflite::ReshapeOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SkipGramOptions: {
            value = new tflite::SkipGramOptionsT(*reinterpret_cast<tflite::SkipGramOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SpaceToDepthOptions: {
            value = new tflite::SpaceToDepthOptionsT(*reinterpret_cast<tflite::SpaceToDepthOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_EmbeddingLookupSparseOptions: {
            value = new tflite::EmbeddingLookupSparseOptionsT(
                *reinterpret_cast<tflite::EmbeddingLookupSparseOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_MulOptions: {
            value = new tflite::MulOptionsT(*reinterpret_cast<tflite::MulOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_PadOptions: {
            value = new tflite::PadOptionsT(*reinterpret_cast<tflite::PadOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_GatherOptions: {
            value = new tflite::GatherOptionsT(*reinterpret_cast<tflite::GatherOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_BatchToSpaceNDOptions: {
            value = new tflite::BatchToSpaceNDOptionsT(*reinterpret_cast<tflite::BatchToSpaceNDOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SpaceToBatchNDOptions: {
            value = new tflite::SpaceToBatchNDOptionsT(*reinterpret_cast<tflite::SpaceToBatchNDOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_TransposeOptions: {
            value = new tflite::TransposeOptionsT(*reinterpret_cast<tflite::TransposeOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_ReducerOptions: {
            value = new tflite::ReducerOptionsT(*reinterpret_cast<tflite::ReducerOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SubOptions: {
            value = new tflite::SubOptionsT(*reinterpret_cast<tflite::SubOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_DivOptions: {
            value = new tflite::DivOptionsT(*reinterpret_cast<tflite::DivOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SqueezeOptions: {
            value = new tflite::SqueezeOptionsT(*reinterpret_cast<tflite::SqueezeOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SequenceRNNOptions: {
            value = new tflite::SequenceRNNOptionsT(*reinterpret_cast<tflite::SequenceRNNOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_StridedSliceOptions: {
            value = new tflite::StridedSliceOptionsT(*reinterpret_cast<tflite::StridedSliceOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_ExpOptions: {
            value = new tflite::ExpOptionsT(*reinterpret_cast<tflite::ExpOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_TopKV2Options: {
            value = new tflite::TopKV2OptionsT(*reinterpret_cast<tflite::TopKV2OptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SplitOptions: {
            value = new tflite::SplitOptionsT(*reinterpret_cast<tflite::SplitOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_LogSoftmaxOptions: {
            value = new tflite::LogSoftmaxOptionsT(*reinterpret_cast<tflite::LogSoftmaxOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_CastOptions: {
            value = new tflite::CastOptionsT(*reinterpret_cast<tflite::CastOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_DequantizeOptions: {
            value = new tflite::DequantizeOptionsT(*reinterpret_cast<tflite::DequantizeOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_MaximumMinimumOptions: {
            value = new tflite::MaximumMinimumOptionsT(*reinterpret_cast<tflite::MaximumMinimumOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_ArgMaxOptions: {
            value = new tflite::ArgMaxOptionsT(*reinterpret_cast<tflite::ArgMaxOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_LessOptions: {
            value = new tflite::LessOptionsT(*reinterpret_cast<tflite::LessOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_NegOptions: {
            value = new tflite::NegOptionsT(*reinterpret_cast<tflite::NegOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_PadV2Options: {
            value = new tflite::PadV2OptionsT(*reinterpret_cast<tflite::PadV2OptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_GreaterOptions: {
            value = new tflite::GreaterOptionsT(*reinterpret_cast<tflite::GreaterOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_GreaterEqualOptions: {
            value = new tflite::GreaterEqualOptionsT(*reinterpret_cast<tflite::GreaterEqualOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_LessEqualOptions: {
            value = new tflite::LessEqualOptionsT(*reinterpret_cast<tflite::LessEqualOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SelectOptions: {
            value = new tflite::SelectOptionsT(*reinterpret_cast<tflite::SelectOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SliceOptions: {
            value = new tflite::SliceOptionsT(*reinterpret_cast<tflite::SliceOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_TransposeConvOptions: {
            value = new tflite::TransposeConvOptionsT(*reinterpret_cast<tflite::TransposeConvOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SparseToDenseOptions: {
            value = new tflite::SparseToDenseOptionsT(*reinterpret_cast<tflite::SparseToDenseOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_TileOptions: {
            value = new tflite::TileOptionsT(*reinterpret_cast<tflite::TileOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_ExpandDimsOptions: {
            value = new tflite::ExpandDimsOptionsT(*reinterpret_cast<tflite::ExpandDimsOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_EqualOptions: {
            value = new tflite::EqualOptionsT(*reinterpret_cast<tflite::EqualOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_NotEqualOptions: {
            value = new tflite::NotEqualOptionsT(*reinterpret_cast<tflite::NotEqualOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_ShapeOptions: {
            value = new tflite::ShapeOptionsT(*reinterpret_cast<tflite::ShapeOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_PowOptions: {
            value = new tflite::PowOptionsT(*reinterpret_cast<tflite::PowOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_ArgMinOptions: {
            value = new tflite::ArgMinOptionsT(*reinterpret_cast<tflite::ArgMinOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_FakeQuantOptions: {
            value = new tflite::FakeQuantOptionsT(*reinterpret_cast<tflite::FakeQuantOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_PackOptions: {
            value = new tflite::PackOptionsT(*reinterpret_cast<tflite::PackOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_LogicalOrOptions: {
            value = new tflite::LogicalOrOptionsT(*reinterpret_cast<tflite::LogicalOrOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_OneHotOptions: {
            value = new tflite::OneHotOptionsT(*reinterpret_cast<tflite::OneHotOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_LogicalAndOptions: {
            value = new tflite::LogicalAndOptionsT(*reinterpret_cast<tflite::LogicalAndOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_LogicalNotOptions: {
            value = new tflite::LogicalNotOptionsT(*reinterpret_cast<tflite::LogicalNotOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_UnpackOptions: {
            value = new tflite::UnpackOptionsT(*reinterpret_cast<tflite::UnpackOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_FloorDivOptions: {
            value = new tflite::FloorDivOptionsT(*reinterpret_cast<tflite::FloorDivOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SquareOptions: {
            value = new tflite::SquareOptionsT(*reinterpret_cast<tflite::SquareOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_ZerosLikeOptions: {
            value = new tflite::ZerosLikeOptionsT(*reinterpret_cast<tflite::ZerosLikeOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_FillOptions: {
            value = new tflite::FillOptionsT(*reinterpret_cast<tflite::FillOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
            value = new tflite::BidirectionalSequenceLSTMOptionsT(
                *reinterpret_cast<tflite::BidirectionalSequenceLSTMOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_BidirectionalSequenceRNNOptions: {
            value = new tflite::BidirectionalSequenceRNNOptionsT(
                *reinterpret_cast<tflite::BidirectionalSequenceRNNOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
            value = new tflite::UnidirectionalSequenceLSTMOptionsT(
                *reinterpret_cast<tflite::UnidirectionalSequenceLSTMOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_FloorModOptions: {
            value = new tflite::FloorModOptionsT(*reinterpret_cast<tflite::FloorModOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_RangeOptions: {
            value = new tflite::RangeOptionsT(*reinterpret_cast<tflite::RangeOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_ResizeNearestNeighborOptions: {
            value = new tflite::ResizeNearestNeighborOptionsT(
                *reinterpret_cast<tflite::ResizeNearestNeighborOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_LeakyReluOptions: {
            value = new tflite::LeakyReluOptionsT(*reinterpret_cast<tflite::LeakyReluOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SquaredDifferenceOptions: {
            value =
                new tflite::SquaredDifferenceOptionsT(*reinterpret_cast<tflite::SquaredDifferenceOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_MirrorPadOptions: {
            value = new tflite::MirrorPadOptionsT(*reinterpret_cast<tflite::MirrorPadOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_AbsOptions: {
            value = new tflite::AbsOptionsT(*reinterpret_cast<tflite::AbsOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SplitVOptions: {
            value = new tflite::SplitVOptionsT(*reinterpret_cast<tflite::SplitVOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_UniqueOptions: {
            value = new tflite::UniqueOptionsT(*reinterpret_cast<tflite::UniqueOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_ReverseV2Options: {
            value = new tflite::ReverseV2OptionsT(*reinterpret_cast<tflite::ReverseV2OptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_AddNOptions: {
            value = new tflite::AddNOptionsT(*reinterpret_cast<tflite::AddNOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_GatherNdOptions: {
            value = new tflite::GatherNdOptionsT(*reinterpret_cast<tflite::GatherNdOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_CosOptions: {
            value = new tflite::CosOptionsT(*reinterpret_cast<tflite::CosOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_WhereOptions: {
            value = new tflite::WhereOptionsT(*reinterpret_cast<tflite::WhereOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_RankOptions: {
            value = new tflite::RankOptionsT(*reinterpret_cast<tflite::RankOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_ReverseSequenceOptions: {
            value = new tflite::ReverseSequenceOptionsT(*reinterpret_cast<tflite::ReverseSequenceOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_MatrixDiagOptions: {
            value = new tflite::MatrixDiagOptionsT(*reinterpret_cast<tflite::MatrixDiagOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_QuantizeOptions: {
            value = new tflite::QuantizeOptionsT(*reinterpret_cast<tflite::QuantizeOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_MatrixSetDiagOptions: {
            value = new tflite::MatrixSetDiagOptionsT(*reinterpret_cast<tflite::MatrixSetDiagOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_HardSwishOptions: {
            value = new tflite::HardSwishOptionsT(*reinterpret_cast<tflite::HardSwishOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_IfOptions: {
            value = new tflite::IfOptionsT(*reinterpret_cast<tflite::IfOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_WhileOptions: {
            value = new tflite::WhileOptionsT(*reinterpret_cast<tflite::WhileOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_DepthToSpaceOptions: {
            value = new tflite::DepthToSpaceOptionsT(*reinterpret_cast<tflite::DepthToSpaceOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_NonMaxSuppressionV4Options: {
            value = new tflite::NonMaxSuppressionV4OptionsT(
                *reinterpret_cast<tflite::NonMaxSuppressionV4OptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_NonMaxSuppressionV5Options: {
            value = new tflite::NonMaxSuppressionV5OptionsT(
                *reinterpret_cast<tflite::NonMaxSuppressionV5OptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_ScatterNdOptions: {
            value = new tflite::ScatterNdOptionsT(*reinterpret_cast<tflite::ScatterNdOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SelectV2Options: {
            value = new tflite::SelectV2OptionsT(*reinterpret_cast<tflite::SelectV2OptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_DensifyOptions: {
            value = new tflite::DensifyOptionsT(*reinterpret_cast<tflite::DensifyOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SegmentSumOptions: {
            value = new tflite::SegmentSumOptionsT(*reinterpret_cast<tflite::SegmentSumOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_BatchMatMulOptions: {
            value = new tflite::BatchMatMulOptionsT(*reinterpret_cast<tflite::BatchMatMulOptionsT *>(u.value));
            break;
        }
        default:
            break;
    }
}

inline void BuiltinOptionsUnion::Reset() {
    switch (type) {
        case BuiltinOptions_Conv2DOptions: {
            auto ptr = reinterpret_cast<tflite::Conv2DOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_DepthwiseConv2DOptions: {
            auto ptr = reinterpret_cast<tflite::DepthwiseConv2DOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_ConcatEmbeddingsOptions: {
            auto ptr = reinterpret_cast<tflite::ConcatEmbeddingsOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_LSHProjectionOptions: {
            auto ptr = reinterpret_cast<tflite::LSHProjectionOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_Pool2DOptions: {
            auto ptr = reinterpret_cast<tflite::Pool2DOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SVDFOptions: {
            auto ptr = reinterpret_cast<tflite::SVDFOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_RNNOptions: {
            auto ptr = reinterpret_cast<tflite::RNNOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_FullyConnectedOptions: {
            auto ptr = reinterpret_cast<tflite::FullyConnectedOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SoftmaxOptions: {
            auto ptr = reinterpret_cast<tflite::SoftmaxOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_ConcatenationOptions: {
            auto ptr = reinterpret_cast<tflite::ConcatenationOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_AddOptions: {
            auto ptr = reinterpret_cast<tflite::AddOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_L2NormOptions: {
            auto ptr = reinterpret_cast<tflite::L2NormOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_LocalResponseNormalizationOptions: {
            auto ptr = reinterpret_cast<tflite::LocalResponseNormalizationOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_LSTMOptions: {
            auto ptr = reinterpret_cast<tflite::LSTMOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_ResizeBilinearOptions: {
            auto ptr = reinterpret_cast<tflite::ResizeBilinearOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_CallOptions: {
            auto ptr = reinterpret_cast<tflite::CallOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_ReshapeOptions: {
            auto ptr = reinterpret_cast<tflite::ReshapeOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SkipGramOptions: {
            auto ptr = reinterpret_cast<tflite::SkipGramOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SpaceToDepthOptions: {
            auto ptr = reinterpret_cast<tflite::SpaceToDepthOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_EmbeddingLookupSparseOptions: {
            auto ptr = reinterpret_cast<tflite::EmbeddingLookupSparseOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_MulOptions: {
            auto ptr = reinterpret_cast<tflite::MulOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_PadOptions: {
            auto ptr = reinterpret_cast<tflite::PadOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_GatherOptions: {
            auto ptr = reinterpret_cast<tflite::GatherOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_BatchToSpaceNDOptions: {
            auto ptr = reinterpret_cast<tflite::BatchToSpaceNDOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SpaceToBatchNDOptions: {
            auto ptr = reinterpret_cast<tflite::SpaceToBatchNDOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_TransposeOptions: {
            auto ptr = reinterpret_cast<tflite::TransposeOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_ReducerOptions: {
            auto ptr = reinterpret_cast<tflite::ReducerOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SubOptions: {
            auto ptr = reinterpret_cast<tflite::SubOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_DivOptions: {
            auto ptr = reinterpret_cast<tflite::DivOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SqueezeOptions: {
            auto ptr = reinterpret_cast<tflite::SqueezeOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SequenceRNNOptions: {
            auto ptr = reinterpret_cast<tflite::SequenceRNNOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_StridedSliceOptions: {
            auto ptr = reinterpret_cast<tflite::StridedSliceOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_ExpOptions: {
            auto ptr = reinterpret_cast<tflite::ExpOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_TopKV2Options: {
            auto ptr = reinterpret_cast<tflite::TopKV2OptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SplitOptions: {
            auto ptr = reinterpret_cast<tflite::SplitOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_LogSoftmaxOptions: {
            auto ptr = reinterpret_cast<tflite::LogSoftmaxOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_CastOptions: {
            auto ptr = reinterpret_cast<tflite::CastOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_DequantizeOptions: {
            auto ptr = reinterpret_cast<tflite::DequantizeOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_MaximumMinimumOptions: {
            auto ptr = reinterpret_cast<tflite::MaximumMinimumOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_ArgMaxOptions: {
            auto ptr = reinterpret_cast<tflite::ArgMaxOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_LessOptions: {
            auto ptr = reinterpret_cast<tflite::LessOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_NegOptions: {
            auto ptr = reinterpret_cast<tflite::NegOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_PadV2Options: {
            auto ptr = reinterpret_cast<tflite::PadV2OptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_GreaterOptions: {
            auto ptr = reinterpret_cast<tflite::GreaterOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_GreaterEqualOptions: {
            auto ptr = reinterpret_cast<tflite::GreaterEqualOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_LessEqualOptions: {
            auto ptr = reinterpret_cast<tflite::LessEqualOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SelectOptions: {
            auto ptr = reinterpret_cast<tflite::SelectOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SliceOptions: {
            auto ptr = reinterpret_cast<tflite::SliceOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_TransposeConvOptions: {
            auto ptr = reinterpret_cast<tflite::TransposeConvOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SparseToDenseOptions: {
            auto ptr = reinterpret_cast<tflite::SparseToDenseOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_TileOptions: {
            auto ptr = reinterpret_cast<tflite::TileOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_ExpandDimsOptions: {
            auto ptr = reinterpret_cast<tflite::ExpandDimsOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_EqualOptions: {
            auto ptr = reinterpret_cast<tflite::EqualOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_NotEqualOptions: {
            auto ptr = reinterpret_cast<tflite::NotEqualOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_ShapeOptions: {
            auto ptr = reinterpret_cast<tflite::ShapeOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_PowOptions: {
            auto ptr = reinterpret_cast<tflite::PowOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_ArgMinOptions: {
            auto ptr = reinterpret_cast<tflite::ArgMinOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_FakeQuantOptions: {
            auto ptr = reinterpret_cast<tflite::FakeQuantOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_PackOptions: {
            auto ptr = reinterpret_cast<tflite::PackOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_LogicalOrOptions: {
            auto ptr = reinterpret_cast<tflite::LogicalOrOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_OneHotOptions: {
            auto ptr = reinterpret_cast<tflite::OneHotOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_LogicalAndOptions: {
            auto ptr = reinterpret_cast<tflite::LogicalAndOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_LogicalNotOptions: {
            auto ptr = reinterpret_cast<tflite::LogicalNotOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_UnpackOptions: {
            auto ptr = reinterpret_cast<tflite::UnpackOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_FloorDivOptions: {
            auto ptr = reinterpret_cast<tflite::FloorDivOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SquareOptions: {
            auto ptr = reinterpret_cast<tflite::SquareOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_ZerosLikeOptions: {
            auto ptr = reinterpret_cast<tflite::ZerosLikeOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_FillOptions: {
            auto ptr = reinterpret_cast<tflite::FillOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
            auto ptr = reinterpret_cast<tflite::BidirectionalSequenceLSTMOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_BidirectionalSequenceRNNOptions: {
            auto ptr = reinterpret_cast<tflite::BidirectionalSequenceRNNOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
            auto ptr = reinterpret_cast<tflite::UnidirectionalSequenceLSTMOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_FloorModOptions: {
            auto ptr = reinterpret_cast<tflite::FloorModOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_RangeOptions: {
            auto ptr = reinterpret_cast<tflite::RangeOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_ResizeNearestNeighborOptions: {
            auto ptr = reinterpret_cast<tflite::ResizeNearestNeighborOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_LeakyReluOptions: {
            auto ptr = reinterpret_cast<tflite::LeakyReluOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SquaredDifferenceOptions: {
            auto ptr = reinterpret_cast<tflite::SquaredDifferenceOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_MirrorPadOptions: {
            auto ptr = reinterpret_cast<tflite::MirrorPadOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_AbsOptions: {
            auto ptr = reinterpret_cast<tflite::AbsOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SplitVOptions: {
            auto ptr = reinterpret_cast<tflite::SplitVOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_UniqueOptions: {
            auto ptr = reinterpret_cast<tflite::UniqueOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_ReverseV2Options: {
            auto ptr = reinterpret_cast<tflite::ReverseV2OptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_AddNOptions: {
            auto ptr = reinterpret_cast<tflite::AddNOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_GatherNdOptions: {
            auto ptr = reinterpret_cast<tflite::GatherNdOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_CosOptions: {
            auto ptr = reinterpret_cast<tflite::CosOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_WhereOptions: {
            auto ptr = reinterpret_cast<tflite::WhereOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_RankOptions: {
            auto ptr = reinterpret_cast<tflite::RankOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_ReverseSequenceOptions: {
            auto ptr = reinterpret_cast<tflite::ReverseSequenceOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_MatrixDiagOptions: {
            auto ptr = reinterpret_cast<tflite::MatrixDiagOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_QuantizeOptions: {
            auto ptr = reinterpret_cast<tflite::QuantizeOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_MatrixSetDiagOptions: {
            auto ptr = reinterpret_cast<tflite::MatrixSetDiagOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_HardSwishOptions: {
            auto ptr = reinterpret_cast<tflite::HardSwishOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_IfOptions: {
            auto ptr = reinterpret_cast<tflite::IfOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_WhileOptions: {
            auto ptr = reinterpret_cast<tflite::WhileOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_DepthToSpaceOptions: {
            auto ptr = reinterpret_cast<tflite::DepthToSpaceOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_NonMaxSuppressionV4Options: {
            auto ptr = reinterpret_cast<tflite::NonMaxSuppressionV4OptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_NonMaxSuppressionV5Options: {
            auto ptr = reinterpret_cast<tflite::NonMaxSuppressionV5OptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_ScatterNdOptions: {
            auto ptr = reinterpret_cast<tflite::ScatterNdOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SelectV2Options: {
            auto ptr = reinterpret_cast<tflite::SelectV2OptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_DensifyOptions: {
            auto ptr = reinterpret_cast<tflite::DensifyOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SegmentSumOptions: {
            auto ptr = reinterpret_cast<tflite::SegmentSumOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_BatchMatMulOptions: {
            auto ptr = reinterpret_cast<tflite::BatchMatMulOptionsT *>(value);
            delete ptr;
            break;
        }
        default:
            break;
    }
    value = nullptr;
    type  = BuiltinOptions_NONE;
}

inline const flatbuffers::TypeTable *TensorTypeTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::TensorTypeTypeTable};
    static const char *const names[]       = {"FLOAT32", "FLOAT16", "INT32",     "UINT8", "INT64",   "STRING",
                                        "BOOL",    "INT16",   "COMPLEX64", "INT8",  "FLOAT64", "COMPLEX128"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_ENUM, 12, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *QuantizationDetailsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_SEQUENCE, 0, -1},
                                                       {flatbuffers::ET_SEQUENCE, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::CustomQuantizationTypeTable};
    static const char *const names[]                   = {"NONE", "CustomQuantization"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_UNION, 2, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *DimensionTypeTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::DimensionTypeTypeTable};
    static const char *const names[]                   = {"DENSE", "SPARSE_CSR"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *SparseIndexVectorTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_SEQUENCE, 0, -1},
                                                       {flatbuffers::ET_SEQUENCE, 0, 0},
                                                       {flatbuffers::ET_SEQUENCE, 0, 1},
                                                       {flatbuffers::ET_SEQUENCE, 0, 2}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::Int32VectorTypeTable, tflite::Uint16VectorTypeTable,
                                                          tflite::Uint8VectorTypeTable};
    static const char *const names[]                   = {"NONE", "Int32Vector", "Uint16Vector", "Uint8Vector"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_UNION, 4, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *BuiltinOperatorTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::BuiltinOperatorTypeTable};
    static const char *const names[]                   = {"ADD",
                                        "AVERAGE_POOL_2D",
                                        "CONCATENATION",
                                        "CONV_2D",
                                        "DEPTHWISE_CONV_2D",
                                        "DEPTH_TO_SPACE",
                                        "DEQUANTIZE",
                                        "EMBEDDING_LOOKUP",
                                        "FLOOR",
                                        "FULLY_CONNECTED",
                                        "HASHTABLE_LOOKUP",
                                        "L2_NORMALIZATION",
                                        "L2_POOL_2D",
                                        "LOCAL_RESPONSE_NORMALIZATION",
                                        "LOGISTIC",
                                        "LSH_PROJECTION",
                                        "LSTM",
                                        "MAX_POOL_2D",
                                        "MUL",
                                        "RELU",
                                        "RELU_N1_TO_1",
                                        "RELU6",
                                        "RESHAPE",
                                        "RESIZE_BILINEAR",
                                        "RNN",
                                        "SOFTMAX",
                                        "SPACE_TO_DEPTH",
                                        "SVDF",
                                        "TANH",
                                        "CONCAT_EMBEDDINGS",
                                        "SKIP_GRAM",
                                        "CALL",
                                        "CUSTOM",
                                        "EMBEDDING_LOOKUP_SPARSE",
                                        "PAD",
                                        "UNIDIRECTIONAL_SEQUENCE_RNN",
                                        "GATHER",
                                        "BATCH_TO_SPACE_ND",
                                        "SPACE_TO_BATCH_ND",
                                        "TRANSPOSE",
                                        "MEAN",
                                        "SUB",
                                        "DIV",
                                        "SQUEEZE",
                                        "UNIDIRECTIONAL_SEQUENCE_LSTM",
                                        "STRIDED_SLICE",
                                        "BIDIRECTIONAL_SEQUENCE_RNN",
                                        "EXP",
                                        "TOPK_V2",
                                        "SPLIT",
                                        "LOG_SOFTMAX",
                                        "DELEGATE",
                                        "BIDIRECTIONAL_SEQUENCE_LSTM",
                                        "CAST",
                                        "PRELU",
                                        "MAXIMUM",
                                        "ARG_MAX",
                                        "MINIMUM",
                                        "LESS",
                                        "NEG",
                                        "PADV2",
                                        "GREATER",
                                        "GREATER_EQUAL",
                                        "LESS_EQUAL",
                                        "SELECT",
                                        "SLICE",
                                        "SIN",
                                        "TRANSPOSE_CONV",
                                        "SPARSE_TO_DENSE",
                                        "TILE",
                                        "EXPAND_DIMS",
                                        "EQUAL",
                                        "NOT_EQUAL",
                                        "LOG",
                                        "SUM",
                                        "SQRT",
                                        "RSQRT",
                                        "SHAPE",
                                        "POW",
                                        "ARG_MIN",
                                        "FAKE_QUANT",
                                        "REDUCE_PROD",
                                        "REDUCE_MAX",
                                        "PACK",
                                        "LOGICAL_OR",
                                        "ONE_HOT",
                                        "LOGICAL_AND",
                                        "LOGICAL_NOT",
                                        "UNPACK",
                                        "REDUCE_MIN",
                                        "FLOOR_DIV",
                                        "REDUCE_ANY",
                                        "SQUARE",
                                        "ZEROS_LIKE",
                                        "FILL",
                                        "FLOOR_MOD",
                                        "RANGE",
                                        "RESIZE_NEAREST_NEIGHBOR",
                                        "LEAKY_RELU",
                                        "SQUARED_DIFFERENCE",
                                        "MIRROR_PAD",
                                        "ABS",
                                        "SPLIT_V",
                                        "UNIQUE",
                                        "CEIL",
                                        "REVERSE_V2",
                                        "ADD_N",
                                        "GATHER_ND",
                                        "COS",
                                        "WHERE",
                                        "RANK",
                                        "ELU",
                                        "REVERSE_SEQUENCE",
                                        "MATRIX_DIAG",
                                        "QUANTIZE",
                                        "MATRIX_SET_DIAG",
                                        "ROUND",
                                        "HARD_SWISH",
                                        "IF",
                                        "WHILE",
                                        "NON_MAX_SUPPRESSION_V4",
                                        "NON_MAX_SUPPRESSION_V5",
                                        "SCATTER_ND",
                                        "SELECT_V2",
                                        "DENSIFY",
                                        "SEGMENT_SUM",
                                        "BATCH_MATMUL"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_ENUM, 127, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *BuiltinOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {
        {flatbuffers::ET_SEQUENCE, 0, -1}, {flatbuffers::ET_SEQUENCE, 0, 0},  {flatbuffers::ET_SEQUENCE, 0, 1},
        {flatbuffers::ET_SEQUENCE, 0, 2},  {flatbuffers::ET_SEQUENCE, 0, 3},  {flatbuffers::ET_SEQUENCE, 0, 4},
        {flatbuffers::ET_SEQUENCE, 0, 5},  {flatbuffers::ET_SEQUENCE, 0, 6},  {flatbuffers::ET_SEQUENCE, 0, 7},
        {flatbuffers::ET_SEQUENCE, 0, 8},  {flatbuffers::ET_SEQUENCE, 0, 9},  {flatbuffers::ET_SEQUENCE, 0, 10},
        {flatbuffers::ET_SEQUENCE, 0, 11}, {flatbuffers::ET_SEQUENCE, 0, 12}, {flatbuffers::ET_SEQUENCE, 0, 13},
        {flatbuffers::ET_SEQUENCE, 0, 14}, {flatbuffers::ET_SEQUENCE, 0, 15}, {flatbuffers::ET_SEQUENCE, 0, 16},
        {flatbuffers::ET_SEQUENCE, 0, 17}, {flatbuffers::ET_SEQUENCE, 0, 18}, {flatbuffers::ET_SEQUENCE, 0, 19},
        {flatbuffers::ET_SEQUENCE, 0, 20}, {flatbuffers::ET_SEQUENCE, 0, 21}, {flatbuffers::ET_SEQUENCE, 0, 22},
        {flatbuffers::ET_SEQUENCE, 0, 23}, {flatbuffers::ET_SEQUENCE, 0, 24}, {flatbuffers::ET_SEQUENCE, 0, 25},
        {flatbuffers::ET_SEQUENCE, 0, 26}, {flatbuffers::ET_SEQUENCE, 0, 27}, {flatbuffers::ET_SEQUENCE, 0, 28},
        {flatbuffers::ET_SEQUENCE, 0, 29}, {flatbuffers::ET_SEQUENCE, 0, 30}, {flatbuffers::ET_SEQUENCE, 0, 31},
        {flatbuffers::ET_SEQUENCE, 0, 32}, {flatbuffers::ET_SEQUENCE, 0, 33}, {flatbuffers::ET_SEQUENCE, 0, 34},
        {flatbuffers::ET_SEQUENCE, 0, 35}, {flatbuffers::ET_SEQUENCE, 0, 36}, {flatbuffers::ET_SEQUENCE, 0, 37},
        {flatbuffers::ET_SEQUENCE, 0, 38}, {flatbuffers::ET_SEQUENCE, 0, 39}, {flatbuffers::ET_SEQUENCE, 0, 40},
        {flatbuffers::ET_SEQUENCE, 0, 41}, {flatbuffers::ET_SEQUENCE, 0, 42}, {flatbuffers::ET_SEQUENCE, 0, 43},
        {flatbuffers::ET_SEQUENCE, 0, 44}, {flatbuffers::ET_SEQUENCE, 0, 45}, {flatbuffers::ET_SEQUENCE, 0, 46},
        {flatbuffers::ET_SEQUENCE, 0, 47}, {flatbuffers::ET_SEQUENCE, 0, 48}, {flatbuffers::ET_SEQUENCE, 0, 49},
        {flatbuffers::ET_SEQUENCE, 0, 50}, {flatbuffers::ET_SEQUENCE, 0, 51}, {flatbuffers::ET_SEQUENCE, 0, 52},
        {flatbuffers::ET_SEQUENCE, 0, 53}, {flatbuffers::ET_SEQUENCE, 0, 54}, {flatbuffers::ET_SEQUENCE, 0, 55},
        {flatbuffers::ET_SEQUENCE, 0, 56}, {flatbuffers::ET_SEQUENCE, 0, 57}, {flatbuffers::ET_SEQUENCE, 0, 58},
        {flatbuffers::ET_SEQUENCE, 0, 59}, {flatbuffers::ET_SEQUENCE, 0, 60}, {flatbuffers::ET_SEQUENCE, 0, 61},
        {flatbuffers::ET_SEQUENCE, 0, 62}, {flatbuffers::ET_SEQUENCE, 0, 63}, {flatbuffers::ET_SEQUENCE, 0, 64},
        {flatbuffers::ET_SEQUENCE, 0, 65}, {flatbuffers::ET_SEQUENCE, 0, 66}, {flatbuffers::ET_SEQUENCE, 0, 67},
        {flatbuffers::ET_SEQUENCE, 0, 68}, {flatbuffers::ET_SEQUENCE, 0, 69}, {flatbuffers::ET_SEQUENCE, 0, 70},
        {flatbuffers::ET_SEQUENCE, 0, 71}, {flatbuffers::ET_SEQUENCE, 0, 72}, {flatbuffers::ET_SEQUENCE, 0, 73},
        {flatbuffers::ET_SEQUENCE, 0, 74}, {flatbuffers::ET_SEQUENCE, 0, 75}, {flatbuffers::ET_SEQUENCE, 0, 76},
        {flatbuffers::ET_SEQUENCE, 0, 77}, {flatbuffers::ET_SEQUENCE, 0, 78}, {flatbuffers::ET_SEQUENCE, 0, 79},
        {flatbuffers::ET_SEQUENCE, 0, 80}, {flatbuffers::ET_SEQUENCE, 0, 81}, {flatbuffers::ET_SEQUENCE, 0, 82},
        {flatbuffers::ET_SEQUENCE, 0, 83}, {flatbuffers::ET_SEQUENCE, 0, 84}, {flatbuffers::ET_SEQUENCE, 0, 85},
        {flatbuffers::ET_SEQUENCE, 0, 86}, {flatbuffers::ET_SEQUENCE, 0, 87}, {flatbuffers::ET_SEQUENCE, 0, 88},
        {flatbuffers::ET_SEQUENCE, 0, 89}, {flatbuffers::ET_SEQUENCE, 0, 90}, {flatbuffers::ET_SEQUENCE, 0, 91},
        {flatbuffers::ET_SEQUENCE, 0, 92}, {flatbuffers::ET_SEQUENCE, 0, 93}, {flatbuffers::ET_SEQUENCE, 0, 94},
        {flatbuffers::ET_SEQUENCE, 0, 95}, {flatbuffers::ET_SEQUENCE, 0, 96}, {flatbuffers::ET_SEQUENCE, 0, 97},
        {flatbuffers::ET_SEQUENCE, 0, 98}, {flatbuffers::ET_SEQUENCE, 0, 99}, {flatbuffers::ET_SEQUENCE, 0, 100}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::Conv2DOptionsTypeTable,
                                                          tflite::DepthwiseConv2DOptionsTypeTable,
                                                          tflite::ConcatEmbeddingsOptionsTypeTable,
                                                          tflite::LSHProjectionOptionsTypeTable,
                                                          tflite::Pool2DOptionsTypeTable,
                                                          tflite::SVDFOptionsTypeTable,
                                                          tflite::RNNOptionsTypeTable,
                                                          tflite::FullyConnectedOptionsTypeTable,
                                                          tflite::SoftmaxOptionsTypeTable,
                                                          tflite::ConcatenationOptionsTypeTable,
                                                          tflite::AddOptionsTypeTable,
                                                          tflite::L2NormOptionsTypeTable,
                                                          tflite::LocalResponseNormalizationOptionsTypeTable,
                                                          tflite::LSTMOptionsTypeTable,
                                                          tflite::ResizeBilinearOptionsTypeTable,
                                                          tflite::CallOptionsTypeTable,
                                                          tflite::ReshapeOptionsTypeTable,
                                                          tflite::SkipGramOptionsTypeTable,
                                                          tflite::SpaceToDepthOptionsTypeTable,
                                                          tflite::EmbeddingLookupSparseOptionsTypeTable,
                                                          tflite::MulOptionsTypeTable,
                                                          tflite::PadOptionsTypeTable,
                                                          tflite::GatherOptionsTypeTable,
                                                          tflite::BatchToSpaceNDOptionsTypeTable,
                                                          tflite::SpaceToBatchNDOptionsTypeTable,
                                                          tflite::TransposeOptionsTypeTable,
                                                          tflite::ReducerOptionsTypeTable,
                                                          tflite::SubOptionsTypeTable,
                                                          tflite::DivOptionsTypeTable,
                                                          tflite::SqueezeOptionsTypeTable,
                                                          tflite::SequenceRNNOptionsTypeTable,
                                                          tflite::StridedSliceOptionsTypeTable,
                                                          tflite::ExpOptionsTypeTable,
                                                          tflite::TopKV2OptionsTypeTable,
                                                          tflite::SplitOptionsTypeTable,
                                                          tflite::LogSoftmaxOptionsTypeTable,
                                                          tflite::CastOptionsTypeTable,
                                                          tflite::DequantizeOptionsTypeTable,
                                                          tflite::MaximumMinimumOptionsTypeTable,
                                                          tflite::ArgMaxOptionsTypeTable,
                                                          tflite::LessOptionsTypeTable,
                                                          tflite::NegOptionsTypeTable,
                                                          tflite::PadV2OptionsTypeTable,
                                                          tflite::GreaterOptionsTypeTable,
                                                          tflite::GreaterEqualOptionsTypeTable,
                                                          tflite::LessEqualOptionsTypeTable,
                                                          tflite::SelectOptionsTypeTable,
                                                          tflite::SliceOptionsTypeTable,
                                                          tflite::TransposeConvOptionsTypeTable,
                                                          tflite::SparseToDenseOptionsTypeTable,
                                                          tflite::TileOptionsTypeTable,
                                                          tflite::ExpandDimsOptionsTypeTable,
                                                          tflite::EqualOptionsTypeTable,
                                                          tflite::NotEqualOptionsTypeTable,
                                                          tflite::ShapeOptionsTypeTable,
                                                          tflite::PowOptionsTypeTable,
                                                          tflite::ArgMinOptionsTypeTable,
                                                          tflite::FakeQuantOptionsTypeTable,
                                                          tflite::PackOptionsTypeTable,
                                                          tflite::LogicalOrOptionsTypeTable,
                                                          tflite::OneHotOptionsTypeTable,
                                                          tflite::LogicalAndOptionsTypeTable,
                                                          tflite::LogicalNotOptionsTypeTable,
                                                          tflite::UnpackOptionsTypeTable,
                                                          tflite::FloorDivOptionsTypeTable,
                                                          tflite::SquareOptionsTypeTable,
                                                          tflite::ZerosLikeOptionsTypeTable,
                                                          tflite::FillOptionsTypeTable,
                                                          tflite::BidirectionalSequenceLSTMOptionsTypeTable,
                                                          tflite::BidirectionalSequenceRNNOptionsTypeTable,
                                                          tflite::UnidirectionalSequenceLSTMOptionsTypeTable,
                                                          tflite::FloorModOptionsTypeTable,
                                                          tflite::RangeOptionsTypeTable,
                                                          tflite::ResizeNearestNeighborOptionsTypeTable,
                                                          tflite::LeakyReluOptionsTypeTable,
                                                          tflite::SquaredDifferenceOptionsTypeTable,
                                                          tflite::MirrorPadOptionsTypeTable,
                                                          tflite::AbsOptionsTypeTable,
                                                          tflite::SplitVOptionsTypeTable,
                                                          tflite::UniqueOptionsTypeTable,
                                                          tflite::ReverseV2OptionsTypeTable,
                                                          tflite::AddNOptionsTypeTable,
                                                          tflite::GatherNdOptionsTypeTable,
                                                          tflite::CosOptionsTypeTable,
                                                          tflite::WhereOptionsTypeTable,
                                                          tflite::RankOptionsTypeTable,
                                                          tflite::ReverseSequenceOptionsTypeTable,
                                                          tflite::MatrixDiagOptionsTypeTable,
                                                          tflite::QuantizeOptionsTypeTable,
                                                          tflite::MatrixSetDiagOptionsTypeTable,
                                                          tflite::HardSwishOptionsTypeTable,
                                                          tflite::IfOptionsTypeTable,
                                                          tflite::WhileOptionsTypeTable,
                                                          tflite::DepthToSpaceOptionsTypeTable,
                                                          tflite::NonMaxSuppressionV4OptionsTypeTable,
                                                          tflite::NonMaxSuppressionV5OptionsTypeTable,
                                                          tflite::ScatterNdOptionsTypeTable,
                                                          tflite::SelectV2OptionsTypeTable,
                                                          tflite::DensifyOptionsTypeTable,
                                                          tflite::SegmentSumOptionsTypeTable,
                                                          tflite::BatchMatMulOptionsTypeTable};
    static const char *const names[]                   = {"NONE",
                                        "Conv2DOptions",
                                        "DepthwiseConv2DOptions",
                                        "ConcatEmbeddingsOptions",
                                        "LSHProjectionOptions",
                                        "Pool2DOptions",
                                        "SVDFOptions",
                                        "RNNOptions",
                                        "FullyConnectedOptions",
                                        "SoftmaxOptions",
                                        "ConcatenationOptions",
                                        "AddOptions",
                                        "L2NormOptions",
                                        "LocalResponseNormalizationOptions",
                                        "LSTMOptions",
                                        "ResizeBilinearOptions",
                                        "CallOptions",
                                        "ReshapeOptions",
                                        "SkipGramOptions",
                                        "SpaceToDepthOptions",
                                        "EmbeddingLookupSparseOptions",
                                        "MulOptions",
                                        "PadOptions",
                                        "GatherOptions",
                                        "BatchToSpaceNDOptions",
                                        "SpaceToBatchNDOptions",
                                        "TransposeOptions",
                                        "ReducerOptions",
                                        "SubOptions",
                                        "DivOptions",
                                        "SqueezeOptions",
                                        "SequenceRNNOptions",
                                        "StridedSliceOptions",
                                        "ExpOptions",
                                        "TopKV2Options",
                                        "SplitOptions",
                                        "LogSoftmaxOptions",
                                        "CastOptions",
                                        "DequantizeOptions",
                                        "MaximumMinimumOptions",
                                        "ArgMaxOptions",
                                        "LessOptions",
                                        "NegOptions",
                                        "PadV2Options",
                                        "GreaterOptions",
                                        "GreaterEqualOptions",
                                        "LessEqualOptions",
                                        "SelectOptions",
                                        "SliceOptions",
                                        "TransposeConvOptions",
                                        "SparseToDenseOptions",
                                        "TileOptions",
                                        "ExpandDimsOptions",
                                        "EqualOptions",
                                        "NotEqualOptions",
                                        "ShapeOptions",
                                        "PowOptions",
                                        "ArgMinOptions",
                                        "FakeQuantOptions",
                                        "PackOptions",
                                        "LogicalOrOptions",
                                        "OneHotOptions",
                                        "LogicalAndOptions",
                                        "LogicalNotOptions",
                                        "UnpackOptions",
                                        "FloorDivOptions",
                                        "SquareOptions",
                                        "ZerosLikeOptions",
                                        "FillOptions",
                                        "BidirectionalSequenceLSTMOptions",
                                        "BidirectionalSequenceRNNOptions",
                                        "UnidirectionalSequenceLSTMOptions",
                                        "FloorModOptions",
                                        "RangeOptions",
                                        "ResizeNearestNeighborOptions",
                                        "LeakyReluOptions",
                                        "SquaredDifferenceOptions",
                                        "MirrorPadOptions",
                                        "AbsOptions",
                                        "SplitVOptions",
                                        "UniqueOptions",
                                        "ReverseV2Options",
                                        "AddNOptions",
                                        "GatherNdOptions",
                                        "CosOptions",
                                        "WhereOptions",
                                        "RankOptions",
                                        "ReverseSequenceOptions",
                                        "MatrixDiagOptions",
                                        "QuantizeOptions",
                                        "MatrixSetDiagOptions",
                                        "HardSwishOptions",
                                        "IfOptions",
                                        "WhileOptions",
                                        "DepthToSpaceOptions",
                                        "NonMaxSuppressionV4Options",
                                        "NonMaxSuppressionV5Options",
                                        "ScatterNdOptions",
                                        "SelectV2Options",
                                        "DensifyOptions",
                                        "SegmentSumOptions",
                                        "BatchMatMulOptions"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_UNION, 102, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *PaddingTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::PaddingTypeTable};
    static const char *const names[]                   = {"SAME", "VALID"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *ActivationFunctionTypeTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
                                                       {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
                                                       {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]                   = {"NONE", "RELU", "RELU_N1_TO_1", "RELU6", "TANH", "SIGN_BIT"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_ENUM, 6, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *LSHProjectionTypeTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::LSHProjectionTypeTypeTable};
    static const char *const names[]                   = {"UNKNOWN", "SPARSE", "DENSE"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *FullyConnectedOptionsWeightsFormatTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::FullyConnectedOptionsWeightsFormatTypeTable};
    static const char *const names[]                   = {"DEFAULT", "SHUFFLED4x16INT8"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *LSTMKernelTypeTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::LSTMKernelTypeTypeTable};
    static const char *const names[]                   = {"FULL", "BASIC"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *CombinerTypeTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::CombinerTypeTypeTable};
    static const char *const names[]                   = {"SUM", "MEAN", "SQRTN"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *MirrorPadModeTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::MirrorPadModeTypeTable};
    static const char *const names[]                   = {"REFLECT", "SYMMETRIC"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *CustomOptionsFormatTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::CustomOptionsFormatTypeTable};
    static const char *const names[]                   = {"FLEXBUFFERS"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_ENUM, 1, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *CustomQuantizationTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_UCHAR, 1, -1}};
    static const char *const names[]                = {"custom"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *QuantizationParametersTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_FLOAT, 1, -1}, {flatbuffers::ET_FLOAT, 1, -1},
                                                       {flatbuffers::ET_FLOAT, 1, -1}, {flatbuffers::ET_LONG, 1, -1},
                                                       {flatbuffers::ET_UTYPE, 0, 0},  {flatbuffers::ET_SEQUENCE, 0, 0},
                                                       {flatbuffers::ET_INT, 0, -1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::QuantizationDetailsTypeTable};
    static const char *const names[]                   = {
        "min", "max", "scale", "zero_point", "details_type", "details", "quantized_dimension"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *Int32VectorTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 1, -1}};
    static const char *const names[]                = {"values"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *Uint16VectorTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_USHORT, 1, -1}};
    static const char *const names[]                = {"values"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *Uint8VectorTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_UCHAR, 1, -1}};
    static const char *const names[]                = {"values"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *DimensionMetadataTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0},  {flatbuffers::ET_INT, 0, -1},
                                                       {flatbuffers::ET_UTYPE, 0, 1}, {flatbuffers::ET_SEQUENCE, 0, 1},
                                                       {flatbuffers::ET_UTYPE, 0, 1}, {flatbuffers::ET_SEQUENCE, 0, 1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::DimensionTypeTypeTable,
                                                          tflite::SparseIndexVectorTypeTable};
    static const char *const names[]                   = {"format",         "dense_size",         "array_segments_type",
                                        "array_segments", "array_indices_type", "array_indices"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *SparsityParametersTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {
        {flatbuffers::ET_INT, 1, -1}, {flatbuffers::ET_INT, 1, -1}, {flatbuffers::ET_SEQUENCE, 1, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::DimensionMetadataTypeTable};
    static const char *const names[]                   = {"traversal_order", "block_map", "dim_metadata"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *TensorTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {
        {flatbuffers::ET_INT, 1, -1},     {flatbuffers::ET_CHAR, 0, 0},     {flatbuffers::ET_UINT, 0, -1},
        {flatbuffers::ET_STRING, 0, -1},  {flatbuffers::ET_SEQUENCE, 0, 1}, {flatbuffers::ET_BOOL, 0, -1},
        {flatbuffers::ET_SEQUENCE, 0, 2}, {flatbuffers::ET_INT, 1, -1}};
    static const flatbuffers::TypeFunction type_refs[] = {
        tflite::TensorTypeTypeTable, tflite::QuantizationParametersTypeTable, tflite::SparsityParametersTypeTable};
    static const char *const names[]       = {"shape",        "type",        "buffer",   "name",
                                        "quantization", "is_variable", "sparsity", "shape_signature"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *Conv2DOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_INT, 0, -1},
                                                       {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_CHAR, 0, 1},
                                                       {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::PaddingTypeTable,
                                                          tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]                   = {
        "padding", "stride_w", "stride_h", "fused_activation_function", "dilation_w_factor", "dilation_h_factor"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *Pool2DOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_INT, 0, -1},
                                                       {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1},
                                                       {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_CHAR, 0, 1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::PaddingTypeTable,
                                                          tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]                   = {"padding",      "stride_w",      "stride_h",
                                        "filter_width", "filter_height", "fused_activation_function"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *DepthwiseConv2DOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_INT, 0, -1},
                                                       {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1},
                                                       {flatbuffers::ET_CHAR, 0, 1}, {flatbuffers::ET_INT, 0, -1},
                                                       {flatbuffers::ET_INT, 0, -1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::PaddingTypeTable,
                                                          tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]                   = {
        "padding",           "stride_w",         "stride_h", "depth_multiplier", "fused_activation_function",
        "dilation_w_factor", "dilation_h_factor"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *ConcatEmbeddingsOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {
        {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 1, -1}, {flatbuffers::ET_INT, 1, -1}};
    static const char *const names[]       = {"num_channels", "num_columns_per_channel", "embedding_dim_per_channel"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *LSHProjectionOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::LSHProjectionTypeTypeTable};
    static const char *const names[]                   = {"type"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *SVDFOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {
        {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_BOOL, 0, -1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]       = {"rank", "fused_activation_function", "asymmetric_quantize_inputs"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *RNNOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_BOOL, 0, -1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]                   = {"fused_activation_function", "asymmetric_quantize_inputs"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *SequenceRNNOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {
        {flatbuffers::ET_BOOL, 0, -1}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_BOOL, 0, -1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]       = {"time_major", "fused_activation_function", "asymmetric_quantize_inputs"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *BidirectionalSequenceRNNOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_BOOL, 0, -1},
                                                       {flatbuffers::ET_CHAR, 0, 0},
                                                       {flatbuffers::ET_BOOL, 0, -1},
                                                       {flatbuffers::ET_BOOL, 0, -1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]                   = {"time_major", "fused_activation_function", "merge_outputs",
                                        "asymmetric_quantize_inputs"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *FullyConnectedOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0},
                                                       {flatbuffers::ET_CHAR, 0, 1},
                                                       {flatbuffers::ET_BOOL, 0, -1},
                                                       {flatbuffers::ET_BOOL, 0, -1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable,
                                                          tflite::FullyConnectedOptionsWeightsFormatTypeTable};
    static const char *const names[]       = {"fused_activation_function", "weights_format", "keep_num_dims",
                                        "asymmetric_quantize_inputs"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *SoftmaxOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_FLOAT, 0, -1}};
    static const char *const names[]                = {"beta"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *ConcatenationOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]                   = {"axis", "fused_activation_function"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *AddOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_BOOL, 0, -1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]                   = {"fused_activation_function", "pot_scale_int16"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *MulOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]                   = {"fused_activation_function"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *L2NormOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]                   = {"fused_activation_function"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *LocalResponseNormalizationOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 0, -1},
                                                       {flatbuffers::ET_FLOAT, 0, -1},
                                                       {flatbuffers::ET_FLOAT, 0, -1},
                                                       {flatbuffers::ET_FLOAT, 0, -1}};
    static const char *const names[]                = {"radius", "bias", "alpha", "beta"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *LSTMOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0},
                                                       {flatbuffers::ET_FLOAT, 0, -1},
                                                       {flatbuffers::ET_FLOAT, 0, -1},
                                                       {flatbuffers::ET_CHAR, 0, 1},
                                                       {flatbuffers::ET_BOOL, 0, -1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable,
                                                          tflite::LSTMKernelTypeTypeTable};
    static const char *const names[]       = {"fused_activation_function", "cell_clip", "proj_clip", "kernel_type",
                                        "asymmetric_quantize_inputs"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *UnidirectionalSequenceLSTMOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0},
                                                       {flatbuffers::ET_FLOAT, 0, -1},
                                                       {flatbuffers::ET_FLOAT, 0, -1},
                                                       {flatbuffers::ET_BOOL, 0, -1},
                                                       {flatbuffers::ET_BOOL, 0, -1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]       = {"fused_activation_function", "cell_clip", "proj_clip", "time_major",
                                        "asymmetric_quantize_inputs"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *BidirectionalSequenceLSTMOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_CHAR, 0, 0},   {flatbuffers::ET_FLOAT, 0, -1},
                                                       {flatbuffers::ET_FLOAT, 0, -1}, {flatbuffers::ET_BOOL, 0, -1},
                                                       {flatbuffers::ET_BOOL, 0, -1},  {flatbuffers::ET_BOOL, 0, -1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]                   = {
        "fused_activation_function", "cell_clip", "proj_clip", "merge_outputs", "time_major",
        "asymmetric_quantize_inputs"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *ResizeBilinearOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 0, -1},
                                                       {flatbuffers::ET_INT, 0, -1},
                                                       {flatbuffers::ET_BOOL, 0, -1},
                                                       {flatbuffers::ET_BOOL, 0, -1}};
    static const char *const names[]       = {"new_height", "new_width", "align_corners", "half_pixel_centers"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *ResizeNearestNeighborOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_BOOL, 0, -1}, {flatbuffers::ET_BOOL, 0, -1}};
    static const char *const names[]                = {"align_corners", "half_pixel_centers"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *CallOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_UINT, 0, -1}};
    static const char *const names[]                = {"subgraph"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *PadOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *PadV2OptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *ReshapeOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 1, -1}};
    static const char *const names[]                = {"new_shape"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *SpaceToBatchNDOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *BatchToSpaceNDOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *SkipGramOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {
        {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_BOOL, 0, -1}};
    static const char *const names[]       = {"ngram_size", "max_skip_size", "include_all_ngrams"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *SpaceToDepthOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 0, -1}};
    static const char *const names[]                = {"block_size"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *DepthToSpaceOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 0, -1}};
    static const char *const names[]                = {"block_size"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *SubOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_BOOL, 0, -1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]                   = {"fused_activation_function", "pot_scale_int16"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *DivOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]                   = {"fused_activation_function"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *TopKV2OptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *EmbeddingLookupSparseOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::CombinerTypeTypeTable};
    static const char *const names[]                   = {"combiner"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *GatherOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 0, -1}};
    static const char *const names[]                = {"axis"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *TransposeOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *ExpOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *CosOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *ReducerOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_BOOL, 0, -1}};
    static const char *const names[]                = {"keep_dims"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *SqueezeOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 1, -1}};
    static const char *const names[]                = {"squeeze_dims"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *SplitOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 0, -1}};
    static const char *const names[]                = {"num_splits"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *SplitVOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 0, -1}};
    static const char *const names[]                = {"num_splits"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *StridedSliceOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 0, -1},
                                                       {flatbuffers::ET_INT, 0, -1},
                                                       {flatbuffers::ET_INT, 0, -1},
                                                       {flatbuffers::ET_INT, 0, -1},
                                                       {flatbuffers::ET_INT, 0, -1}};
    static const char *const names[] = {"begin_mask", "end_mask", "ellipsis_mask", "new_axis_mask", "shrink_axis_mask"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *LogSoftmaxOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *CastOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::TensorTypeTypeTable};
    static const char *const names[]                   = {"in_data_type", "out_data_type"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *DequantizeOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *MaximumMinimumOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *TileOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *ArgMaxOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::TensorTypeTypeTable};
    static const char *const names[]                   = {"output_type"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *ArgMinOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::TensorTypeTypeTable};
    static const char *const names[]                   = {"output_type"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *GreaterOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *GreaterEqualOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *LessOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *LessEqualOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *NegOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *SelectOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *SliceOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *TransposeConvOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::PaddingTypeTable};
    static const char *const names[]                   = {"padding", "stride_w", "stride_h"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *ExpandDimsOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *SparseToDenseOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_BOOL, 0, -1}};
    static const char *const names[]                = {"validate_indices"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *EqualOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *NotEqualOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *ShapeOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::TensorTypeTypeTable};
    static const char *const names[]                   = {"out_type"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *RankOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *PowOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *FakeQuantOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_FLOAT, 0, -1},
                                                       {flatbuffers::ET_FLOAT, 0, -1},
                                                       {flatbuffers::ET_INT, 0, -1},
                                                       {flatbuffers::ET_BOOL, 0, -1}};
    static const char *const names[]                = {"min", "max", "num_bits", "narrow_range"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *PackOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1}};
    static const char *const names[]                = {"values_count", "axis"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *LogicalOrOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *OneHotOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 0, -1}};
    static const char *const names[]                = {"axis"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *AbsOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *HardSwishOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *LogicalAndOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *LogicalNotOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *UnpackOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1}};
    static const char *const names[]                = {"num", "axis"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *FloorDivOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *SquareOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *ZerosLikeOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *FillOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *FloorModOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *RangeOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *LeakyReluOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_FLOAT, 0, -1}};
    static const char *const names[]                = {"alpha"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *SquaredDifferenceOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *MirrorPadOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::MirrorPadModeTypeTable};
    static const char *const names[]                   = {"mode"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *UniqueOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::TensorTypeTypeTable};
    static const char *const names[]                   = {"idx_out_type"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *ReverseV2OptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *AddNOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *GatherNdOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *WhereOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *ReverseSequenceOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1}};
    static const char *const names[]                = {"seq_dim", "batch_dim"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *MatrixDiagOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *QuantizeOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *MatrixSetDiagOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *IfOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1}};
    static const char *const names[]                = {"then_subgraph_index", "else_subgraph_index"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *WhileOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1}};
    static const char *const names[]                = {"cond_subgraph_index", "body_subgraph_index"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *NonMaxSuppressionV4OptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *NonMaxSuppressionV5OptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *ScatterNdOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *SelectV2OptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *DensifyOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *SegmentSumOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *BatchMatMulOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_BOOL, 0, -1}, {flatbuffers::ET_BOOL, 0, -1}};
    static const char *const names[]                = {"adj_x", "adj_y"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *OperatorCodeTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_STRING, 0, -1}, {flatbuffers::ET_INT, 0, -1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::BuiltinOperatorTypeTable};
    static const char *const names[]                   = {"builtin_code", "custom_code", "version"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *OperatorTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {
        {flatbuffers::ET_UINT, 0, -1}, {flatbuffers::ET_INT, 1, -1},     {flatbuffers::ET_INT, 1, -1},
        {flatbuffers::ET_UTYPE, 0, 0}, {flatbuffers::ET_SEQUENCE, 0, 0}, {flatbuffers::ET_UCHAR, 1, -1},
        {flatbuffers::ET_CHAR, 0, 1},  {flatbuffers::ET_BOOL, 1, -1},    {flatbuffers::ET_INT, 1, -1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::BuiltinOptionsTypeTable,
                                                          tflite::CustomOptionsFormatTypeTable};
    static const char *const names[]                   = {"opcode_index",
                                        "inputs",
                                        "outputs",
                                        "builtin_options_type",
                                        "builtin_options",
                                        "custom_options",
                                        "custom_options_format",
                                        "mutating_variable_inputs",
                                        "intermediates"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 9, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *SubGraphTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_SEQUENCE, 1, 0},
                                                       {flatbuffers::ET_INT, 1, -1},
                                                       {flatbuffers::ET_INT, 1, -1},
                                                       {flatbuffers::ET_SEQUENCE, 1, 1},
                                                       {flatbuffers::ET_STRING, 0, -1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::TensorTypeTable, tflite::OperatorTypeTable};
    static const char *const names[]                   = {"tensors", "inputs", "outputs", "operators", "name"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *BufferTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_UCHAR, 1, -1}};
    static const char *const names[]                = {"data"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *MetadataTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_STRING, 0, -1}, {flatbuffers::ET_UINT, 0, -1}};
    static const char *const names[]                = {"name", "buffer"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *ModelTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {
        {flatbuffers::ET_UINT, 0, -1},   {flatbuffers::ET_SEQUENCE, 1, 0}, {flatbuffers::ET_SEQUENCE, 1, 1},
        {flatbuffers::ET_STRING, 0, -1}, {flatbuffers::ET_SEQUENCE, 1, 2}, {flatbuffers::ET_INT, 1, -1},
        {flatbuffers::ET_SEQUENCE, 1, 3}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::OperatorCodeTypeTable, tflite::SubGraphTypeTable,
                                                          tflite::BufferTypeTable, tflite::MetadataTypeTable};
    static const char *const names[]                   = {"version", "operator_codes",  "subgraphs", "description",
                                        "buffers", "metadata_buffer", "metadata"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const tflite::Model *GetModel(const void *buf) {
    return flatbuffers::GetRoot<tflite::Model>(buf);
}

inline const tflite::Model *GetSizePrefixedModel(const void *buf) {
    return flatbuffers::GetSizePrefixedRoot<tflite::Model>(buf);
}

inline const char *ModelIdentifier() {
    return "TFL3";
}

inline bool ModelBufferHasIdentifier(const void *buf) {
    return flatbuffers::BufferHasIdentifier(buf, ModelIdentifier());
}

inline bool VerifyModelBuffer(flatbuffers::Verifier &verifier) {
    return verifier.VerifyBuffer<tflite::Model>(ModelIdentifier());
}

inline bool VerifySizePrefixedModelBuffer(flatbuffers::Verifier &verifier) {
    return verifier.VerifySizePrefixedBuffer<tflite::Model>(ModelIdentifier());
}

inline const char *ModelExtension() {
    return "tflite";
}

inline void FinishModelBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<tflite::Model> root) {
    fbb.Finish(root, ModelIdentifier());
}

inline void FinishSizePrefixedModelBuffer(flatbuffers::FlatBufferBuilder &fbb,
                                          flatbuffers::Offset<tflite::Model> root) {
    fbb.FinishSizePrefixed(root, ModelIdentifier());
}

inline std::unique_ptr<tflite::ModelT> UnPackModel(const void *buf,
                                                   const flatbuffers::resolver_function_t *res = nullptr) {
    return std::unique_ptr<tflite::ModelT>(GetModel(buf)->UnPack(res));
}

inline std::unique_ptr<tflite::ModelT> UnPackSizePrefixedModel(const void *buf,
                                                               const flatbuffers::resolver_function_t *res = nullptr) {
    return std::unique_ptr<tflite::ModelT>(GetSizePrefixedModel(buf)->UnPack(res));
}

}  // namespace tflite

#endif  // FLATBUFFERS_GENERATED_SCHEMA_TFLITE_H_
