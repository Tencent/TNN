// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_SCHEMA_TFLITE_H_
#define FLATBUFFERS_GENERATED_SCHEMA_TFLITE_H_

#include "flatbuffers/flatbuffers.h"

namespace tflite {

struct QuantizationParameters;
struct QuantizationParametersBuilder;
struct QuantizationParametersT;

struct Tensor;
struct TensorBuilder;
struct TensorT;

struct Conv2DOptions;
struct Conv2DOptionsBuilder;
struct Conv2DOptionsT;

struct Pool2DOptions;
struct Pool2DOptionsBuilder;
struct Pool2DOptionsT;

struct DepthwiseConv2DOptions;
struct DepthwiseConv2DOptionsBuilder;
struct DepthwiseConv2DOptionsT;

struct ConcatEmbeddingsOptions;
struct ConcatEmbeddingsOptionsBuilder;
struct ConcatEmbeddingsOptionsT;

struct LSHProjectionOptions;
struct LSHProjectionOptionsBuilder;
struct LSHProjectionOptionsT;

struct SVDFOptions;
struct SVDFOptionsBuilder;
struct SVDFOptionsT;

struct RNNOptions;
struct RNNOptionsBuilder;
struct RNNOptionsT;

struct SequenceRNNOptions;
struct SequenceRNNOptionsBuilder;
struct SequenceRNNOptionsT;

struct BidirectionalSequenceRNNOptions;
struct BidirectionalSequenceRNNOptionsBuilder;
struct BidirectionalSequenceRNNOptionsT;

struct FullyConnectedOptions;
struct FullyConnectedOptionsBuilder;
struct FullyConnectedOptionsT;

struct SoftmaxOptions;
struct SoftmaxOptionsBuilder;
struct SoftmaxOptionsT;

struct ConcatenationOptions;
struct ConcatenationOptionsBuilder;
struct ConcatenationOptionsT;

struct AddOptions;
struct AddOptionsBuilder;
struct AddOptionsT;

struct MulOptions;
struct MulOptionsBuilder;
struct MulOptionsT;

struct L2NormOptions;
struct L2NormOptionsBuilder;
struct L2NormOptionsT;

struct LocalResponseNormalizationOptions;
struct LocalResponseNormalizationOptionsBuilder;
struct LocalResponseNormalizationOptionsT;

struct LSTMOptions;
struct LSTMOptionsBuilder;
struct LSTMOptionsT;

struct ResizeBilinearOptions;
struct ResizeBilinearOptionsBuilder;
struct ResizeBilinearOptionsT;

struct CallOptions;
struct CallOptionsBuilder;
struct CallOptionsT;

struct PadOptions;
struct PadOptionsBuilder;
struct PadOptionsT;

struct PadV2Options;
struct PadV2OptionsBuilder;
struct PadV2OptionsT;

struct ReshapeOptions;
struct ReshapeOptionsBuilder;
struct ReshapeOptionsT;

struct SpaceToBatchNDOptions;
struct SpaceToBatchNDOptionsBuilder;
struct SpaceToBatchNDOptionsT;

struct BatchToSpaceNDOptions;
struct BatchToSpaceNDOptionsBuilder;
struct BatchToSpaceNDOptionsT;

struct SkipGramOptions;
struct SkipGramOptionsBuilder;
struct SkipGramOptionsT;

struct SpaceToDepthOptions;
struct SpaceToDepthOptionsBuilder;
struct SpaceToDepthOptionsT;

struct SubOptions;
struct SubOptionsBuilder;
struct SubOptionsT;

struct DivOptions;
struct DivOptionsBuilder;
struct DivOptionsT;

struct TopKV2Options;
struct TopKV2OptionsBuilder;
struct TopKV2OptionsT;

struct EmbeddingLookupSparseOptions;
struct EmbeddingLookupSparseOptionsBuilder;
struct EmbeddingLookupSparseOptionsT;

struct GatherOptions;
struct GatherOptionsBuilder;
struct GatherOptionsT;

struct TransposeOptions;
struct TransposeOptionsBuilder;
struct TransposeOptionsT;

struct ExpOptions;
struct ExpOptionsBuilder;
struct ExpOptionsT;

struct ReducerOptions;
struct ReducerOptionsBuilder;
struct ReducerOptionsT;

struct SqueezeOptions;
struct SqueezeOptionsBuilder;
struct SqueezeOptionsT;

struct SplitOptions;
struct SplitOptionsBuilder;
struct SplitOptionsT;

struct StridedSliceOptions;
struct StridedSliceOptionsBuilder;
struct StridedSliceOptionsT;

struct LogSoftmaxOptions;
struct LogSoftmaxOptionsBuilder;
struct LogSoftmaxOptionsT;

struct CastOptions;
struct CastOptionsBuilder;
struct CastOptionsT;

struct DequantizeOptions;
struct DequantizeOptionsBuilder;
struct DequantizeOptionsT;

struct MaximumMinimumOptions;
struct MaximumMinimumOptionsBuilder;
struct MaximumMinimumOptionsT;

struct TileOptions;
struct TileOptionsBuilder;
struct TileOptionsT;

struct ArgMaxOptions;
struct ArgMaxOptionsBuilder;
struct ArgMaxOptionsT;

struct ArgMinOptions;
struct ArgMinOptionsBuilder;
struct ArgMinOptionsT;

struct GreaterOptions;
struct GreaterOptionsBuilder;
struct GreaterOptionsT;

struct GreaterEqualOptions;
struct GreaterEqualOptionsBuilder;
struct GreaterEqualOptionsT;

struct LessOptions;
struct LessOptionsBuilder;
struct LessOptionsT;

struct LessEqualOptions;
struct LessEqualOptionsBuilder;
struct LessEqualOptionsT;

struct NegOptions;
struct NegOptionsBuilder;
struct NegOptionsT;

struct SelectOptions;
struct SelectOptionsBuilder;
struct SelectOptionsT;

struct SliceOptions;
struct SliceOptionsBuilder;
struct SliceOptionsT;

struct TransposeConvOptions;
struct TransposeConvOptionsBuilder;
struct TransposeConvOptionsT;

struct ExpandDimsOptions;
struct ExpandDimsOptionsBuilder;
struct ExpandDimsOptionsT;

struct SparseToDenseOptions;
struct SparseToDenseOptionsBuilder;
struct SparseToDenseOptionsT;

struct EqualOptions;
struct EqualOptionsBuilder;
struct EqualOptionsT;

struct NotEqualOptions;
struct NotEqualOptionsBuilder;
struct NotEqualOptionsT;

struct ShapeOptions;
struct ShapeOptionsBuilder;
struct ShapeOptionsT;

struct PowOptions;
struct PowOptionsBuilder;
struct PowOptionsT;

struct FakeQuantOptions;
struct FakeQuantOptionsBuilder;
struct FakeQuantOptionsT;

struct PackOptions;
struct PackOptionsBuilder;
struct PackOptionsT;

struct LogicalOrOptions;
struct LogicalOrOptionsBuilder;
struct LogicalOrOptionsT;

struct OneHotOptions;
struct OneHotOptionsBuilder;
struct OneHotOptionsT;

struct LogicalAndOptions;
struct LogicalAndOptionsBuilder;
struct LogicalAndOptionsT;

struct LogicalNotOptions;
struct LogicalNotOptionsBuilder;
struct LogicalNotOptionsT;

struct UnpackOptions;
struct UnpackOptionsBuilder;
struct UnpackOptionsT;

struct FloorDivOptions;
struct FloorDivOptionsBuilder;
struct FloorDivOptionsT;

struct SquareOptions;
struct SquareOptionsBuilder;
struct SquareOptionsT;

struct ZerosLikeOptions;
struct ZerosLikeOptionsBuilder;
struct ZerosLikeOptionsT;

struct FillOptions;
struct FillOptionsBuilder;
struct FillOptionsT;

struct OperatorCode;
struct OperatorCodeBuilder;
struct OperatorCodeT;

struct Operator;
struct OperatorBuilder;
struct OperatorT;

struct SubGraph;
struct SubGraphBuilder;
struct SubGraphT;

struct Buffer;
struct BufferBuilder;
struct BufferT;

struct Model;
struct ModelBuilder;
struct ModelT;

inline const flatbuffers::TypeTable *QuantizationParametersTypeTable();

inline const flatbuffers::TypeTable *TensorTypeTable();

inline const flatbuffers::TypeTable *Conv2DOptionsTypeTable();

inline const flatbuffers::TypeTable *Pool2DOptionsTypeTable();

inline const flatbuffers::TypeTable *DepthwiseConv2DOptionsTypeTable();

inline const flatbuffers::TypeTable *ConcatEmbeddingsOptionsTypeTable();

inline const flatbuffers::TypeTable *LSHProjectionOptionsTypeTable();

inline const flatbuffers::TypeTable *SVDFOptionsTypeTable();

inline const flatbuffers::TypeTable *RNNOptionsTypeTable();

inline const flatbuffers::TypeTable *SequenceRNNOptionsTypeTable();

inline const flatbuffers::TypeTable *BidirectionalSequenceRNNOptionsTypeTable();

inline const flatbuffers::TypeTable *FullyConnectedOptionsTypeTable();

inline const flatbuffers::TypeTable *SoftmaxOptionsTypeTable();

inline const flatbuffers::TypeTable *ConcatenationOptionsTypeTable();

inline const flatbuffers::TypeTable *AddOptionsTypeTable();

inline const flatbuffers::TypeTable *MulOptionsTypeTable();

inline const flatbuffers::TypeTable *L2NormOptionsTypeTable();

inline const flatbuffers::TypeTable *LocalResponseNormalizationOptionsTypeTable();

inline const flatbuffers::TypeTable *LSTMOptionsTypeTable();

inline const flatbuffers::TypeTable *ResizeBilinearOptionsTypeTable();

inline const flatbuffers::TypeTable *CallOptionsTypeTable();

inline const flatbuffers::TypeTable *PadOptionsTypeTable();

inline const flatbuffers::TypeTable *PadV2OptionsTypeTable();

inline const flatbuffers::TypeTable *ReshapeOptionsTypeTable();

inline const flatbuffers::TypeTable *SpaceToBatchNDOptionsTypeTable();

inline const flatbuffers::TypeTable *BatchToSpaceNDOptionsTypeTable();

inline const flatbuffers::TypeTable *SkipGramOptionsTypeTable();

inline const flatbuffers::TypeTable *SpaceToDepthOptionsTypeTable();

inline const flatbuffers::TypeTable *SubOptionsTypeTable();

inline const flatbuffers::TypeTable *DivOptionsTypeTable();

inline const flatbuffers::TypeTable *TopKV2OptionsTypeTable();

inline const flatbuffers::TypeTable *EmbeddingLookupSparseOptionsTypeTable();

inline const flatbuffers::TypeTable *GatherOptionsTypeTable();

inline const flatbuffers::TypeTable *TransposeOptionsTypeTable();

inline const flatbuffers::TypeTable *ExpOptionsTypeTable();

inline const flatbuffers::TypeTable *ReducerOptionsTypeTable();

inline const flatbuffers::TypeTable *SqueezeOptionsTypeTable();

inline const flatbuffers::TypeTable *SplitOptionsTypeTable();

inline const flatbuffers::TypeTable *StridedSliceOptionsTypeTable();

inline const flatbuffers::TypeTable *LogSoftmaxOptionsTypeTable();

inline const flatbuffers::TypeTable *CastOptionsTypeTable();

inline const flatbuffers::TypeTable *DequantizeOptionsTypeTable();

inline const flatbuffers::TypeTable *MaximumMinimumOptionsTypeTable();

inline const flatbuffers::TypeTable *TileOptionsTypeTable();

inline const flatbuffers::TypeTable *ArgMaxOptionsTypeTable();

inline const flatbuffers::TypeTable *ArgMinOptionsTypeTable();

inline const flatbuffers::TypeTable *GreaterOptionsTypeTable();

inline const flatbuffers::TypeTable *GreaterEqualOptionsTypeTable();

inline const flatbuffers::TypeTable *LessOptionsTypeTable();

inline const flatbuffers::TypeTable *LessEqualOptionsTypeTable();

inline const flatbuffers::TypeTable *NegOptionsTypeTable();

inline const flatbuffers::TypeTable *SelectOptionsTypeTable();

inline const flatbuffers::TypeTable *SliceOptionsTypeTable();

inline const flatbuffers::TypeTable *TransposeConvOptionsTypeTable();

inline const flatbuffers::TypeTable *ExpandDimsOptionsTypeTable();

inline const flatbuffers::TypeTable *SparseToDenseOptionsTypeTable();

inline const flatbuffers::TypeTable *EqualOptionsTypeTable();

inline const flatbuffers::TypeTable *NotEqualOptionsTypeTable();

inline const flatbuffers::TypeTable *ShapeOptionsTypeTable();

inline const flatbuffers::TypeTable *PowOptionsTypeTable();

inline const flatbuffers::TypeTable *FakeQuantOptionsTypeTable();

inline const flatbuffers::TypeTable *PackOptionsTypeTable();

inline const flatbuffers::TypeTable *LogicalOrOptionsTypeTable();

inline const flatbuffers::TypeTable *OneHotOptionsTypeTable();

inline const flatbuffers::TypeTable *LogicalAndOptionsTypeTable();

inline const flatbuffers::TypeTable *LogicalNotOptionsTypeTable();

inline const flatbuffers::TypeTable *UnpackOptionsTypeTable();

inline const flatbuffers::TypeTable *FloorDivOptionsTypeTable();

inline const flatbuffers::TypeTable *SquareOptionsTypeTable();

inline const flatbuffers::TypeTable *ZerosLikeOptionsTypeTable();

inline const flatbuffers::TypeTable *FillOptionsTypeTable();

inline const flatbuffers::TypeTable *OperatorCodeTypeTable();

inline const flatbuffers::TypeTable *OperatorTypeTable();

inline const flatbuffers::TypeTable *SubGraphTypeTable();

inline const flatbuffers::TypeTable *BufferTypeTable();

inline const flatbuffers::TypeTable *ModelTypeTable();

enum TensorType {
    TensorType_FLOAT32   = 0,
    TensorType_FLOAT16   = 1,
    TensorType_INT32     = 2,
    TensorType_UINT8     = 3,
    TensorType_INT64     = 4,
    TensorType_STRING    = 5,
    TensorType_BOOL      = 6,
    TensorType_INT16     = 7,
    TensorType_COMPLEX64 = 8,
    TensorType_MIN       = TensorType_FLOAT32,
    TensorType_MAX       = TensorType_COMPLEX64
};

inline const TensorType (&EnumValuesTensorType())[9] {
    static const TensorType values[] = {TensorType_FLOAT32, TensorType_FLOAT16, TensorType_INT32,
                                        TensorType_UINT8,   TensorType_INT64,   TensorType_STRING,
                                        TensorType_BOOL,    TensorType_INT16,   TensorType_COMPLEX64};
    return values;
}

inline const char *const *EnumNamesTensorType() {
    static const char *const names[10] = {"FLOAT32", "FLOAT16", "INT32", "UINT8",     "INT64",
                                          "STRING",  "BOOL",    "INT16", "COMPLEX64", nullptr};
    return names;
}

inline const char *EnumNameTensorType(TensorType e) {
    if (flatbuffers::IsOutRange(e, TensorType_FLOAT32, TensorType_COMPLEX64))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesTensorType()[index];
}

enum BuiltinOperator {
    BuiltinOperator_ADD                          = 0,
    BuiltinOperator_AVERAGE_POOL_2D              = 1,
    BuiltinOperator_CONCATENATION                = 2,
    BuiltinOperator_CONV_2D                      = 3,
    BuiltinOperator_DEPTHWISE_CONV_2D            = 4,
    BuiltinOperator_DEQUANTIZE                   = 6,
    BuiltinOperator_EMBEDDING_LOOKUP             = 7,
    BuiltinOperator_FLOOR                        = 8,
    BuiltinOperator_FULLY_CONNECTED              = 9,
    BuiltinOperator_HASHTABLE_LOOKUP             = 10,
    BuiltinOperator_L2_NORMALIZATION             = 11,
    BuiltinOperator_L2_POOL_2D                   = 12,
    BuiltinOperator_LOCAL_RESPONSE_NORMALIZATION = 13,
    BuiltinOperator_LOGISTIC                     = 14,
    BuiltinOperator_LSH_PROJECTION               = 15,
    BuiltinOperator_LSTM                         = 16,
    BuiltinOperator_MAX_POOL_2D                  = 17,
    BuiltinOperator_MUL                          = 18,
    BuiltinOperator_RELU                         = 19,
    BuiltinOperator_RELU_N1_TO_1                 = 20,
    BuiltinOperator_RELU6                        = 21,
    BuiltinOperator_RESHAPE                      = 22,
    BuiltinOperator_RESIZE_BILINEAR              = 23,
    BuiltinOperator_RNN                          = 24,
    BuiltinOperator_SOFTMAX                      = 25,
    BuiltinOperator_SPACE_TO_DEPTH               = 26,
    BuiltinOperator_SVDF                         = 27,
    BuiltinOperator_TANH                         = 28,
    BuiltinOperator_CONCAT_EMBEDDINGS            = 29,
    BuiltinOperator_SKIP_GRAM                    = 30,
    BuiltinOperator_CALL                         = 31,
    BuiltinOperator_CUSTOM                       = 32,
    BuiltinOperator_EMBEDDING_LOOKUP_SPARSE      = 33,
    BuiltinOperator_PAD                          = 34,
    BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_RNN  = 35,
    BuiltinOperator_GATHER                       = 36,
    BuiltinOperator_BATCH_TO_SPACE_ND            = 37,
    BuiltinOperator_SPACE_TO_BATCH_ND            = 38,
    BuiltinOperator_TRANSPOSE                    = 39,
    BuiltinOperator_MEAN                         = 40,
    BuiltinOperator_SUB                          = 41,
    BuiltinOperator_DIV                          = 42,
    BuiltinOperator_SQUEEZE                      = 43,
    BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_LSTM = 44,
    BuiltinOperator_STRIDED_SLICE                = 45,
    BuiltinOperator_BIDIRECTIONAL_SEQUENCE_RNN   = 46,
    BuiltinOperator_EXP                          = 47,
    BuiltinOperator_TOPK_V2                      = 48,
    BuiltinOperator_SPLIT                        = 49,
    BuiltinOperator_LOG_SOFTMAX                  = 50,
    BuiltinOperator_DELEGATE                     = 51,
    BuiltinOperator_BIDIRECTIONAL_SEQUENCE_LSTM  = 52,
    BuiltinOperator_CAST                         = 53,
    BuiltinOperator_PRELU                        = 54,
    BuiltinOperator_MAXIMUM                      = 55,
    BuiltinOperator_ARG_MAX                      = 56,
    BuiltinOperator_MINIMUM                      = 57,
    BuiltinOperator_LESS                         = 58,
    BuiltinOperator_NEG                          = 59,
    BuiltinOperator_PADV2                        = 60,
    BuiltinOperator_GREATER                      = 61,
    BuiltinOperator_GREATER_EQUAL                = 62,
    BuiltinOperator_LESS_EQUAL                   = 63,
    BuiltinOperator_SELECT                       = 64,
    BuiltinOperator_SLICE                        = 65,
    BuiltinOperator_SIN                          = 66,
    BuiltinOperator_TRANSPOSE_CONV               = 67,
    BuiltinOperator_SPARSE_TO_DENSE              = 68,
    BuiltinOperator_TILE                         = 69,
    BuiltinOperator_EXPAND_DIMS                  = 70,
    BuiltinOperator_EQUAL                        = 71,
    BuiltinOperator_NOT_EQUAL                    = 72,
    BuiltinOperator_LOG                          = 73,
    BuiltinOperator_SUM                          = 74,
    BuiltinOperator_SQRT                         = 75,
    BuiltinOperator_RSQRT                        = 76,
    BuiltinOperator_SHAPE                        = 77,
    BuiltinOperator_POW                          = 78,
    BuiltinOperator_ARG_MIN                      = 79,
    BuiltinOperator_FAKE_QUANT                   = 80,
    BuiltinOperator_REDUCE_PROD                  = 81,
    BuiltinOperator_REDUCE_MAX                   = 82,
    BuiltinOperator_PACK                         = 83,
    BuiltinOperator_LOGICAL_OR                   = 84,
    BuiltinOperator_ONE_HOT                      = 85,
    BuiltinOperator_LOGICAL_AND                  = 86,
    BuiltinOperator_LOGICAL_NOT                  = 87,
    BuiltinOperator_UNPACK                       = 88,
    BuiltinOperator_REDUCE_MIN                   = 89,
    BuiltinOperator_FLOOR_DIV                    = 90,
    BuiltinOperator_REDUCE_ANY                   = 91,
    BuiltinOperator_SQUARE                       = 92,
    BuiltinOperator_ZEROS_LIKE                   = 93,
    BuiltinOperator_FILL                         = 94,
    BuiltinOperator_MIN                          = BuiltinOperator_ADD,
    BuiltinOperator_MAX                          = BuiltinOperator_FILL
};

inline const BuiltinOperator (&EnumValuesBuiltinOperator())[94] {
    static const BuiltinOperator values[] = {BuiltinOperator_ADD,
                                             BuiltinOperator_AVERAGE_POOL_2D,
                                             BuiltinOperator_CONCATENATION,
                                             BuiltinOperator_CONV_2D,
                                             BuiltinOperator_DEPTHWISE_CONV_2D,
                                             BuiltinOperator_DEQUANTIZE,
                                             BuiltinOperator_EMBEDDING_LOOKUP,
                                             BuiltinOperator_FLOOR,
                                             BuiltinOperator_FULLY_CONNECTED,
                                             BuiltinOperator_HASHTABLE_LOOKUP,
                                             BuiltinOperator_L2_NORMALIZATION,
                                             BuiltinOperator_L2_POOL_2D,
                                             BuiltinOperator_LOCAL_RESPONSE_NORMALIZATION,
                                             BuiltinOperator_LOGISTIC,
                                             BuiltinOperator_LSH_PROJECTION,
                                             BuiltinOperator_LSTM,
                                             BuiltinOperator_MAX_POOL_2D,
                                             BuiltinOperator_MUL,
                                             BuiltinOperator_RELU,
                                             BuiltinOperator_RELU_N1_TO_1,
                                             BuiltinOperator_RELU6,
                                             BuiltinOperator_RESHAPE,
                                             BuiltinOperator_RESIZE_BILINEAR,
                                             BuiltinOperator_RNN,
                                             BuiltinOperator_SOFTMAX,
                                             BuiltinOperator_SPACE_TO_DEPTH,
                                             BuiltinOperator_SVDF,
                                             BuiltinOperator_TANH,
                                             BuiltinOperator_CONCAT_EMBEDDINGS,
                                             BuiltinOperator_SKIP_GRAM,
                                             BuiltinOperator_CALL,
                                             BuiltinOperator_CUSTOM,
                                             BuiltinOperator_EMBEDDING_LOOKUP_SPARSE,
                                             BuiltinOperator_PAD,
                                             BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_RNN,
                                             BuiltinOperator_GATHER,
                                             BuiltinOperator_BATCH_TO_SPACE_ND,
                                             BuiltinOperator_SPACE_TO_BATCH_ND,
                                             BuiltinOperator_TRANSPOSE,
                                             BuiltinOperator_MEAN,
                                             BuiltinOperator_SUB,
                                             BuiltinOperator_DIV,
                                             BuiltinOperator_SQUEEZE,
                                             BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_LSTM,
                                             BuiltinOperator_STRIDED_SLICE,
                                             BuiltinOperator_BIDIRECTIONAL_SEQUENCE_RNN,
                                             BuiltinOperator_EXP,
                                             BuiltinOperator_TOPK_V2,
                                             BuiltinOperator_SPLIT,
                                             BuiltinOperator_LOG_SOFTMAX,
                                             BuiltinOperator_DELEGATE,
                                             BuiltinOperator_BIDIRECTIONAL_SEQUENCE_LSTM,
                                             BuiltinOperator_CAST,
                                             BuiltinOperator_PRELU,
                                             BuiltinOperator_MAXIMUM,
                                             BuiltinOperator_ARG_MAX,
                                             BuiltinOperator_MINIMUM,
                                             BuiltinOperator_LESS,
                                             BuiltinOperator_NEG,
                                             BuiltinOperator_PADV2,
                                             BuiltinOperator_GREATER,
                                             BuiltinOperator_GREATER_EQUAL,
                                             BuiltinOperator_LESS_EQUAL,
                                             BuiltinOperator_SELECT,
                                             BuiltinOperator_SLICE,
                                             BuiltinOperator_SIN,
                                             BuiltinOperator_TRANSPOSE_CONV,
                                             BuiltinOperator_SPARSE_TO_DENSE,
                                             BuiltinOperator_TILE,
                                             BuiltinOperator_EXPAND_DIMS,
                                             BuiltinOperator_EQUAL,
                                             BuiltinOperator_NOT_EQUAL,
                                             BuiltinOperator_LOG,
                                             BuiltinOperator_SUM,
                                             BuiltinOperator_SQRT,
                                             BuiltinOperator_RSQRT,
                                             BuiltinOperator_SHAPE,
                                             BuiltinOperator_POW,
                                             BuiltinOperator_ARG_MIN,
                                             BuiltinOperator_FAKE_QUANT,
                                             BuiltinOperator_REDUCE_PROD,
                                             BuiltinOperator_REDUCE_MAX,
                                             BuiltinOperator_PACK,
                                             BuiltinOperator_LOGICAL_OR,
                                             BuiltinOperator_ONE_HOT,
                                             BuiltinOperator_LOGICAL_AND,
                                             BuiltinOperator_LOGICAL_NOT,
                                             BuiltinOperator_UNPACK,
                                             BuiltinOperator_REDUCE_MIN,
                                             BuiltinOperator_FLOOR_DIV,
                                             BuiltinOperator_REDUCE_ANY,
                                             BuiltinOperator_SQUARE,
                                             BuiltinOperator_ZEROS_LIKE,
                                             BuiltinOperator_FILL};
    return values;
}

inline const char *const *EnumNamesBuiltinOperator() {
    static const char *const names[96] = {"ADD",
                                          "AVERAGE_POOL_2D",
                                          "CONCATENATION",
                                          "CONV_2D",
                                          "DEPTHWISE_CONV_2D",
                                          "",
                                          "DEQUANTIZE",
                                          "EMBEDDING_LOOKUP",
                                          "FLOOR",
                                          "FULLY_CONNECTED",
                                          "HASHTABLE_LOOKUP",
                                          "L2_NORMALIZATION",
                                          "L2_POOL_2D",
                                          "LOCAL_RESPONSE_NORMALIZATION",
                                          "LOGISTIC",
                                          "LSH_PROJECTION",
                                          "LSTM",
                                          "MAX_POOL_2D",
                                          "MUL",
                                          "RELU",
                                          "RELU_N1_TO_1",
                                          "RELU6",
                                          "RESHAPE",
                                          "RESIZE_BILINEAR",
                                          "RNN",
                                          "SOFTMAX",
                                          "SPACE_TO_DEPTH",
                                          "SVDF",
                                          "TANH",
                                          "CONCAT_EMBEDDINGS",
                                          "SKIP_GRAM",
                                          "CALL",
                                          "CUSTOM",
                                          "EMBEDDING_LOOKUP_SPARSE",
                                          "PAD",
                                          "UNIDIRECTIONAL_SEQUENCE_RNN",
                                          "GATHER",
                                          "BATCH_TO_SPACE_ND",
                                          "SPACE_TO_BATCH_ND",
                                          "TRANSPOSE",
                                          "MEAN",
                                          "SUB",
                                          "DIV",
                                          "SQUEEZE",
                                          "UNIDIRECTIONAL_SEQUENCE_LSTM",
                                          "STRIDED_SLICE",
                                          "BIDIRECTIONAL_SEQUENCE_RNN",
                                          "EXP",
                                          "TOPK_V2",
                                          "SPLIT",
                                          "LOG_SOFTMAX",
                                          "DELEGATE",
                                          "BIDIRECTIONAL_SEQUENCE_LSTM",
                                          "CAST",
                                          "PRELU",
                                          "MAXIMUM",
                                          "ARG_MAX",
                                          "MINIMUM",
                                          "LESS",
                                          "NEG",
                                          "PADV2",
                                          "GREATER",
                                          "GREATER_EQUAL",
                                          "LESS_EQUAL",
                                          "SELECT",
                                          "SLICE",
                                          "SIN",
                                          "TRANSPOSE_CONV",
                                          "SPARSE_TO_DENSE",
                                          "TILE",
                                          "EXPAND_DIMS",
                                          "EQUAL",
                                          "NOT_EQUAL",
                                          "LOG",
                                          "SUM",
                                          "SQRT",
                                          "RSQRT",
                                          "SHAPE",
                                          "POW",
                                          "ARG_MIN",
                                          "FAKE_QUANT",
                                          "REDUCE_PROD",
                                          "REDUCE_MAX",
                                          "PACK",
                                          "LOGICAL_OR",
                                          "ONE_HOT",
                                          "LOGICAL_AND",
                                          "LOGICAL_NOT",
                                          "UNPACK",
                                          "REDUCE_MIN",
                                          "FLOOR_DIV",
                                          "REDUCE_ANY",
                                          "SQUARE",
                                          "ZEROS_LIKE",
                                          "FILL",
                                          nullptr};
    return names;
}

inline const char *EnumNameBuiltinOperator(BuiltinOperator e) {
    if (flatbuffers::IsOutRange(e, BuiltinOperator_ADD, BuiltinOperator_FILL))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesBuiltinOperator()[index];
}

enum BuiltinOptions {
    BuiltinOptions_NONE                              = 0,
    BuiltinOptions_Conv2DOptions                     = 1,
    BuiltinOptions_DepthwiseConv2DOptions            = 2,
    BuiltinOptions_ConcatEmbeddingsOptions           = 3,
    BuiltinOptions_LSHProjectionOptions              = 4,
    BuiltinOptions_Pool2DOptions                     = 5,
    BuiltinOptions_SVDFOptions                       = 6,
    BuiltinOptions_RNNOptions                        = 7,
    BuiltinOptions_FullyConnectedOptions             = 8,
    BuiltinOptions_SoftmaxOptions                    = 9,
    BuiltinOptions_ConcatenationOptions              = 10,
    BuiltinOptions_AddOptions                        = 11,
    BuiltinOptions_L2NormOptions                     = 12,
    BuiltinOptions_LocalResponseNormalizationOptions = 13,
    BuiltinOptions_LSTMOptions                       = 14,
    BuiltinOptions_ResizeBilinearOptions             = 15,
    BuiltinOptions_CallOptions                       = 16,
    BuiltinOptions_ReshapeOptions                    = 17,
    BuiltinOptions_SkipGramOptions                   = 18,
    BuiltinOptions_SpaceToDepthOptions               = 19,
    BuiltinOptions_EmbeddingLookupSparseOptions      = 20,
    BuiltinOptions_MulOptions                        = 21,
    BuiltinOptions_PadOptions                        = 22,
    BuiltinOptions_GatherOptions                     = 23,
    BuiltinOptions_BatchToSpaceNDOptions             = 24,
    BuiltinOptions_SpaceToBatchNDOptions             = 25,
    BuiltinOptions_TransposeOptions                  = 26,
    BuiltinOptions_ReducerOptions                    = 27,
    BuiltinOptions_SubOptions                        = 28,
    BuiltinOptions_DivOptions                        = 29,
    BuiltinOptions_SqueezeOptions                    = 30,
    BuiltinOptions_SequenceRNNOptions                = 31,
    BuiltinOptions_StridedSliceOptions               = 32,
    BuiltinOptions_ExpOptions                        = 33,
    BuiltinOptions_TopKV2Options                     = 34,
    BuiltinOptions_SplitOptions                      = 35,
    BuiltinOptions_LogSoftmaxOptions                 = 36,
    BuiltinOptions_CastOptions                       = 37,
    BuiltinOptions_DequantizeOptions                 = 38,
    BuiltinOptions_MaximumMinimumOptions             = 39,
    BuiltinOptions_ArgMaxOptions                     = 40,
    BuiltinOptions_LessOptions                       = 41,
    BuiltinOptions_NegOptions                        = 42,
    BuiltinOptions_PadV2Options                      = 43,
    BuiltinOptions_GreaterOptions                    = 44,
    BuiltinOptions_GreaterEqualOptions               = 45,
    BuiltinOptions_LessEqualOptions                  = 46,
    BuiltinOptions_SelectOptions                     = 47,
    BuiltinOptions_SliceOptions                      = 48,
    BuiltinOptions_TransposeConvOptions              = 49,
    BuiltinOptions_SparseToDenseOptions              = 50,
    BuiltinOptions_TileOptions                       = 51,
    BuiltinOptions_ExpandDimsOptions                 = 52,
    BuiltinOptions_EqualOptions                      = 53,
    BuiltinOptions_NotEqualOptions                   = 54,
    BuiltinOptions_ShapeOptions                      = 55,
    BuiltinOptions_PowOptions                        = 56,
    BuiltinOptions_ArgMinOptions                     = 57,
    BuiltinOptions_FakeQuantOptions                  = 58,
    BuiltinOptions_PackOptions                       = 59,
    BuiltinOptions_LogicalOrOptions                  = 60,
    BuiltinOptions_OneHotOptions                     = 61,
    BuiltinOptions_LogicalAndOptions                 = 62,
    BuiltinOptions_LogicalNotOptions                 = 63,
    BuiltinOptions_UnpackOptions                     = 64,
    BuiltinOptions_FloorDivOptions                   = 65,
    BuiltinOptions_SquareOptions                     = 66,
    BuiltinOptions_ZerosLikeOptions                  = 67,
    BuiltinOptions_FillOptions                       = 68,
    BuiltinOptions_MIN                               = BuiltinOptions_NONE,
    BuiltinOptions_MAX                               = BuiltinOptions_FillOptions
};

inline const BuiltinOptions (&EnumValuesBuiltinOptions())[69] {
    static const BuiltinOptions values[] = {BuiltinOptions_NONE,
                                            BuiltinOptions_Conv2DOptions,
                                            BuiltinOptions_DepthwiseConv2DOptions,
                                            BuiltinOptions_ConcatEmbeddingsOptions,
                                            BuiltinOptions_LSHProjectionOptions,
                                            BuiltinOptions_Pool2DOptions,
                                            BuiltinOptions_SVDFOptions,
                                            BuiltinOptions_RNNOptions,
                                            BuiltinOptions_FullyConnectedOptions,
                                            BuiltinOptions_SoftmaxOptions,
                                            BuiltinOptions_ConcatenationOptions,
                                            BuiltinOptions_AddOptions,
                                            BuiltinOptions_L2NormOptions,
                                            BuiltinOptions_LocalResponseNormalizationOptions,
                                            BuiltinOptions_LSTMOptions,
                                            BuiltinOptions_ResizeBilinearOptions,
                                            BuiltinOptions_CallOptions,
                                            BuiltinOptions_ReshapeOptions,
                                            BuiltinOptions_SkipGramOptions,
                                            BuiltinOptions_SpaceToDepthOptions,
                                            BuiltinOptions_EmbeddingLookupSparseOptions,
                                            BuiltinOptions_MulOptions,
                                            BuiltinOptions_PadOptions,
                                            BuiltinOptions_GatherOptions,
                                            BuiltinOptions_BatchToSpaceNDOptions,
                                            BuiltinOptions_SpaceToBatchNDOptions,
                                            BuiltinOptions_TransposeOptions,
                                            BuiltinOptions_ReducerOptions,
                                            BuiltinOptions_SubOptions,
                                            BuiltinOptions_DivOptions,
                                            BuiltinOptions_SqueezeOptions,
                                            BuiltinOptions_SequenceRNNOptions,
                                            BuiltinOptions_StridedSliceOptions,
                                            BuiltinOptions_ExpOptions,
                                            BuiltinOptions_TopKV2Options,
                                            BuiltinOptions_SplitOptions,
                                            BuiltinOptions_LogSoftmaxOptions,
                                            BuiltinOptions_CastOptions,
                                            BuiltinOptions_DequantizeOptions,
                                            BuiltinOptions_MaximumMinimumOptions,
                                            BuiltinOptions_ArgMaxOptions,
                                            BuiltinOptions_LessOptions,
                                            BuiltinOptions_NegOptions,
                                            BuiltinOptions_PadV2Options,
                                            BuiltinOptions_GreaterOptions,
                                            BuiltinOptions_GreaterEqualOptions,
                                            BuiltinOptions_LessEqualOptions,
                                            BuiltinOptions_SelectOptions,
                                            BuiltinOptions_SliceOptions,
                                            BuiltinOptions_TransposeConvOptions,
                                            BuiltinOptions_SparseToDenseOptions,
                                            BuiltinOptions_TileOptions,
                                            BuiltinOptions_ExpandDimsOptions,
                                            BuiltinOptions_EqualOptions,
                                            BuiltinOptions_NotEqualOptions,
                                            BuiltinOptions_ShapeOptions,
                                            BuiltinOptions_PowOptions,
                                            BuiltinOptions_ArgMinOptions,
                                            BuiltinOptions_FakeQuantOptions,
                                            BuiltinOptions_PackOptions,
                                            BuiltinOptions_LogicalOrOptions,
                                            BuiltinOptions_OneHotOptions,
                                            BuiltinOptions_LogicalAndOptions,
                                            BuiltinOptions_LogicalNotOptions,
                                            BuiltinOptions_UnpackOptions,
                                            BuiltinOptions_FloorDivOptions,
                                            BuiltinOptions_SquareOptions,
                                            BuiltinOptions_ZerosLikeOptions,
                                            BuiltinOptions_FillOptions};
    return values;
}

inline const char *const *EnumNamesBuiltinOptions() {
    static const char *const names[70] = {"NONE",
                                          "Conv2DOptions",
                                          "DepthwiseConv2DOptions",
                                          "ConcatEmbeddingsOptions",
                                          "LSHProjectionOptions",
                                          "Pool2DOptions",
                                          "SVDFOptions",
                                          "RNNOptions",
                                          "FullyConnectedOptions",
                                          "SoftmaxOptions",
                                          "ConcatenationOptions",
                                          "AddOptions",
                                          "L2NormOptions",
                                          "LocalResponseNormalizationOptions",
                                          "LSTMOptions",
                                          "ResizeBilinearOptions",
                                          "CallOptions",
                                          "ReshapeOptions",
                                          "SkipGramOptions",
                                          "SpaceToDepthOptions",
                                          "EmbeddingLookupSparseOptions",
                                          "MulOptions",
                                          "PadOptions",
                                          "GatherOptions",
                                          "BatchToSpaceNDOptions",
                                          "SpaceToBatchNDOptions",
                                          "TransposeOptions",
                                          "ReducerOptions",
                                          "SubOptions",
                                          "DivOptions",
                                          "SqueezeOptions",
                                          "SequenceRNNOptions",
                                          "StridedSliceOptions",
                                          "ExpOptions",
                                          "TopKV2Options",
                                          "SplitOptions",
                                          "LogSoftmaxOptions",
                                          "CastOptions",
                                          "DequantizeOptions",
                                          "MaximumMinimumOptions",
                                          "ArgMaxOptions",
                                          "LessOptions",
                                          "NegOptions",
                                          "PadV2Options",
                                          "GreaterOptions",
                                          "GreaterEqualOptions",
                                          "LessEqualOptions",
                                          "SelectOptions",
                                          "SliceOptions",
                                          "TransposeConvOptions",
                                          "SparseToDenseOptions",
                                          "TileOptions",
                                          "ExpandDimsOptions",
                                          "EqualOptions",
                                          "NotEqualOptions",
                                          "ShapeOptions",
                                          "PowOptions",
                                          "ArgMinOptions",
                                          "FakeQuantOptions",
                                          "PackOptions",
                                          "LogicalOrOptions",
                                          "OneHotOptions",
                                          "LogicalAndOptions",
                                          "LogicalNotOptions",
                                          "UnpackOptions",
                                          "FloorDivOptions",
                                          "SquareOptions",
                                          "ZerosLikeOptions",
                                          "FillOptions",
                                          nullptr};
    return names;
}

inline const char *EnumNameBuiltinOptions(BuiltinOptions e) {
    if (flatbuffers::IsOutRange(e, BuiltinOptions_NONE, BuiltinOptions_FillOptions))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesBuiltinOptions()[index];
}

template <typename T>
struct BuiltinOptionsTraits {
    static const BuiltinOptions enum_value = BuiltinOptions_NONE;
};

template <>
struct BuiltinOptionsTraits<tflite::Conv2DOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_Conv2DOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::DepthwiseConv2DOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_DepthwiseConv2DOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ConcatEmbeddingsOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_ConcatEmbeddingsOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LSHProjectionOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_LSHProjectionOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::Pool2DOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_Pool2DOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SVDFOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SVDFOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::RNNOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_RNNOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::FullyConnectedOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_FullyConnectedOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SoftmaxOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SoftmaxOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ConcatenationOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_ConcatenationOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::AddOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_AddOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::L2NormOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_L2NormOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LocalResponseNormalizationOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_LocalResponseNormalizationOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LSTMOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_LSTMOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ResizeBilinearOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_ResizeBilinearOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::CallOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_CallOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ReshapeOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_ReshapeOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SkipGramOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SkipGramOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SpaceToDepthOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SpaceToDepthOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::EmbeddingLookupSparseOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_EmbeddingLookupSparseOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::MulOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_MulOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::PadOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_PadOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::GatherOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_GatherOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::BatchToSpaceNDOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_BatchToSpaceNDOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SpaceToBatchNDOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SpaceToBatchNDOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::TransposeOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_TransposeOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ReducerOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_ReducerOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SubOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SubOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::DivOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_DivOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SqueezeOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SqueezeOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SequenceRNNOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SequenceRNNOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::StridedSliceOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_StridedSliceOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ExpOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_ExpOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::TopKV2Options> {
    static const BuiltinOptions enum_value = BuiltinOptions_TopKV2Options;
};

template <>
struct BuiltinOptionsTraits<tflite::SplitOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SplitOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LogSoftmaxOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_LogSoftmaxOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::CastOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_CastOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::DequantizeOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_DequantizeOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::MaximumMinimumOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_MaximumMinimumOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ArgMaxOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_ArgMaxOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LessOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_LessOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::NegOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_NegOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::PadV2Options> {
    static const BuiltinOptions enum_value = BuiltinOptions_PadV2Options;
};

template <>
struct BuiltinOptionsTraits<tflite::GreaterOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_GreaterOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::GreaterEqualOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_GreaterEqualOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LessEqualOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_LessEqualOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SelectOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SelectOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SliceOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SliceOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::TransposeConvOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_TransposeConvOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SparseToDenseOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SparseToDenseOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::TileOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_TileOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ExpandDimsOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_ExpandDimsOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::EqualOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_EqualOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::NotEqualOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_NotEqualOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ShapeOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_ShapeOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::PowOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_PowOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ArgMinOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_ArgMinOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::FakeQuantOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_FakeQuantOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::PackOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_PackOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LogicalOrOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_LogicalOrOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::OneHotOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_OneHotOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LogicalAndOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_LogicalAndOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LogicalNotOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_LogicalNotOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::UnpackOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_UnpackOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::FloorDivOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_FloorDivOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SquareOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_SquareOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ZerosLikeOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_ZerosLikeOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::FillOptions> {
    static const BuiltinOptions enum_value = BuiltinOptions_FillOptions;
};

struct BuiltinOptionsUnion {
    BuiltinOptions type;
    void *value;

    BuiltinOptionsUnion() : type(BuiltinOptions_NONE), value(nullptr) {}
    BuiltinOptionsUnion(BuiltinOptionsUnion &&u) FLATBUFFERS_NOEXCEPT : type(BuiltinOptions_NONE), value(nullptr) {
        std::swap(type, u.type);
        std::swap(value, u.value);
    }
    BuiltinOptionsUnion(const BuiltinOptionsUnion &);
    BuiltinOptionsUnion &operator=(const BuiltinOptionsUnion &u) {
        BuiltinOptionsUnion t(u);
        std::swap(type, t.type);
        std::swap(value, t.value);
        return *this;
    }
    BuiltinOptionsUnion &operator=(BuiltinOptionsUnion &&u) FLATBUFFERS_NOEXCEPT {
        std::swap(type, u.type);
        std::swap(value, u.value);
        return *this;
    }
    ~BuiltinOptionsUnion() {
        Reset();
    }

    void Reset();

#ifndef FLATBUFFERS_CPP98_STL
    template <typename T>
    void Set(T &&val) {
        using RT = typename std::remove_reference<T>::type;
        Reset();
        type = BuiltinOptionsTraits<typename RT::TableType>::enum_value;
        if (type != BuiltinOptions_NONE) {
            value = new RT(std::forward<T>(val));
        }
    }
#endif  // FLATBUFFERS_CPP98_STL

    static void *UnPack(const void *obj, BuiltinOptions type, const flatbuffers::resolver_function_t *resolver);
    flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

    tflite::Conv2DOptionsT *AsConv2DOptions() {
        return type == BuiltinOptions_Conv2DOptions ? reinterpret_cast<tflite::Conv2DOptionsT *>(value) : nullptr;
    }
    const tflite::Conv2DOptionsT *AsConv2DOptions() const {
        return type == BuiltinOptions_Conv2DOptions ? reinterpret_cast<const tflite::Conv2DOptionsT *>(value) : nullptr;
    }
    tflite::DepthwiseConv2DOptionsT *AsDepthwiseConv2DOptions() {
        return type == BuiltinOptions_DepthwiseConv2DOptions
                   ? reinterpret_cast<tflite::DepthwiseConv2DOptionsT *>(value)
                   : nullptr;
    }
    const tflite::DepthwiseConv2DOptionsT *AsDepthwiseConv2DOptions() const {
        return type == BuiltinOptions_DepthwiseConv2DOptions
                   ? reinterpret_cast<const tflite::DepthwiseConv2DOptionsT *>(value)
                   : nullptr;
    }
    tflite::ConcatEmbeddingsOptionsT *AsConcatEmbeddingsOptions() {
        return type == BuiltinOptions_ConcatEmbeddingsOptions
                   ? reinterpret_cast<tflite::ConcatEmbeddingsOptionsT *>(value)
                   : nullptr;
    }
    const tflite::ConcatEmbeddingsOptionsT *AsConcatEmbeddingsOptions() const {
        return type == BuiltinOptions_ConcatEmbeddingsOptions
                   ? reinterpret_cast<const tflite::ConcatEmbeddingsOptionsT *>(value)
                   : nullptr;
    }
    tflite::LSHProjectionOptionsT *AsLSHProjectionOptions() {
        return type == BuiltinOptions_LSHProjectionOptions ? reinterpret_cast<tflite::LSHProjectionOptionsT *>(value)
                                                           : nullptr;
    }
    const tflite::LSHProjectionOptionsT *AsLSHProjectionOptions() const {
        return type == BuiltinOptions_LSHProjectionOptions
                   ? reinterpret_cast<const tflite::LSHProjectionOptionsT *>(value)
                   : nullptr;
    }
    tflite::Pool2DOptionsT *AsPool2DOptions() {
        return type == BuiltinOptions_Pool2DOptions ? reinterpret_cast<tflite::Pool2DOptionsT *>(value) : nullptr;
    }
    const tflite::Pool2DOptionsT *AsPool2DOptions() const {
        return type == BuiltinOptions_Pool2DOptions ? reinterpret_cast<const tflite::Pool2DOptionsT *>(value) : nullptr;
    }
    tflite::SVDFOptionsT *AsSVDFOptions() {
        return type == BuiltinOptions_SVDFOptions ? reinterpret_cast<tflite::SVDFOptionsT *>(value) : nullptr;
    }
    const tflite::SVDFOptionsT *AsSVDFOptions() const {
        return type == BuiltinOptions_SVDFOptions ? reinterpret_cast<const tflite::SVDFOptionsT *>(value) : nullptr;
    }
    tflite::RNNOptionsT *AsRNNOptions() {
        return type == BuiltinOptions_RNNOptions ? reinterpret_cast<tflite::RNNOptionsT *>(value) : nullptr;
    }
    const tflite::RNNOptionsT *AsRNNOptions() const {
        return type == BuiltinOptions_RNNOptions ? reinterpret_cast<const tflite::RNNOptionsT *>(value) : nullptr;
    }
    tflite::FullyConnectedOptionsT *AsFullyConnectedOptions() {
        return type == BuiltinOptions_FullyConnectedOptions ? reinterpret_cast<tflite::FullyConnectedOptionsT *>(value)
                                                            : nullptr;
    }
    const tflite::FullyConnectedOptionsT *AsFullyConnectedOptions() const {
        return type == BuiltinOptions_FullyConnectedOptions
                   ? reinterpret_cast<const tflite::FullyConnectedOptionsT *>(value)
                   : nullptr;
    }
    tflite::SoftmaxOptionsT *AsSoftmaxOptions() {
        return type == BuiltinOptions_SoftmaxOptions ? reinterpret_cast<tflite::SoftmaxOptionsT *>(value) : nullptr;
    }
    const tflite::SoftmaxOptionsT *AsSoftmaxOptions() const {
        return type == BuiltinOptions_SoftmaxOptions ? reinterpret_cast<const tflite::SoftmaxOptionsT *>(value)
                                                     : nullptr;
    }
    tflite::ConcatenationOptionsT *AsConcatenationOptions() {
        return type == BuiltinOptions_ConcatenationOptions ? reinterpret_cast<tflite::ConcatenationOptionsT *>(value)
                                                           : nullptr;
    }
    const tflite::ConcatenationOptionsT *AsConcatenationOptions() const {
        return type == BuiltinOptions_ConcatenationOptions
                   ? reinterpret_cast<const tflite::ConcatenationOptionsT *>(value)
                   : nullptr;
    }
    tflite::AddOptionsT *AsAddOptions() {
        return type == BuiltinOptions_AddOptions ? reinterpret_cast<tflite::AddOptionsT *>(value) : nullptr;
    }
    const tflite::AddOptionsT *AsAddOptions() const {
        return type == BuiltinOptions_AddOptions ? reinterpret_cast<const tflite::AddOptionsT *>(value) : nullptr;
    }
    tflite::L2NormOptionsT *AsL2NormOptions() {
        return type == BuiltinOptions_L2NormOptions ? reinterpret_cast<tflite::L2NormOptionsT *>(value) : nullptr;
    }
    const tflite::L2NormOptionsT *AsL2NormOptions() const {
        return type == BuiltinOptions_L2NormOptions ? reinterpret_cast<const tflite::L2NormOptionsT *>(value) : nullptr;
    }
    tflite::LocalResponseNormalizationOptionsT *AsLocalResponseNormalizationOptions() {
        return type == BuiltinOptions_LocalResponseNormalizationOptions
                   ? reinterpret_cast<tflite::LocalResponseNormalizationOptionsT *>(value)
                   : nullptr;
    }
    const tflite::LocalResponseNormalizationOptionsT *AsLocalResponseNormalizationOptions() const {
        return type == BuiltinOptions_LocalResponseNormalizationOptions
                   ? reinterpret_cast<const tflite::LocalResponseNormalizationOptionsT *>(value)
                   : nullptr;
    }
    tflite::LSTMOptionsT *AsLSTMOptions() {
        return type == BuiltinOptions_LSTMOptions ? reinterpret_cast<tflite::LSTMOptionsT *>(value) : nullptr;
    }
    const tflite::LSTMOptionsT *AsLSTMOptions() const {
        return type == BuiltinOptions_LSTMOptions ? reinterpret_cast<const tflite::LSTMOptionsT *>(value) : nullptr;
    }
    tflite::ResizeBilinearOptionsT *AsResizeBilinearOptions() {
        return type == BuiltinOptions_ResizeBilinearOptions ? reinterpret_cast<tflite::ResizeBilinearOptionsT *>(value)
                                                            : nullptr;
    }
    const tflite::ResizeBilinearOptionsT *AsResizeBilinearOptions() const {
        return type == BuiltinOptions_ResizeBilinearOptions
                   ? reinterpret_cast<const tflite::ResizeBilinearOptionsT *>(value)
                   : nullptr;
    }
    tflite::CallOptionsT *AsCallOptions() {
        return type == BuiltinOptions_CallOptions ? reinterpret_cast<tflite::CallOptionsT *>(value) : nullptr;
    }
    const tflite::CallOptionsT *AsCallOptions() const {
        return type == BuiltinOptions_CallOptions ? reinterpret_cast<const tflite::CallOptionsT *>(value) : nullptr;
    }
    tflite::ReshapeOptionsT *AsReshapeOptions() {
        return type == BuiltinOptions_ReshapeOptions ? reinterpret_cast<tflite::ReshapeOptionsT *>(value) : nullptr;
    }
    const tflite::ReshapeOptionsT *AsReshapeOptions() const {
        return type == BuiltinOptions_ReshapeOptions ? reinterpret_cast<const tflite::ReshapeOptionsT *>(value)
                                                     : nullptr;
    }
    tflite::SkipGramOptionsT *AsSkipGramOptions() {
        return type == BuiltinOptions_SkipGramOptions ? reinterpret_cast<tflite::SkipGramOptionsT *>(value) : nullptr;
    }
    const tflite::SkipGramOptionsT *AsSkipGramOptions() const {
        return type == BuiltinOptions_SkipGramOptions ? reinterpret_cast<const tflite::SkipGramOptionsT *>(value)
                                                      : nullptr;
    }
    tflite::SpaceToDepthOptionsT *AsSpaceToDepthOptions() {
        return type == BuiltinOptions_SpaceToDepthOptions ? reinterpret_cast<tflite::SpaceToDepthOptionsT *>(value)
                                                          : nullptr;
    }
    const tflite::SpaceToDepthOptionsT *AsSpaceToDepthOptions() const {
        return type == BuiltinOptions_SpaceToDepthOptions
                   ? reinterpret_cast<const tflite::SpaceToDepthOptionsT *>(value)
                   : nullptr;
    }
    tflite::EmbeddingLookupSparseOptionsT *AsEmbeddingLookupSparseOptions() {
        return type == BuiltinOptions_EmbeddingLookupSparseOptions
                   ? reinterpret_cast<tflite::EmbeddingLookupSparseOptionsT *>(value)
                   : nullptr;
    }
    const tflite::EmbeddingLookupSparseOptionsT *AsEmbeddingLookupSparseOptions() const {
        return type == BuiltinOptions_EmbeddingLookupSparseOptions
                   ? reinterpret_cast<const tflite::EmbeddingLookupSparseOptionsT *>(value)
                   : nullptr;
    }
    tflite::MulOptionsT *AsMulOptions() {
        return type == BuiltinOptions_MulOptions ? reinterpret_cast<tflite::MulOptionsT *>(value) : nullptr;
    }
    const tflite::MulOptionsT *AsMulOptions() const {
        return type == BuiltinOptions_MulOptions ? reinterpret_cast<const tflite::MulOptionsT *>(value) : nullptr;
    }
    tflite::PadOptionsT *AsPadOptions() {
        return type == BuiltinOptions_PadOptions ? reinterpret_cast<tflite::PadOptionsT *>(value) : nullptr;
    }
    const tflite::PadOptionsT *AsPadOptions() const {
        return type == BuiltinOptions_PadOptions ? reinterpret_cast<const tflite::PadOptionsT *>(value) : nullptr;
    }
    tflite::GatherOptionsT *AsGatherOptions() {
        return type == BuiltinOptions_GatherOptions ? reinterpret_cast<tflite::GatherOptionsT *>(value) : nullptr;
    }
    const tflite::GatherOptionsT *AsGatherOptions() const {
        return type == BuiltinOptions_GatherOptions ? reinterpret_cast<const tflite::GatherOptionsT *>(value) : nullptr;
    }
    tflite::BatchToSpaceNDOptionsT *AsBatchToSpaceNDOptions() {
        return type == BuiltinOptions_BatchToSpaceNDOptions ? reinterpret_cast<tflite::BatchToSpaceNDOptionsT *>(value)
                                                            : nullptr;
    }
    const tflite::BatchToSpaceNDOptionsT *AsBatchToSpaceNDOptions() const {
        return type == BuiltinOptions_BatchToSpaceNDOptions
                   ? reinterpret_cast<const tflite::BatchToSpaceNDOptionsT *>(value)
                   : nullptr;
    }
    tflite::SpaceToBatchNDOptionsT *AsSpaceToBatchNDOptions() {
        return type == BuiltinOptions_SpaceToBatchNDOptions ? reinterpret_cast<tflite::SpaceToBatchNDOptionsT *>(value)
                                                            : nullptr;
    }
    const tflite::SpaceToBatchNDOptionsT *AsSpaceToBatchNDOptions() const {
        return type == BuiltinOptions_SpaceToBatchNDOptions
                   ? reinterpret_cast<const tflite::SpaceToBatchNDOptionsT *>(value)
                   : nullptr;
    }
    tflite::TransposeOptionsT *AsTransposeOptions() {
        return type == BuiltinOptions_TransposeOptions ? reinterpret_cast<tflite::TransposeOptionsT *>(value) : nullptr;
    }
    const tflite::TransposeOptionsT *AsTransposeOptions() const {
        return type == BuiltinOptions_TransposeOptions ? reinterpret_cast<const tflite::TransposeOptionsT *>(value)
                                                       : nullptr;
    }
    tflite::ReducerOptionsT *AsReducerOptions() {
        return type == BuiltinOptions_ReducerOptions ? reinterpret_cast<tflite::ReducerOptionsT *>(value) : nullptr;
    }
    const tflite::ReducerOptionsT *AsReducerOptions() const {
        return type == BuiltinOptions_ReducerOptions ? reinterpret_cast<const tflite::ReducerOptionsT *>(value)
                                                     : nullptr;
    }
    tflite::SubOptionsT *AsSubOptions() {
        return type == BuiltinOptions_SubOptions ? reinterpret_cast<tflite::SubOptionsT *>(value) : nullptr;
    }
    const tflite::SubOptionsT *AsSubOptions() const {
        return type == BuiltinOptions_SubOptions ? reinterpret_cast<const tflite::SubOptionsT *>(value) : nullptr;
    }
    tflite::DivOptionsT *AsDivOptions() {
        return type == BuiltinOptions_DivOptions ? reinterpret_cast<tflite::DivOptionsT *>(value) : nullptr;
    }
    const tflite::DivOptionsT *AsDivOptions() const {
        return type == BuiltinOptions_DivOptions ? reinterpret_cast<const tflite::DivOptionsT *>(value) : nullptr;
    }
    tflite::SqueezeOptionsT *AsSqueezeOptions() {
        return type == BuiltinOptions_SqueezeOptions ? reinterpret_cast<tflite::SqueezeOptionsT *>(value) : nullptr;
    }
    const tflite::SqueezeOptionsT *AsSqueezeOptions() const {
        return type == BuiltinOptions_SqueezeOptions ? reinterpret_cast<const tflite::SqueezeOptionsT *>(value)
                                                     : nullptr;
    }
    tflite::SequenceRNNOptionsT *AsSequenceRNNOptions() {
        return type == BuiltinOptions_SequenceRNNOptions ? reinterpret_cast<tflite::SequenceRNNOptionsT *>(value)
                                                         : nullptr;
    }
    const tflite::SequenceRNNOptionsT *AsSequenceRNNOptions() const {
        return type == BuiltinOptions_SequenceRNNOptions ? reinterpret_cast<const tflite::SequenceRNNOptionsT *>(value)
                                                         : nullptr;
    }
    tflite::StridedSliceOptionsT *AsStridedSliceOptions() {
        return type == BuiltinOptions_StridedSliceOptions ? reinterpret_cast<tflite::StridedSliceOptionsT *>(value)
                                                          : nullptr;
    }
    const tflite::StridedSliceOptionsT *AsStridedSliceOptions() const {
        return type == BuiltinOptions_StridedSliceOptions
                   ? reinterpret_cast<const tflite::StridedSliceOptionsT *>(value)
                   : nullptr;
    }
    tflite::ExpOptionsT *AsExpOptions() {
        return type == BuiltinOptions_ExpOptions ? reinterpret_cast<tflite::ExpOptionsT *>(value) : nullptr;
    }
    const tflite::ExpOptionsT *AsExpOptions() const {
        return type == BuiltinOptions_ExpOptions ? reinterpret_cast<const tflite::ExpOptionsT *>(value) : nullptr;
    }
    tflite::TopKV2OptionsT *AsTopKV2Options() {
        return type == BuiltinOptions_TopKV2Options ? reinterpret_cast<tflite::TopKV2OptionsT *>(value) : nullptr;
    }
    const tflite::TopKV2OptionsT *AsTopKV2Options() const {
        return type == BuiltinOptions_TopKV2Options ? reinterpret_cast<const tflite::TopKV2OptionsT *>(value) : nullptr;
    }
    tflite::SplitOptionsT *AsSplitOptions() {
        return type == BuiltinOptions_SplitOptions ? reinterpret_cast<tflite::SplitOptionsT *>(value) : nullptr;
    }
    const tflite::SplitOptionsT *AsSplitOptions() const {
        return type == BuiltinOptions_SplitOptions ? reinterpret_cast<const tflite::SplitOptionsT *>(value) : nullptr;
    }
    tflite::LogSoftmaxOptionsT *AsLogSoftmaxOptions() {
        return type == BuiltinOptions_LogSoftmaxOptions ? reinterpret_cast<tflite::LogSoftmaxOptionsT *>(value)
                                                        : nullptr;
    }
    const tflite::LogSoftmaxOptionsT *AsLogSoftmaxOptions() const {
        return type == BuiltinOptions_LogSoftmaxOptions ? reinterpret_cast<const tflite::LogSoftmaxOptionsT *>(value)
                                                        : nullptr;
    }
    tflite::CastOptionsT *AsCastOptions() {
        return type == BuiltinOptions_CastOptions ? reinterpret_cast<tflite::CastOptionsT *>(value) : nullptr;
    }
    const tflite::CastOptionsT *AsCastOptions() const {
        return type == BuiltinOptions_CastOptions ? reinterpret_cast<const tflite::CastOptionsT *>(value) : nullptr;
    }
    tflite::DequantizeOptionsT *AsDequantizeOptions() {
        return type == BuiltinOptions_DequantizeOptions ? reinterpret_cast<tflite::DequantizeOptionsT *>(value)
                                                        : nullptr;
    }
    const tflite::DequantizeOptionsT *AsDequantizeOptions() const {
        return type == BuiltinOptions_DequantizeOptions ? reinterpret_cast<const tflite::DequantizeOptionsT *>(value)
                                                        : nullptr;
    }
    tflite::MaximumMinimumOptionsT *AsMaximumMinimumOptions() {
        return type == BuiltinOptions_MaximumMinimumOptions ? reinterpret_cast<tflite::MaximumMinimumOptionsT *>(value)
                                                            : nullptr;
    }
    const tflite::MaximumMinimumOptionsT *AsMaximumMinimumOptions() const {
        return type == BuiltinOptions_MaximumMinimumOptions
                   ? reinterpret_cast<const tflite::MaximumMinimumOptionsT *>(value)
                   : nullptr;
    }
    tflite::ArgMaxOptionsT *AsArgMaxOptions() {
        return type == BuiltinOptions_ArgMaxOptions ? reinterpret_cast<tflite::ArgMaxOptionsT *>(value) : nullptr;
    }
    const tflite::ArgMaxOptionsT *AsArgMaxOptions() const {
        return type == BuiltinOptions_ArgMaxOptions ? reinterpret_cast<const tflite::ArgMaxOptionsT *>(value) : nullptr;
    }
    tflite::LessOptionsT *AsLessOptions() {
        return type == BuiltinOptions_LessOptions ? reinterpret_cast<tflite::LessOptionsT *>(value) : nullptr;
    }
    const tflite::LessOptionsT *AsLessOptions() const {
        return type == BuiltinOptions_LessOptions ? reinterpret_cast<const tflite::LessOptionsT *>(value) : nullptr;
    }
    tflite::NegOptionsT *AsNegOptions() {
        return type == BuiltinOptions_NegOptions ? reinterpret_cast<tflite::NegOptionsT *>(value) : nullptr;
    }
    const tflite::NegOptionsT *AsNegOptions() const {
        return type == BuiltinOptions_NegOptions ? reinterpret_cast<const tflite::NegOptionsT *>(value) : nullptr;
    }
    tflite::PadV2OptionsT *AsPadV2Options() {
        return type == BuiltinOptions_PadV2Options ? reinterpret_cast<tflite::PadV2OptionsT *>(value) : nullptr;
    }
    const tflite::PadV2OptionsT *AsPadV2Options() const {
        return type == BuiltinOptions_PadV2Options ? reinterpret_cast<const tflite::PadV2OptionsT *>(value) : nullptr;
    }
    tflite::GreaterOptionsT *AsGreaterOptions() {
        return type == BuiltinOptions_GreaterOptions ? reinterpret_cast<tflite::GreaterOptionsT *>(value) : nullptr;
    }
    const tflite::GreaterOptionsT *AsGreaterOptions() const {
        return type == BuiltinOptions_GreaterOptions ? reinterpret_cast<const tflite::GreaterOptionsT *>(value)
                                                     : nullptr;
    }
    tflite::GreaterEqualOptionsT *AsGreaterEqualOptions() {
        return type == BuiltinOptions_GreaterEqualOptions ? reinterpret_cast<tflite::GreaterEqualOptionsT *>(value)
                                                          : nullptr;
    }
    const tflite::GreaterEqualOptionsT *AsGreaterEqualOptions() const {
        return type == BuiltinOptions_GreaterEqualOptions
                   ? reinterpret_cast<const tflite::GreaterEqualOptionsT *>(value)
                   : nullptr;
    }
    tflite::LessEqualOptionsT *AsLessEqualOptions() {
        return type == BuiltinOptions_LessEqualOptions ? reinterpret_cast<tflite::LessEqualOptionsT *>(value) : nullptr;
    }
    const tflite::LessEqualOptionsT *AsLessEqualOptions() const {
        return type == BuiltinOptions_LessEqualOptions ? reinterpret_cast<const tflite::LessEqualOptionsT *>(value)
                                                       : nullptr;
    }
    tflite::SelectOptionsT *AsSelectOptions() {
        return type == BuiltinOptions_SelectOptions ? reinterpret_cast<tflite::SelectOptionsT *>(value) : nullptr;
    }
    const tflite::SelectOptionsT *AsSelectOptions() const {
        return type == BuiltinOptions_SelectOptions ? reinterpret_cast<const tflite::SelectOptionsT *>(value) : nullptr;
    }
    tflite::SliceOptionsT *AsSliceOptions() {
        return type == BuiltinOptions_SliceOptions ? reinterpret_cast<tflite::SliceOptionsT *>(value) : nullptr;
    }
    const tflite::SliceOptionsT *AsSliceOptions() const {
        return type == BuiltinOptions_SliceOptions ? reinterpret_cast<const tflite::SliceOptionsT *>(value) : nullptr;
    }
    tflite::TransposeConvOptionsT *AsTransposeConvOptions() {
        return type == BuiltinOptions_TransposeConvOptions ? reinterpret_cast<tflite::TransposeConvOptionsT *>(value)
                                                           : nullptr;
    }
    const tflite::TransposeConvOptionsT *AsTransposeConvOptions() const {
        return type == BuiltinOptions_TransposeConvOptions
                   ? reinterpret_cast<const tflite::TransposeConvOptionsT *>(value)
                   : nullptr;
    }
    tflite::SparseToDenseOptionsT *AsSparseToDenseOptions() {
        return type == BuiltinOptions_SparseToDenseOptions ? reinterpret_cast<tflite::SparseToDenseOptionsT *>(value)
                                                           : nullptr;
    }
    const tflite::SparseToDenseOptionsT *AsSparseToDenseOptions() const {
        return type == BuiltinOptions_SparseToDenseOptions
                   ? reinterpret_cast<const tflite::SparseToDenseOptionsT *>(value)
                   : nullptr;
    }
    tflite::TileOptionsT *AsTileOptions() {
        return type == BuiltinOptions_TileOptions ? reinterpret_cast<tflite::TileOptionsT *>(value) : nullptr;
    }
    const tflite::TileOptionsT *AsTileOptions() const {
        return type == BuiltinOptions_TileOptions ? reinterpret_cast<const tflite::TileOptionsT *>(value) : nullptr;
    }
    tflite::ExpandDimsOptionsT *AsExpandDimsOptions() {
        return type == BuiltinOptions_ExpandDimsOptions ? reinterpret_cast<tflite::ExpandDimsOptionsT *>(value)
                                                        : nullptr;
    }
    const tflite::ExpandDimsOptionsT *AsExpandDimsOptions() const {
        return type == BuiltinOptions_ExpandDimsOptions ? reinterpret_cast<const tflite::ExpandDimsOptionsT *>(value)
                                                        : nullptr;
    }
    tflite::EqualOptionsT *AsEqualOptions() {
        return type == BuiltinOptions_EqualOptions ? reinterpret_cast<tflite::EqualOptionsT *>(value) : nullptr;
    }
    const tflite::EqualOptionsT *AsEqualOptions() const {
        return type == BuiltinOptions_EqualOptions ? reinterpret_cast<const tflite::EqualOptionsT *>(value) : nullptr;
    }
    tflite::NotEqualOptionsT *AsNotEqualOptions() {
        return type == BuiltinOptions_NotEqualOptions ? reinterpret_cast<tflite::NotEqualOptionsT *>(value) : nullptr;
    }
    const tflite::NotEqualOptionsT *AsNotEqualOptions() const {
        return type == BuiltinOptions_NotEqualOptions ? reinterpret_cast<const tflite::NotEqualOptionsT *>(value)
                                                      : nullptr;
    }
    tflite::ShapeOptionsT *AsShapeOptions() {
        return type == BuiltinOptions_ShapeOptions ? reinterpret_cast<tflite::ShapeOptionsT *>(value) : nullptr;
    }
    const tflite::ShapeOptionsT *AsShapeOptions() const {
        return type == BuiltinOptions_ShapeOptions ? reinterpret_cast<const tflite::ShapeOptionsT *>(value) : nullptr;
    }
    tflite::PowOptionsT *AsPowOptions() {
        return type == BuiltinOptions_PowOptions ? reinterpret_cast<tflite::PowOptionsT *>(value) : nullptr;
    }
    const tflite::PowOptionsT *AsPowOptions() const {
        return type == BuiltinOptions_PowOptions ? reinterpret_cast<const tflite::PowOptionsT *>(value) : nullptr;
    }
    tflite::ArgMinOptionsT *AsArgMinOptions() {
        return type == BuiltinOptions_ArgMinOptions ? reinterpret_cast<tflite::ArgMinOptionsT *>(value) : nullptr;
    }
    const tflite::ArgMinOptionsT *AsArgMinOptions() const {
        return type == BuiltinOptions_ArgMinOptions ? reinterpret_cast<const tflite::ArgMinOptionsT *>(value) : nullptr;
    }
    tflite::FakeQuantOptionsT *AsFakeQuantOptions() {
        return type == BuiltinOptions_FakeQuantOptions ? reinterpret_cast<tflite::FakeQuantOptionsT *>(value) : nullptr;
    }
    const tflite::FakeQuantOptionsT *AsFakeQuantOptions() const {
        return type == BuiltinOptions_FakeQuantOptions ? reinterpret_cast<const tflite::FakeQuantOptionsT *>(value)
                                                       : nullptr;
    }
    tflite::PackOptionsT *AsPackOptions() {
        return type == BuiltinOptions_PackOptions ? reinterpret_cast<tflite::PackOptionsT *>(value) : nullptr;
    }
    const tflite::PackOptionsT *AsPackOptions() const {
        return type == BuiltinOptions_PackOptions ? reinterpret_cast<const tflite::PackOptionsT *>(value) : nullptr;
    }
    tflite::LogicalOrOptionsT *AsLogicalOrOptions() {
        return type == BuiltinOptions_LogicalOrOptions ? reinterpret_cast<tflite::LogicalOrOptionsT *>(value) : nullptr;
    }
    const tflite::LogicalOrOptionsT *AsLogicalOrOptions() const {
        return type == BuiltinOptions_LogicalOrOptions ? reinterpret_cast<const tflite::LogicalOrOptionsT *>(value)
                                                       : nullptr;
    }
    tflite::OneHotOptionsT *AsOneHotOptions() {
        return type == BuiltinOptions_OneHotOptions ? reinterpret_cast<tflite::OneHotOptionsT *>(value) : nullptr;
    }
    const tflite::OneHotOptionsT *AsOneHotOptions() const {
        return type == BuiltinOptions_OneHotOptions ? reinterpret_cast<const tflite::OneHotOptionsT *>(value) : nullptr;
    }
    tflite::LogicalAndOptionsT *AsLogicalAndOptions() {
        return type == BuiltinOptions_LogicalAndOptions ? reinterpret_cast<tflite::LogicalAndOptionsT *>(value)
                                                        : nullptr;
    }
    const tflite::LogicalAndOptionsT *AsLogicalAndOptions() const {
        return type == BuiltinOptions_LogicalAndOptions ? reinterpret_cast<const tflite::LogicalAndOptionsT *>(value)
                                                        : nullptr;
    }
    tflite::LogicalNotOptionsT *AsLogicalNotOptions() {
        return type == BuiltinOptions_LogicalNotOptions ? reinterpret_cast<tflite::LogicalNotOptionsT *>(value)
                                                        : nullptr;
    }
    const tflite::LogicalNotOptionsT *AsLogicalNotOptions() const {
        return type == BuiltinOptions_LogicalNotOptions ? reinterpret_cast<const tflite::LogicalNotOptionsT *>(value)
                                                        : nullptr;
    }
    tflite::UnpackOptionsT *AsUnpackOptions() {
        return type == BuiltinOptions_UnpackOptions ? reinterpret_cast<tflite::UnpackOptionsT *>(value) : nullptr;
    }
    const tflite::UnpackOptionsT *AsUnpackOptions() const {
        return type == BuiltinOptions_UnpackOptions ? reinterpret_cast<const tflite::UnpackOptionsT *>(value) : nullptr;
    }
    tflite::FloorDivOptionsT *AsFloorDivOptions() {
        return type == BuiltinOptions_FloorDivOptions ? reinterpret_cast<tflite::FloorDivOptionsT *>(value) : nullptr;
    }
    const tflite::FloorDivOptionsT *AsFloorDivOptions() const {
        return type == BuiltinOptions_FloorDivOptions ? reinterpret_cast<const tflite::FloorDivOptionsT *>(value)
                                                      : nullptr;
    }
    tflite::SquareOptionsT *AsSquareOptions() {
        return type == BuiltinOptions_SquareOptions ? reinterpret_cast<tflite::SquareOptionsT *>(value) : nullptr;
    }
    const tflite::SquareOptionsT *AsSquareOptions() const {
        return type == BuiltinOptions_SquareOptions ? reinterpret_cast<const tflite::SquareOptionsT *>(value) : nullptr;
    }
    tflite::ZerosLikeOptionsT *AsZerosLikeOptions() {
        return type == BuiltinOptions_ZerosLikeOptions ? reinterpret_cast<tflite::ZerosLikeOptionsT *>(value) : nullptr;
    }
    const tflite::ZerosLikeOptionsT *AsZerosLikeOptions() const {
        return type == BuiltinOptions_ZerosLikeOptions ? reinterpret_cast<const tflite::ZerosLikeOptionsT *>(value)
                                                       : nullptr;
    }
    tflite::FillOptionsT *AsFillOptions() {
        return type == BuiltinOptions_FillOptions ? reinterpret_cast<tflite::FillOptionsT *>(value) : nullptr;
    }
    const tflite::FillOptionsT *AsFillOptions() const {
        return type == BuiltinOptions_FillOptions ? reinterpret_cast<const tflite::FillOptionsT *>(value) : nullptr;
    }
};

bool VerifyBuiltinOptions(flatbuffers::Verifier &verifier, const void *obj, BuiltinOptions type);
bool VerifyBuiltinOptionsVector(flatbuffers::Verifier &verifier,
                                const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                                const flatbuffers::Vector<uint8_t> *types);

enum Padding { Padding_SAME = 0, Padding_VALID = 1, Padding_MIN = Padding_SAME, Padding_MAX = Padding_VALID };

inline const Padding (&EnumValuesPadding())[2] {
    static const Padding values[] = {Padding_SAME, Padding_VALID};
    return values;
}

inline const char *const *EnumNamesPadding() {
    static const char *const names[3] = {"SAME", "VALID", nullptr};
    return names;
}

inline const char *EnumNamePadding(Padding e) {
    if (flatbuffers::IsOutRange(e, Padding_SAME, Padding_VALID))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesPadding()[index];
}

enum ActivationFunctionType {
    ActivationFunctionType_NONE         = 0,
    ActivationFunctionType_RELU         = 1,
    ActivationFunctionType_RELU_N1_TO_1 = 2,
    ActivationFunctionType_RELU6        = 3,
    ActivationFunctionType_TANH         = 4,
    ActivationFunctionType_SIGN_BIT     = 5,
    ActivationFunctionType_MIN          = ActivationFunctionType_NONE,
    ActivationFunctionType_MAX          = ActivationFunctionType_SIGN_BIT
};

inline const ActivationFunctionType (&EnumValuesActivationFunctionType())[6] {
    static const ActivationFunctionType values[] = {
        ActivationFunctionType_NONE,  ActivationFunctionType_RELU, ActivationFunctionType_RELU_N1_TO_1,
        ActivationFunctionType_RELU6, ActivationFunctionType_TANH, ActivationFunctionType_SIGN_BIT};
    return values;
}

inline const char *const *EnumNamesActivationFunctionType() {
    static const char *const names[7] = {"NONE", "RELU", "RELU_N1_TO_1", "RELU6", "TANH", "SIGN_BIT", nullptr};
    return names;
}

inline const char *EnumNameActivationFunctionType(ActivationFunctionType e) {
    if (flatbuffers::IsOutRange(e, ActivationFunctionType_NONE, ActivationFunctionType_SIGN_BIT))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesActivationFunctionType()[index];
}

enum LSHProjectionType {
    LSHProjectionType_UNKNOWN = 0,
    LSHProjectionType_SPARSE  = 1,
    LSHProjectionType_DENSE   = 2,
    LSHProjectionType_MIN     = LSHProjectionType_UNKNOWN,
    LSHProjectionType_MAX     = LSHProjectionType_DENSE
};

inline const LSHProjectionType (&EnumValuesLSHProjectionType())[3] {
    static const LSHProjectionType values[] = {LSHProjectionType_UNKNOWN, LSHProjectionType_SPARSE,
                                               LSHProjectionType_DENSE};
    return values;
}

inline const char *const *EnumNamesLSHProjectionType() {
    static const char *const names[4] = {"UNKNOWN", "SPARSE", "DENSE", nullptr};
    return names;
}

inline const char *EnumNameLSHProjectionType(LSHProjectionType e) {
    if (flatbuffers::IsOutRange(e, LSHProjectionType_UNKNOWN, LSHProjectionType_DENSE))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesLSHProjectionType()[index];
}

enum FullyConnectedOptionsWeightsFormat {
    FullyConnectedOptionsWeightsFormat_DEFAULT          = 0,
    FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8 = 1,
    FullyConnectedOptionsWeightsFormat_MIN              = FullyConnectedOptionsWeightsFormat_DEFAULT,
    FullyConnectedOptionsWeightsFormat_MAX              = FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8
};

inline const FullyConnectedOptionsWeightsFormat (&EnumValuesFullyConnectedOptionsWeightsFormat())[2] {
    static const FullyConnectedOptionsWeightsFormat values[] = {FullyConnectedOptionsWeightsFormat_DEFAULT,
                                                                FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8};
    return values;
}

inline const char *const *EnumNamesFullyConnectedOptionsWeightsFormat() {
    static const char *const names[3] = {"DEFAULT", "SHUFFLED4x16INT8", nullptr};
    return names;
}

inline const char *EnumNameFullyConnectedOptionsWeightsFormat(FullyConnectedOptionsWeightsFormat e) {
    if (flatbuffers::IsOutRange(e, FullyConnectedOptionsWeightsFormat_DEFAULT,
                                FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesFullyConnectedOptionsWeightsFormat()[index];
}

enum LSTMKernelType {
    LSTMKernelType_FULL  = 0,
    LSTMKernelType_BASIC = 1,
    LSTMKernelType_MIN   = LSTMKernelType_FULL,
    LSTMKernelType_MAX   = LSTMKernelType_BASIC
};

inline const LSTMKernelType (&EnumValuesLSTMKernelType())[2] {
    static const LSTMKernelType values[] = {LSTMKernelType_FULL, LSTMKernelType_BASIC};
    return values;
}

inline const char *const *EnumNamesLSTMKernelType() {
    static const char *const names[3] = {"FULL", "BASIC", nullptr};
    return names;
}

inline const char *EnumNameLSTMKernelType(LSTMKernelType e) {
    if (flatbuffers::IsOutRange(e, LSTMKernelType_FULL, LSTMKernelType_BASIC))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesLSTMKernelType()[index];
}

enum CombinerType {
    CombinerType_SUM   = 0,
    CombinerType_MEAN  = 1,
    CombinerType_SQRTN = 2,
    CombinerType_MIN   = CombinerType_SUM,
    CombinerType_MAX   = CombinerType_SQRTN
};

inline const CombinerType (&EnumValuesCombinerType())[3] {
    static const CombinerType values[] = {CombinerType_SUM, CombinerType_MEAN, CombinerType_SQRTN};
    return values;
}

inline const char *const *EnumNamesCombinerType() {
    static const char *const names[4] = {"SUM", "MEAN", "SQRTN", nullptr};
    return names;
}

inline const char *EnumNameCombinerType(CombinerType e) {
    if (flatbuffers::IsOutRange(e, CombinerType_SUM, CombinerType_SQRTN))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesCombinerType()[index];
}

enum CustomOptionsFormat {
    CustomOptionsFormat_FLEXBUFFERS = 0,
    CustomOptionsFormat_MIN         = CustomOptionsFormat_FLEXBUFFERS,
    CustomOptionsFormat_MAX         = CustomOptionsFormat_FLEXBUFFERS
};

inline const CustomOptionsFormat (&EnumValuesCustomOptionsFormat())[1] {
    static const CustomOptionsFormat values[] = {CustomOptionsFormat_FLEXBUFFERS};
    return values;
}

inline const char *const *EnumNamesCustomOptionsFormat() {
    static const char *const names[2] = {"FLEXBUFFERS", nullptr};
    return names;
}

inline const char *EnumNameCustomOptionsFormat(CustomOptionsFormat e) {
    if (flatbuffers::IsOutRange(e, CustomOptionsFormat_FLEXBUFFERS, CustomOptionsFormat_FLEXBUFFERS))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesCustomOptionsFormat()[index];
}

struct QuantizationParametersT : public flatbuffers::NativeTable {
    typedef QuantizationParameters TableType;
    std::vector<float> min;
    std::vector<float> max;
    std::vector<float> scale;
    std::vector<int64_t> zeroPoint;
    QuantizationParametersT() {}
};

struct QuantizationParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef QuantizationParametersT NativeTableType;
    typedef QuantizationParametersBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return QuantizationParametersTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_MIN       = 4,
        VT_MAX       = 6,
        VT_SCALE     = 8,
        VT_ZEROPOINT = 10
    };
    const flatbuffers::Vector<float> *min() const {
        return GetPointer<const flatbuffers::Vector<float> *>(VT_MIN);
    }
    const flatbuffers::Vector<float> *max() const {
        return GetPointer<const flatbuffers::Vector<float> *>(VT_MAX);
    }
    const flatbuffers::Vector<float> *scale() const {
        return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALE);
    }
    const flatbuffers::Vector<int64_t> *zeroPoint() const {
        return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_ZEROPOINT);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_MIN) && verifier.VerifyVector(min()) &&
               VerifyOffset(verifier, VT_MAX) && verifier.VerifyVector(max()) && VerifyOffset(verifier, VT_SCALE) &&
               verifier.VerifyVector(scale()) && VerifyOffset(verifier, VT_ZEROPOINT) &&
               verifier.VerifyVector(zeroPoint()) && verifier.EndTable();
    }
    QuantizationParametersT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(QuantizationParametersT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<QuantizationParameters> Pack(
        flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT *_o,
        const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QuantizationParametersBuilder {
    typedef QuantizationParameters Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_min(flatbuffers::Offset<flatbuffers::Vector<float>> min) {
        fbb_.AddOffset(QuantizationParameters::VT_MIN, min);
    }
    void add_max(flatbuffers::Offset<flatbuffers::Vector<float>> max) {
        fbb_.AddOffset(QuantizationParameters::VT_MAX, max);
    }
    void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale) {
        fbb_.AddOffset(QuantizationParameters::VT_SCALE, scale);
    }
    void add_zeroPoint(flatbuffers::Offset<flatbuffers::Vector<int64_t>> zeroPoint) {
        fbb_.AddOffset(QuantizationParameters::VT_ZEROPOINT, zeroPoint);
    }
    explicit QuantizationParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    QuantizationParametersBuilder &operator=(const QuantizationParametersBuilder &);
    flatbuffers::Offset<QuantizationParameters> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<QuantizationParameters>(end);
        return o;
    }
};

inline flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(
    flatbuffers::FlatBufferBuilder &_fbb, flatbuffers::Offset<flatbuffers::Vector<float>> min = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> max = 0, flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> zeroPoint = 0) {
    QuantizationParametersBuilder builder_(_fbb);
    builder_.add_zeroPoint(zeroPoint);
    builder_.add_scale(scale);
    builder_.add_max(max);
    builder_.add_min(min);
    return builder_.Finish();
}

inline flatbuffers::Offset<QuantizationParameters> CreateQuantizationParametersDirect(
    flatbuffers::FlatBufferBuilder &_fbb, const std::vector<float> *min = nullptr,
    const std::vector<float> *max = nullptr, const std::vector<float> *scale = nullptr,
    const std::vector<int64_t> *zeroPoint = nullptr) {
    auto min__       = min ? _fbb.CreateVector<float>(*min) : 0;
    auto max__       = max ? _fbb.CreateVector<float>(*max) : 0;
    auto scale__     = scale ? _fbb.CreateVector<float>(*scale) : 0;
    auto zeroPoint__ = zeroPoint ? _fbb.CreateVector<int64_t>(*zeroPoint) : 0;
    return tflite::CreateQuantizationParameters(_fbb, min__, max__, scale__, zeroPoint__);
}

flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(
    flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorT : public flatbuffers::NativeTable {
    typedef Tensor TableType;
    std::vector<int32_t> shape;
    tflite::TensorType type;
    uint32_t buffer;
    std::string name;
    std::unique_ptr<tflite::QuantizationParametersT> quantization;
    bool is_variable;
    TensorT() : type(tflite::TensorType_FLOAT32), buffer(0), is_variable(false) {}
};

struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef TensorT NativeTableType;
    typedef TensorBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return TensorTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_SHAPE        = 4,
        VT_TYPE         = 6,
        VT_BUFFER       = 8,
        VT_NAME         = 10,
        VT_QUANTIZATION = 12,
        VT_IS_VARIABLE  = 14
    };
    const flatbuffers::Vector<int32_t> *shape() const {
        return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SHAPE);
    }
    tflite::TensorType type() const {
        return static_cast<tflite::TensorType>(GetField<int8_t>(VT_TYPE, 0));
    }
    uint32_t buffer() const {
        return GetField<uint32_t>(VT_BUFFER, 0);
    }
    const flatbuffers::String *name() const {
        return GetPointer<const flatbuffers::String *>(VT_NAME);
    }
    const tflite::QuantizationParameters *quantization() const {
        return GetPointer<const tflite::QuantizationParameters *>(VT_QUANTIZATION);
    }
    bool is_variable() const {
        return GetField<uint8_t>(VT_IS_VARIABLE, 0) != 0;
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_SHAPE) && verifier.VerifyVector(shape()) &&
               VerifyField<int8_t>(verifier, VT_TYPE) && VerifyField<uint32_t>(verifier, VT_BUFFER) &&
               VerifyOffset(verifier, VT_NAME) && verifier.VerifyString(name()) &&
               VerifyOffset(verifier, VT_QUANTIZATION) && verifier.VerifyTable(quantization()) &&
               VerifyField<uint8_t>(verifier, VT_IS_VARIABLE) && verifier.EndTable();
    }
    TensorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(TensorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<Tensor> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o,
                                            const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorBuilder {
    typedef Tensor Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape) {
        fbb_.AddOffset(Tensor::VT_SHAPE, shape);
    }
    void add_type(tflite::TensorType type) {
        fbb_.AddElement<int8_t>(Tensor::VT_TYPE, static_cast<int8_t>(type), 0);
    }
    void add_buffer(uint32_t buffer) {
        fbb_.AddElement<uint32_t>(Tensor::VT_BUFFER, buffer, 0);
    }
    void add_name(flatbuffers::Offset<flatbuffers::String> name) {
        fbb_.AddOffset(Tensor::VT_NAME, name);
    }
    void add_quantization(flatbuffers::Offset<tflite::QuantizationParameters> quantization) {
        fbb_.AddOffset(Tensor::VT_QUANTIZATION, quantization);
    }
    void add_is_variable(bool is_variable) {
        fbb_.AddElement<uint8_t>(Tensor::VT_IS_VARIABLE, static_cast<uint8_t>(is_variable), 0);
    }
    explicit TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    TensorBuilder &operator=(const TensorBuilder &);
    flatbuffers::Offset<Tensor> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<Tensor>(end);
        return o;
    }
};

inline flatbuffers::Offset<Tensor> CreateTensor(flatbuffers::FlatBufferBuilder &_fbb,
                                                flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape = 0,
                                                tflite::TensorType type = tflite::TensorType_FLOAT32,
                                                uint32_t buffer = 0, flatbuffers::Offset<flatbuffers::String> name = 0,
                                                flatbuffers::Offset<tflite::QuantizationParameters> quantization = 0,
                                                bool is_variable = false) {
    TensorBuilder builder_(_fbb);
    builder_.add_quantization(quantization);
    builder_.add_name(name);
    builder_.add_buffer(buffer);
    builder_.add_shape(shape);
    builder_.add_is_variable(is_variable);
    builder_.add_type(type);
    return builder_.Finish();
}

inline flatbuffers::Offset<Tensor> CreateTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb, const std::vector<int32_t> *shape = nullptr,
    tflite::TensorType type = tflite::TensorType_FLOAT32, uint32_t buffer = 0, const char *name = nullptr,
    flatbuffers::Offset<tflite::QuantizationParameters> quantization = 0, bool is_variable = false) {
    auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
    auto name__  = name ? _fbb.CreateString(name) : 0;
    return tflite::CreateTensor(_fbb, shape__, type, buffer, name__, quantization, is_variable);
}

flatbuffers::Offset<Tensor> CreateTensor(flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o,
                                         const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Conv2DOptionsT : public flatbuffers::NativeTable {
    typedef Conv2DOptions TableType;
    tflite::Padding padding;
    int32_t stride_w;
    int32_t stride_h;
    tflite::ActivationFunctionType fused_activation_function;
    int32_t dilation_w_factor;
    int32_t dilation_h_factor;
    Conv2DOptionsT()
        : padding(tflite::Padding_SAME),
          stride_w(0),
          stride_h(0),
          fused_activation_function(tflite::ActivationFunctionType_NONE),
          dilation_w_factor(1),
          dilation_h_factor(1) {}
};

struct Conv2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef Conv2DOptionsT NativeTableType;
    typedef Conv2DOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return Conv2DOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_PADDING                   = 4,
        VT_STRIDE_W                  = 6,
        VT_STRIDE_H                  = 8,
        VT_FUSED_ACTIVATION_FUNCTION = 10,
        VT_DILATION_W_FACTOR         = 12,
        VT_DILATION_H_FACTOR         = 14
    };
    tflite::Padding padding() const {
        return static_cast<tflite::Padding>(GetField<int8_t>(VT_PADDING, 0));
    }
    int32_t stride_w() const {
        return GetField<int32_t>(VT_STRIDE_W, 0);
    }
    int32_t stride_h() const {
        return GetField<int32_t>(VT_STRIDE_H, 0);
    }
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    int32_t dilation_w_factor() const {
        return GetField<int32_t>(VT_DILATION_W_FACTOR, 1);
    }
    int32_t dilation_h_factor() const {
        return GetField<int32_t>(VT_DILATION_H_FACTOR, 1);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_PADDING) &&
               VerifyField<int32_t>(verifier, VT_STRIDE_W) && VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
               VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
               VerifyField<int32_t>(verifier, VT_DILATION_W_FACTOR) &&
               VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR) && verifier.EndTable();
    }
    Conv2DOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(Conv2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<Conv2DOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Conv2DOptionsBuilder {
    typedef Conv2DOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_padding(tflite::Padding padding) {
        fbb_.AddElement<int8_t>(Conv2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
    }
    void add_stride_w(int32_t stride_w) {
        fbb_.AddElement<int32_t>(Conv2DOptions::VT_STRIDE_W, stride_w, 0);
    }
    void add_stride_h(int32_t stride_h) {
        fbb_.AddElement<int32_t>(Conv2DOptions::VT_STRIDE_H, stride_h, 0);
    }
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(Conv2DOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    void add_dilation_w_factor(int32_t dilation_w_factor) {
        fbb_.AddElement<int32_t>(Conv2DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
    }
    void add_dilation_h_factor(int32_t dilation_h_factor) {
        fbb_.AddElement<int32_t>(Conv2DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
    }
    explicit Conv2DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    Conv2DOptionsBuilder &operator=(const Conv2DOptionsBuilder &);
    flatbuffers::Offset<Conv2DOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<Conv2DOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(
    flatbuffers::FlatBufferBuilder &_fbb, tflite::Padding padding = tflite::Padding_SAME, int32_t stride_w = 0,
    int32_t stride_h                                         = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    int32_t dilation_w_factor = 1, int32_t dilation_h_factor = 1) {
    Conv2DOptionsBuilder builder_(_fbb);
    builder_.add_dilation_h_factor(dilation_h_factor);
    builder_.add_dilation_w_factor(dilation_w_factor);
    builder_.add_stride_h(stride_h);
    builder_.add_stride_w(stride_w);
    builder_.add_fused_activation_function(fused_activation_function);
    builder_.add_padding(padding);
    return builder_.Finish();
}

flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Pool2DOptionsT : public flatbuffers::NativeTable {
    typedef Pool2DOptions TableType;
    tflite::Padding padding;
    int32_t stride_w;
    int32_t stride_h;
    int32_t filter_width;
    int32_t filter_height;
    tflite::ActivationFunctionType fused_activation_function;
    Pool2DOptionsT()
        : padding(tflite::Padding_SAME),
          stride_w(0),
          stride_h(0),
          filter_width(0),
          filter_height(0),
          fused_activation_function(tflite::ActivationFunctionType_NONE) {}
};

struct Pool2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef Pool2DOptionsT NativeTableType;
    typedef Pool2DOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return Pool2DOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_PADDING                   = 4,
        VT_STRIDE_W                  = 6,
        VT_STRIDE_H                  = 8,
        VT_FILTER_WIDTH              = 10,
        VT_FILTER_HEIGHT             = 12,
        VT_FUSED_ACTIVATION_FUNCTION = 14
    };
    tflite::Padding padding() const {
        return static_cast<tflite::Padding>(GetField<int8_t>(VT_PADDING, 0));
    }
    int32_t stride_w() const {
        return GetField<int32_t>(VT_STRIDE_W, 0);
    }
    int32_t stride_h() const {
        return GetField<int32_t>(VT_STRIDE_H, 0);
    }
    int32_t filter_width() const {
        return GetField<int32_t>(VT_FILTER_WIDTH, 0);
    }
    int32_t filter_height() const {
        return GetField<int32_t>(VT_FILTER_HEIGHT, 0);
    }
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_PADDING) &&
               VerifyField<int32_t>(verifier, VT_STRIDE_W) && VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
               VerifyField<int32_t>(verifier, VT_FILTER_WIDTH) && VerifyField<int32_t>(verifier, VT_FILTER_HEIGHT) &&
               VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) && verifier.EndTable();
    }
    Pool2DOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(Pool2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<Pool2DOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Pool2DOptionsBuilder {
    typedef Pool2DOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_padding(tflite::Padding padding) {
        fbb_.AddElement<int8_t>(Pool2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
    }
    void add_stride_w(int32_t stride_w) {
        fbb_.AddElement<int32_t>(Pool2DOptions::VT_STRIDE_W, stride_w, 0);
    }
    void add_stride_h(int32_t stride_h) {
        fbb_.AddElement<int32_t>(Pool2DOptions::VT_STRIDE_H, stride_h, 0);
    }
    void add_filter_width(int32_t filter_width) {
        fbb_.AddElement<int32_t>(Pool2DOptions::VT_FILTER_WIDTH, filter_width, 0);
    }
    void add_filter_height(int32_t filter_height) {
        fbb_.AddElement<int32_t>(Pool2DOptions::VT_FILTER_HEIGHT, filter_height, 0);
    }
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(Pool2DOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    explicit Pool2DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    Pool2DOptionsBuilder &operator=(const Pool2DOptionsBuilder &);
    flatbuffers::Offset<Pool2DOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<Pool2DOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(
    flatbuffers::FlatBufferBuilder &_fbb, tflite::Padding padding = tflite::Padding_SAME, int32_t stride_w = 0,
    int32_t stride_h = 0, int32_t filter_width = 0, int32_t filter_height = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
    Pool2DOptionsBuilder builder_(_fbb);
    builder_.add_filter_height(filter_height);
    builder_.add_filter_width(filter_width);
    builder_.add_stride_h(stride_h);
    builder_.add_stride_w(stride_w);
    builder_.add_fused_activation_function(fused_activation_function);
    builder_.add_padding(padding);
    return builder_.Finish();
}

flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DepthwiseConv2DOptionsT : public flatbuffers::NativeTable {
    typedef DepthwiseConv2DOptions TableType;
    tflite::Padding padding;
    int32_t stride_w;
    int32_t stride_h;
    int32_t depth_multiplier;
    tflite::ActivationFunctionType fused_activation_function;
    int32_t dilation_w_factor;
    int32_t dilation_h_factor;
    DepthwiseConv2DOptionsT()
        : padding(tflite::Padding_SAME),
          stride_w(0),
          stride_h(0),
          depth_multiplier(0),
          fused_activation_function(tflite::ActivationFunctionType_NONE),
          dilation_w_factor(1),
          dilation_h_factor(1) {}
};

struct DepthwiseConv2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef DepthwiseConv2DOptionsT NativeTableType;
    typedef DepthwiseConv2DOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return DepthwiseConv2DOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_PADDING                   = 4,
        VT_STRIDE_W                  = 6,
        VT_STRIDE_H                  = 8,
        VT_DEPTH_MULTIPLIER          = 10,
        VT_FUSED_ACTIVATION_FUNCTION = 12,
        VT_DILATION_W_FACTOR         = 14,
        VT_DILATION_H_FACTOR         = 16
    };
    tflite::Padding padding() const {
        return static_cast<tflite::Padding>(GetField<int8_t>(VT_PADDING, 0));
    }
    int32_t stride_w() const {
        return GetField<int32_t>(VT_STRIDE_W, 0);
    }
    int32_t stride_h() const {
        return GetField<int32_t>(VT_STRIDE_H, 0);
    }
    int32_t depth_multiplier() const {
        return GetField<int32_t>(VT_DEPTH_MULTIPLIER, 0);
    }
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    int32_t dilation_w_factor() const {
        return GetField<int32_t>(VT_DILATION_W_FACTOR, 1);
    }
    int32_t dilation_h_factor() const {
        return GetField<int32_t>(VT_DILATION_H_FACTOR, 1);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_PADDING) &&
               VerifyField<int32_t>(verifier, VT_STRIDE_W) && VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
               VerifyField<int32_t>(verifier, VT_DEPTH_MULTIPLIER) &&
               VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
               VerifyField<int32_t>(verifier, VT_DILATION_W_FACTOR) &&
               VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR) && verifier.EndTable();
    }
    DepthwiseConv2DOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(DepthwiseConv2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<DepthwiseConv2DOptions> Pack(
        flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT *_o,
        const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DepthwiseConv2DOptionsBuilder {
    typedef DepthwiseConv2DOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_padding(tflite::Padding padding) {
        fbb_.AddElement<int8_t>(DepthwiseConv2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
    }
    void add_stride_w(int32_t stride_w) {
        fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_STRIDE_W, stride_w, 0);
    }
    void add_stride_h(int32_t stride_h) {
        fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_STRIDE_H, stride_h, 0);
    }
    void add_depth_multiplier(int32_t depth_multiplier) {
        fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DEPTH_MULTIPLIER, depth_multiplier, 0);
    }
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(DepthwiseConv2DOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    void add_dilation_w_factor(int32_t dilation_w_factor) {
        fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
    }
    void add_dilation_h_factor(int32_t dilation_h_factor) {
        fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
    }
    explicit DepthwiseConv2DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    DepthwiseConv2DOptionsBuilder &operator=(const DepthwiseConv2DOptionsBuilder &);
    flatbuffers::Offset<DepthwiseConv2DOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<DepthwiseConv2DOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(
    flatbuffers::FlatBufferBuilder &_fbb, tflite::Padding padding = tflite::Padding_SAME, int32_t stride_w = 0,
    int32_t stride_h = 0, int32_t depth_multiplier = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    int32_t dilation_w_factor = 1, int32_t dilation_h_factor = 1) {
    DepthwiseConv2DOptionsBuilder builder_(_fbb);
    builder_.add_dilation_h_factor(dilation_h_factor);
    builder_.add_dilation_w_factor(dilation_w_factor);
    builder_.add_depth_multiplier(depth_multiplier);
    builder_.add_stride_h(stride_h);
    builder_.add_stride_w(stride_w);
    builder_.add_fused_activation_function(fused_activation_function);
    builder_.add_padding(padding);
    return builder_.Finish();
}

flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConcatEmbeddingsOptionsT : public flatbuffers::NativeTable {
    typedef ConcatEmbeddingsOptions TableType;
    int32_t num_channels;
    std::vector<int32_t> num_columns_per_channel;
    std::vector<int32_t> embedding_dim_per_channel;
    ConcatEmbeddingsOptionsT() : num_channels(0) {}
};

struct ConcatEmbeddingsOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ConcatEmbeddingsOptionsT NativeTableType;
    typedef ConcatEmbeddingsOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ConcatEmbeddingsOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_NUM_CHANNELS              = 4,
        VT_NUM_COLUMNS_PER_CHANNEL   = 6,
        VT_EMBEDDING_DIM_PER_CHANNEL = 8
    };
    int32_t num_channels() const {
        return GetField<int32_t>(VT_NUM_CHANNELS, 0);
    }
    const flatbuffers::Vector<int32_t> *num_columns_per_channel() const {
        return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_NUM_COLUMNS_PER_CHANNEL);
    }
    const flatbuffers::Vector<int32_t> *embedding_dim_per_channel() const {
        return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_EMBEDDING_DIM_PER_CHANNEL);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_NUM_CHANNELS) &&
               VerifyOffset(verifier, VT_NUM_COLUMNS_PER_CHANNEL) && verifier.VerifyVector(num_columns_per_channel()) &&
               VerifyOffset(verifier, VT_EMBEDDING_DIM_PER_CHANNEL) &&
               verifier.VerifyVector(embedding_dim_per_channel()) && verifier.EndTable();
    }
    ConcatEmbeddingsOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ConcatEmbeddingsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<ConcatEmbeddingsOptions> Pack(
        flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT *_o,
        const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConcatEmbeddingsOptionsBuilder {
    typedef ConcatEmbeddingsOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_num_channels(int32_t num_channels) {
        fbb_.AddElement<int32_t>(ConcatEmbeddingsOptions::VT_NUM_CHANNELS, num_channels, 0);
    }
    void add_num_columns_per_channel(flatbuffers::Offset<flatbuffers::Vector<int32_t>> num_columns_per_channel) {
        fbb_.AddOffset(ConcatEmbeddingsOptions::VT_NUM_COLUMNS_PER_CHANNEL, num_columns_per_channel);
    }
    void add_embedding_dim_per_channel(flatbuffers::Offset<flatbuffers::Vector<int32_t>> embedding_dim_per_channel) {
        fbb_.AddOffset(ConcatEmbeddingsOptions::VT_EMBEDDING_DIM_PER_CHANNEL, embedding_dim_per_channel);
    }
    explicit ConcatEmbeddingsOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ConcatEmbeddingsOptionsBuilder &operator=(const ConcatEmbeddingsOptionsBuilder &);
    flatbuffers::Offset<ConcatEmbeddingsOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<ConcatEmbeddingsOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(
    flatbuffers::FlatBufferBuilder &_fbb, int32_t num_channels = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> num_columns_per_channel   = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> embedding_dim_per_channel = 0) {
    ConcatEmbeddingsOptionsBuilder builder_(_fbb);
    builder_.add_embedding_dim_per_channel(embedding_dim_per_channel);
    builder_.add_num_columns_per_channel(num_columns_per_channel);
    builder_.add_num_channels(num_channels);
    return builder_.Finish();
}

inline flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb, int32_t num_channels = 0,
    const std::vector<int32_t> *num_columns_per_channel   = nullptr,
    const std::vector<int32_t> *embedding_dim_per_channel = nullptr) {
    auto num_columns_per_channel__ = num_columns_per_channel ? _fbb.CreateVector<int32_t>(*num_columns_per_channel) : 0;
    auto embedding_dim_per_channel__ =
        embedding_dim_per_channel ? _fbb.CreateVector<int32_t>(*embedding_dim_per_channel) : 0;
    return tflite::CreateConcatEmbeddingsOptions(_fbb, num_channels, num_columns_per_channel__,
                                                 embedding_dim_per_channel__);
}

flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LSHProjectionOptionsT : public flatbuffers::NativeTable {
    typedef LSHProjectionOptions TableType;
    tflite::LSHProjectionType type;
    LSHProjectionOptionsT() : type(tflite::LSHProjectionType_UNKNOWN) {}
};

struct LSHProjectionOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef LSHProjectionOptionsT NativeTableType;
    typedef LSHProjectionOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return LSHProjectionOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_TYPE = 4 };
    tflite::LSHProjectionType type() const {
        return static_cast<tflite::LSHProjectionType>(GetField<int8_t>(VT_TYPE, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_TYPE) && verifier.EndTable();
    }
    LSHProjectionOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(LSHProjectionOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<LSHProjectionOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                          const LSHProjectionOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LSHProjectionOptionsBuilder {
    typedef LSHProjectionOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_type(tflite::LSHProjectionType type) {
        fbb_.AddElement<int8_t>(LSHProjectionOptions::VT_TYPE, static_cast<int8_t>(type), 0);
    }
    explicit LSHProjectionOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    LSHProjectionOptionsBuilder &operator=(const LSHProjectionOptionsBuilder &);
    flatbuffers::Offset<LSHProjectionOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<LSHProjectionOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<LSHProjectionOptions> CreateLSHProjectionOptions(
    flatbuffers::FlatBufferBuilder &_fbb, tflite::LSHProjectionType type = tflite::LSHProjectionType_UNKNOWN) {
    LSHProjectionOptionsBuilder builder_(_fbb);
    builder_.add_type(type);
    return builder_.Finish();
}

flatbuffers::Offset<LSHProjectionOptions> CreateLSHProjectionOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SVDFOptionsT : public flatbuffers::NativeTable {
    typedef SVDFOptions TableType;
    int32_t rank;
    tflite::ActivationFunctionType fused_activation_function;
    SVDFOptionsT() : rank(0), fused_activation_function(tflite::ActivationFunctionType_NONE) {}
};

struct SVDFOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SVDFOptionsT NativeTableType;
    typedef SVDFOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SVDFOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_RANK = 4, VT_FUSED_ACTIVATION_FUNCTION = 6 };
    int32_t rank() const {
        return GetField<int32_t>(VT_RANK, 0);
    }
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_RANK) &&
               VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) && verifier.EndTable();
    }
    SVDFOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SVDFOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SVDFOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SVDFOptionsBuilder {
    typedef SVDFOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_rank(int32_t rank) {
        fbb_.AddElement<int32_t>(SVDFOptions::VT_RANK, rank, 0);
    }
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(SVDFOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    explicit SVDFOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SVDFOptionsBuilder &operator=(const SVDFOptionsBuilder &);
    flatbuffers::Offset<SVDFOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SVDFOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(
    flatbuffers::FlatBufferBuilder &_fbb, int32_t rank = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
    SVDFOptionsBuilder builder_(_fbb);
    builder_.add_rank(rank);
    builder_.add_fused_activation_function(fused_activation_function);
    return builder_.Finish();
}

flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RNNOptionsT : public flatbuffers::NativeTable {
    typedef RNNOptions TableType;
    tflite::ActivationFunctionType fused_activation_function;
    RNNOptionsT() : fused_activation_function(tflite::ActivationFunctionType_NONE) {}
};

struct RNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef RNNOptionsT NativeTableType;
    typedef RNNOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return RNNOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_FUSED_ACTIVATION_FUNCTION = 4 };
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
               verifier.EndTable();
    }
    RNNOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(RNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<RNNOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RNNOptionsBuilder {
    typedef RNNOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(RNNOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    explicit RNNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    RNNOptionsBuilder &operator=(const RNNOptionsBuilder &);
    flatbuffers::Offset<RNNOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<RNNOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<RNNOptions> CreateRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
    RNNOptionsBuilder builder_(_fbb);
    builder_.add_fused_activation_function(fused_activation_function);
    return builder_.Finish();
}

flatbuffers::Offset<RNNOptions> CreateRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SequenceRNNOptionsT : public flatbuffers::NativeTable {
    typedef SequenceRNNOptions TableType;
    bool time_major;
    tflite::ActivationFunctionType fused_activation_function;
    SequenceRNNOptionsT() : time_major(false), fused_activation_function(tflite::ActivationFunctionType_NONE) {}
};

struct SequenceRNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SequenceRNNOptionsT NativeTableType;
    typedef SequenceRNNOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SequenceRNNOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_TIME_MAJOR                = 4,
        VT_FUSED_ACTIVATION_FUNCTION = 6
    };
    bool time_major() const {
        return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0;
    }
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
               VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) && verifier.EndTable();
    }
    SequenceRNNOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SequenceRNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SequenceRNNOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                        const SequenceRNNOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SequenceRNNOptionsBuilder {
    typedef SequenceRNNOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_time_major(bool time_major) {
        fbb_.AddElement<uint8_t>(SequenceRNNOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 0);
    }
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(SequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    explicit SequenceRNNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SequenceRNNOptionsBuilder &operator=(const SequenceRNNOptionsBuilder &);
    flatbuffers::Offset<SequenceRNNOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SequenceRNNOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb, bool time_major = false,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
    SequenceRNNOptionsBuilder builder_(_fbb);
    builder_.add_fused_activation_function(fused_activation_function);
    builder_.add_time_major(time_major);
    return builder_.Finish();
}

flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BidirectionalSequenceRNNOptionsT : public flatbuffers::NativeTable {
    typedef BidirectionalSequenceRNNOptions TableType;
    bool time_major;
    tflite::ActivationFunctionType fused_activation_function;
    BidirectionalSequenceRNNOptionsT()
        : time_major(false), fused_activation_function(tflite::ActivationFunctionType_NONE) {}
};

struct BidirectionalSequenceRNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef BidirectionalSequenceRNNOptionsT NativeTableType;
    typedef BidirectionalSequenceRNNOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return BidirectionalSequenceRNNOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_TIME_MAJOR                = 4,
        VT_FUSED_ACTIVATION_FUNCTION = 6
    };
    bool time_major() const {
        return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0;
    }
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
               VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) && verifier.EndTable();
    }
    BidirectionalSequenceRNNOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(BidirectionalSequenceRNNOptionsT *_o,
                  const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<BidirectionalSequenceRNNOptions> Pack(
        flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT *_o,
        const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BidirectionalSequenceRNNOptionsBuilder {
    typedef BidirectionalSequenceRNNOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_time_major(bool time_major) {
        fbb_.AddElement<uint8_t>(BidirectionalSequenceRNNOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 0);
    }
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(BidirectionalSequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    explicit BidirectionalSequenceRNNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    BidirectionalSequenceRNNOptionsBuilder &operator=(const BidirectionalSequenceRNNOptionsBuilder &);
    flatbuffers::Offset<BidirectionalSequenceRNNOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<BidirectionalSequenceRNNOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb, bool time_major = false,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
    BidirectionalSequenceRNNOptionsBuilder builder_(_fbb);
    builder_.add_fused_activation_function(fused_activation_function);
    builder_.add_time_major(time_major);
    return builder_.Finish();
}

flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FullyConnectedOptionsT : public flatbuffers::NativeTable {
    typedef FullyConnectedOptions TableType;
    tflite::ActivationFunctionType fused_activation_function;
    tflite::FullyConnectedOptionsWeightsFormat weights_format;
    FullyConnectedOptionsT()
        : fused_activation_function(tflite::ActivationFunctionType_NONE),
          weights_format(tflite::FullyConnectedOptionsWeightsFormat_DEFAULT) {}
};

struct FullyConnectedOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef FullyConnectedOptionsT NativeTableType;
    typedef FullyConnectedOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return FullyConnectedOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_FUSED_ACTIVATION_FUNCTION = 4,
        VT_WEIGHTS_FORMAT            = 6
    };
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    tflite::FullyConnectedOptionsWeightsFormat weights_format() const {
        return static_cast<tflite::FullyConnectedOptionsWeightsFormat>(GetField<int8_t>(VT_WEIGHTS_FORMAT, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
               VerifyField<int8_t>(verifier, VT_WEIGHTS_FORMAT) && verifier.EndTable();
    }
    FullyConnectedOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(FullyConnectedOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<FullyConnectedOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                           const FullyConnectedOptionsT *_o,
                                                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FullyConnectedOptionsBuilder {
    typedef FullyConnectedOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(FullyConnectedOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    void add_weights_format(tflite::FullyConnectedOptionsWeightsFormat weights_format) {
        fbb_.AddElement<int8_t>(FullyConnectedOptions::VT_WEIGHTS_FORMAT, static_cast<int8_t>(weights_format), 0);
    }
    explicit FullyConnectedOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    FullyConnectedOptionsBuilder &operator=(const FullyConnectedOptionsBuilder &);
    flatbuffers::Offset<FullyConnectedOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<FullyConnectedOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function  = tflite::ActivationFunctionType_NONE,
    tflite::FullyConnectedOptionsWeightsFormat weights_format = tflite::FullyConnectedOptionsWeightsFormat_DEFAULT) {
    FullyConnectedOptionsBuilder builder_(_fbb);
    builder_.add_weights_format(weights_format);
    builder_.add_fused_activation_function(fused_activation_function);
    return builder_.Finish();
}

flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SoftmaxOptionsT : public flatbuffers::NativeTable {
    typedef SoftmaxOptions TableType;
    float beta;
    SoftmaxOptionsT() : beta(0.0f) {}
};

struct SoftmaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SoftmaxOptionsT NativeTableType;
    typedef SoftmaxOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SoftmaxOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_BETA = 4 };
    float beta() const {
        return GetField<float>(VT_BETA, 0.0f);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<float>(verifier, VT_BETA) && verifier.EndTable();
    }
    SoftmaxOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SoftmaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SoftmaxOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT *_o,
                                                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SoftmaxOptionsBuilder {
    typedef SoftmaxOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_beta(float beta) {
        fbb_.AddElement<float>(SoftmaxOptions::VT_BETA, beta, 0.0f);
    }
    explicit SoftmaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SoftmaxOptionsBuilder &operator=(const SoftmaxOptionsBuilder &);
    flatbuffers::Offset<SoftmaxOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SoftmaxOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SoftmaxOptions> CreateSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                float beta = 0.0f) {
    SoftmaxOptionsBuilder builder_(_fbb);
    builder_.add_beta(beta);
    return builder_.Finish();
}

flatbuffers::Offset<SoftmaxOptions> CreateSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                         const SoftmaxOptionsT *_o,
                                                         const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConcatenationOptionsT : public flatbuffers::NativeTable {
    typedef ConcatenationOptions TableType;
    int32_t axis;
    tflite::ActivationFunctionType fused_activation_function;
    ConcatenationOptionsT() : axis(0), fused_activation_function(tflite::ActivationFunctionType_NONE) {}
};

struct ConcatenationOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ConcatenationOptionsT NativeTableType;
    typedef ConcatenationOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ConcatenationOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_AXIS = 4, VT_FUSED_ACTIVATION_FUNCTION = 6 };
    int32_t axis() const {
        return GetField<int32_t>(VT_AXIS, 0);
    }
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_AXIS) &&
               VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) && verifier.EndTable();
    }
    ConcatenationOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ConcatenationOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<ConcatenationOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                          const ConcatenationOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConcatenationOptionsBuilder {
    typedef ConcatenationOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_axis(int32_t axis) {
        fbb_.AddElement<int32_t>(ConcatenationOptions::VT_AXIS, axis, 0);
    }
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(ConcatenationOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    explicit ConcatenationOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ConcatenationOptionsBuilder &operator=(const ConcatenationOptionsBuilder &);
    flatbuffers::Offset<ConcatenationOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<ConcatenationOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(
    flatbuffers::FlatBufferBuilder &_fbb, int32_t axis = 0,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
    ConcatenationOptionsBuilder builder_(_fbb);
    builder_.add_axis(axis);
    builder_.add_fused_activation_function(fused_activation_function);
    return builder_.Finish();
}

flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddOptionsT : public flatbuffers::NativeTable {
    typedef AddOptions TableType;
    tflite::ActivationFunctionType fused_activation_function;
    AddOptionsT() : fused_activation_function(tflite::ActivationFunctionType_NONE) {}
};

struct AddOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef AddOptionsT NativeTableType;
    typedef AddOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return AddOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_FUSED_ACTIVATION_FUNCTION = 4 };
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
               verifier.EndTable();
    }
    AddOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(AddOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<AddOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddOptionsBuilder {
    typedef AddOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(AddOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    explicit AddOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    AddOptionsBuilder &operator=(const AddOptionsBuilder &);
    flatbuffers::Offset<AddOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<AddOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<AddOptions> CreateAddOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
    AddOptionsBuilder builder_(_fbb);
    builder_.add_fused_activation_function(fused_activation_function);
    return builder_.Finish();
}

flatbuffers::Offset<AddOptions> CreateAddOptions(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MulOptionsT : public flatbuffers::NativeTable {
    typedef MulOptions TableType;
    tflite::ActivationFunctionType fused_activation_function;
    MulOptionsT() : fused_activation_function(tflite::ActivationFunctionType_NONE) {}
};

struct MulOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef MulOptionsT NativeTableType;
    typedef MulOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return MulOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_FUSED_ACTIVATION_FUNCTION = 4 };
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
               verifier.EndTable();
    }
    MulOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(MulOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<MulOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MulOptionsBuilder {
    typedef MulOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(MulOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    explicit MulOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    MulOptionsBuilder &operator=(const MulOptionsBuilder &);
    flatbuffers::Offset<MulOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<MulOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<MulOptions> CreateMulOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
    MulOptionsBuilder builder_(_fbb);
    builder_.add_fused_activation_function(fused_activation_function);
    return builder_.Finish();
}

flatbuffers::Offset<MulOptions> CreateMulOptions(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct L2NormOptionsT : public flatbuffers::NativeTable {
    typedef L2NormOptions TableType;
    tflite::ActivationFunctionType fused_activation_function;
    L2NormOptionsT() : fused_activation_function(tflite::ActivationFunctionType_NONE) {}
};

struct L2NormOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef L2NormOptionsT NativeTableType;
    typedef L2NormOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return L2NormOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_FUSED_ACTIVATION_FUNCTION = 4 };
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
               verifier.EndTable();
    }
    L2NormOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(L2NormOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<L2NormOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct L2NormOptionsBuilder {
    typedef L2NormOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(L2NormOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    explicit L2NormOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    L2NormOptionsBuilder &operator=(const L2NormOptionsBuilder &);
    flatbuffers::Offset<L2NormOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<L2NormOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
    L2NormOptionsBuilder builder_(_fbb);
    builder_.add_fused_activation_function(fused_activation_function);
    return builder_.Finish();
}

flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LocalResponseNormalizationOptionsT : public flatbuffers::NativeTable {
    typedef LocalResponseNormalizationOptions TableType;
    int32_t radius;
    float bias;
    float alpha;
    float beta;
    LocalResponseNormalizationOptionsT() : radius(0), bias(0.0f), alpha(0.0f), beta(0.0f) {}
};

struct LocalResponseNormalizationOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef LocalResponseNormalizationOptionsT NativeTableType;
    typedef LocalResponseNormalizationOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return LocalResponseNormalizationOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_RADIUS = 4,
        VT_BIAS   = 6,
        VT_ALPHA  = 8,
        VT_BETA   = 10
    };
    int32_t radius() const {
        return GetField<int32_t>(VT_RADIUS, 0);
    }
    float bias() const {
        return GetField<float>(VT_BIAS, 0.0f);
    }
    float alpha() const {
        return GetField<float>(VT_ALPHA, 0.0f);
    }
    float beta() const {
        return GetField<float>(VT_BETA, 0.0f);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_RADIUS) &&
               VerifyField<float>(verifier, VT_BIAS) && VerifyField<float>(verifier, VT_ALPHA) &&
               VerifyField<float>(verifier, VT_BETA) && verifier.EndTable();
    }
    LocalResponseNormalizationOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(LocalResponseNormalizationOptionsT *_o,
                  const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<LocalResponseNormalizationOptions> Pack(
        flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT *_o,
        const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LocalResponseNormalizationOptionsBuilder {
    typedef LocalResponseNormalizationOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_radius(int32_t radius) {
        fbb_.AddElement<int32_t>(LocalResponseNormalizationOptions::VT_RADIUS, radius, 0);
    }
    void add_bias(float bias) {
        fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_BIAS, bias, 0.0f);
    }
    void add_alpha(float alpha) {
        fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_ALPHA, alpha, 0.0f);
    }
    void add_beta(float beta) {
        fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_BETA, beta, 0.0f);
    }
    explicit LocalResponseNormalizationOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    LocalResponseNormalizationOptionsBuilder &operator=(const LocalResponseNormalizationOptionsBuilder &);
    flatbuffers::Offset<LocalResponseNormalizationOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<LocalResponseNormalizationOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(
    flatbuffers::FlatBufferBuilder &_fbb, int32_t radius = 0, float bias = 0.0f, float alpha = 0.0f,
    float beta = 0.0f) {
    LocalResponseNormalizationOptionsBuilder builder_(_fbb);
    builder_.add_beta(beta);
    builder_.add_alpha(alpha);
    builder_.add_bias(bias);
    builder_.add_radius(radius);
    return builder_.Finish();
}

flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LSTMOptionsT : public flatbuffers::NativeTable {
    typedef LSTMOptions TableType;
    tflite::ActivationFunctionType fused_activation_function;
    float cell_clip;
    float proj_clip;
    tflite::LSTMKernelType kernel_type;
    LSTMOptionsT()
        : fused_activation_function(tflite::ActivationFunctionType_NONE),
          cell_clip(0.0f),
          proj_clip(0.0f),
          kernel_type(tflite::LSTMKernelType_FULL) {}
};

struct LSTMOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef LSTMOptionsT NativeTableType;
    typedef LSTMOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return LSTMOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_FUSED_ACTIVATION_FUNCTION = 4,
        VT_CELL_CLIP                 = 6,
        VT_PROJ_CLIP                 = 8,
        VT_KERNEL_TYPE               = 10
    };
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    float cell_clip() const {
        return GetField<float>(VT_CELL_CLIP, 0.0f);
    }
    float proj_clip() const {
        return GetField<float>(VT_PROJ_CLIP, 0.0f);
    }
    tflite::LSTMKernelType kernel_type() const {
        return static_cast<tflite::LSTMKernelType>(GetField<int8_t>(VT_KERNEL_TYPE, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
               VerifyField<float>(verifier, VT_CELL_CLIP) && VerifyField<float>(verifier, VT_PROJ_CLIP) &&
               VerifyField<int8_t>(verifier, VT_KERNEL_TYPE) && verifier.EndTable();
    }
    LSTMOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(LSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<LSTMOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LSTMOptionsBuilder {
    typedef LSTMOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(LSTMOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    void add_cell_clip(float cell_clip) {
        fbb_.AddElement<float>(LSTMOptions::VT_CELL_CLIP, cell_clip, 0.0f);
    }
    void add_proj_clip(float proj_clip) {
        fbb_.AddElement<float>(LSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0f);
    }
    void add_kernel_type(tflite::LSTMKernelType kernel_type) {
        fbb_.AddElement<int8_t>(LSTMOptions::VT_KERNEL_TYPE, static_cast<int8_t>(kernel_type), 0);
    }
    explicit LSTMOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    LSTMOptionsBuilder &operator=(const LSTMOptionsBuilder &);
    flatbuffers::Offset<LSTMOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<LSTMOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,
    float cell_clip = 0.0f, float proj_clip = 0.0f, tflite::LSTMKernelType kernel_type = tflite::LSTMKernelType_FULL) {
    LSTMOptionsBuilder builder_(_fbb);
    builder_.add_proj_clip(proj_clip);
    builder_.add_cell_clip(cell_clip);
    builder_.add_kernel_type(kernel_type);
    builder_.add_fused_activation_function(fused_activation_function);
    return builder_.Finish();
}

flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResizeBilinearOptionsT : public flatbuffers::NativeTable {
    typedef ResizeBilinearOptions TableType;
    bool alignCorners;
    ResizeBilinearOptionsT() : alignCorners(false) {}
};

struct ResizeBilinearOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ResizeBilinearOptionsT NativeTableType;
    typedef ResizeBilinearOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ResizeBilinearOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_ALIGNCORNERS = 8 };
    bool alignCorners() const {
        return GetField<uint8_t>(VT_ALIGNCORNERS, 0) != 0;
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_ALIGNCORNERS) && verifier.EndTable();
    }
    ResizeBilinearOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ResizeBilinearOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<ResizeBilinearOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                           const ResizeBilinearOptionsT *_o,
                                                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResizeBilinearOptionsBuilder {
    typedef ResizeBilinearOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_alignCorners(bool alignCorners) {
        fbb_.AddElement<uint8_t>(ResizeBilinearOptions::VT_ALIGNCORNERS, static_cast<uint8_t>(alignCorners), 0);
    }
    explicit ResizeBilinearOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ResizeBilinearOptionsBuilder &operator=(const ResizeBilinearOptionsBuilder &);
    flatbuffers::Offset<ResizeBilinearOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<ResizeBilinearOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                              bool alignCorners = false) {
    ResizeBilinearOptionsBuilder builder_(_fbb);
    builder_.add_alignCorners(alignCorners);
    return builder_.Finish();
}

flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CallOptionsT : public flatbuffers::NativeTable {
    typedef CallOptions TableType;
    uint32_t subgraph;
    CallOptionsT() : subgraph(0) {}
};

struct CallOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef CallOptionsT NativeTableType;
    typedef CallOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return CallOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_SUBGRAPH = 4 };
    uint32_t subgraph() const {
        return GetField<uint32_t>(VT_SUBGRAPH, 0);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_SUBGRAPH) && verifier.EndTable();
    }
    CallOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(CallOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<CallOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CallOptionsBuilder {
    typedef CallOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_subgraph(uint32_t subgraph) {
        fbb_.AddElement<uint32_t>(CallOptions::VT_SUBGRAPH, subgraph, 0);
    }
    explicit CallOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    CallOptionsBuilder &operator=(const CallOptionsBuilder &);
    flatbuffers::Offset<CallOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<CallOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<CallOptions> CreateCallOptions(flatbuffers::FlatBufferBuilder &_fbb, uint32_t subgraph = 0) {
    CallOptionsBuilder builder_(_fbb);
    builder_.add_subgraph(subgraph);
    return builder_.Finish();
}

flatbuffers::Offset<CallOptions> CreateCallOptions(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PadOptionsT : public flatbuffers::NativeTable {
    typedef PadOptions TableType;
    PadOptionsT() {}
};

struct PadOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef PadOptionsT NativeTableType;
    typedef PadOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return PadOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    PadOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(PadOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<PadOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PadOptionsBuilder {
    typedef PadOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit PadOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    PadOptionsBuilder &operator=(const PadOptionsBuilder &);
    flatbuffers::Offset<PadOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<PadOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<PadOptions> CreatePadOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    PadOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<PadOptions> CreatePadOptions(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PadV2OptionsT : public flatbuffers::NativeTable {
    typedef PadV2Options TableType;
    PadV2OptionsT() {}
};

struct PadV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef PadV2OptionsT NativeTableType;
    typedef PadV2OptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return PadV2OptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    PadV2OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(PadV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<PadV2Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT *_o,
                                                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PadV2OptionsBuilder {
    typedef PadV2Options Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit PadV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    PadV2OptionsBuilder &operator=(const PadV2OptionsBuilder &);
    flatbuffers::Offset<PadV2Options> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<PadV2Options>(end);
        return o;
    }
};

inline flatbuffers::Offset<PadV2Options> CreatePadV2Options(flatbuffers::FlatBufferBuilder &_fbb) {
    PadV2OptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<PadV2Options> CreatePadV2Options(flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT *_o,
                                                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReshapeOptionsT : public flatbuffers::NativeTable {
    typedef ReshapeOptions TableType;
    std::vector<int32_t> new_shape;
    ReshapeOptionsT() {}
};

struct ReshapeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ReshapeOptionsT NativeTableType;
    typedef ReshapeOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ReshapeOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_NEW_SHAPE = 4 };
    const flatbuffers::Vector<int32_t> *new_shape() const {
        return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_NEW_SHAPE);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NEW_SHAPE) &&
               verifier.VerifyVector(new_shape()) && verifier.EndTable();
    }
    ReshapeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ReshapeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<ReshapeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT *_o,
                                                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReshapeOptionsBuilder {
    typedef ReshapeOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_new_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> new_shape) {
        fbb_.AddOffset(ReshapeOptions::VT_NEW_SHAPE, new_shape);
    }
    explicit ReshapeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ReshapeOptionsBuilder &operator=(const ReshapeOptionsBuilder &);
    flatbuffers::Offset<ReshapeOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<ReshapeOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<ReshapeOptions> CreateReshapeOptions(
    flatbuffers::FlatBufferBuilder &_fbb, flatbuffers::Offset<flatbuffers::Vector<int32_t>> new_shape = 0) {
    ReshapeOptionsBuilder builder_(_fbb);
    builder_.add_new_shape(new_shape);
    return builder_.Finish();
}

inline flatbuffers::Offset<ReshapeOptions> CreateReshapeOptionsDirect(flatbuffers::FlatBufferBuilder &_fbb,
                                                                      const std::vector<int32_t> *new_shape = nullptr) {
    auto new_shape__ = new_shape ? _fbb.CreateVector<int32_t>(*new_shape) : 0;
    return tflite::CreateReshapeOptions(_fbb, new_shape__);
}

flatbuffers::Offset<ReshapeOptions> CreateReshapeOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                         const ReshapeOptionsT *_o,
                                                         const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpaceToBatchNDOptionsT : public flatbuffers::NativeTable {
    typedef SpaceToBatchNDOptions TableType;
    SpaceToBatchNDOptionsT() {}
};

struct SpaceToBatchNDOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SpaceToBatchNDOptionsT NativeTableType;
    typedef SpaceToBatchNDOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SpaceToBatchNDOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    SpaceToBatchNDOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SpaceToBatchNDOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SpaceToBatchNDOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                           const SpaceToBatchNDOptionsT *_o,
                                                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpaceToBatchNDOptionsBuilder {
    typedef SpaceToBatchNDOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit SpaceToBatchNDOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SpaceToBatchNDOptionsBuilder &operator=(const SpaceToBatchNDOptionsBuilder &);
    flatbuffers::Offset<SpaceToBatchNDOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SpaceToBatchNDOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SpaceToBatchNDOptions> CreateSpaceToBatchNDOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    SpaceToBatchNDOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<SpaceToBatchNDOptions> CreateSpaceToBatchNDOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchToSpaceNDOptionsT : public flatbuffers::NativeTable {
    typedef BatchToSpaceNDOptions TableType;
    BatchToSpaceNDOptionsT() {}
};

struct BatchToSpaceNDOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef BatchToSpaceNDOptionsT NativeTableType;
    typedef BatchToSpaceNDOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return BatchToSpaceNDOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    BatchToSpaceNDOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(BatchToSpaceNDOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<BatchToSpaceNDOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                           const BatchToSpaceNDOptionsT *_o,
                                                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchToSpaceNDOptionsBuilder {
    typedef BatchToSpaceNDOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit BatchToSpaceNDOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    BatchToSpaceNDOptionsBuilder &operator=(const BatchToSpaceNDOptionsBuilder &);
    flatbuffers::Offset<BatchToSpaceNDOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<BatchToSpaceNDOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<BatchToSpaceNDOptions> CreateBatchToSpaceNDOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    BatchToSpaceNDOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<BatchToSpaceNDOptions> CreateBatchToSpaceNDOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SkipGramOptionsT : public flatbuffers::NativeTable {
    typedef SkipGramOptions TableType;
    int32_t ngram_size;
    int32_t max_skip_size;
    bool include_all_ngrams;
    SkipGramOptionsT() : ngram_size(0), max_skip_size(0), include_all_ngrams(false) {}
};

struct SkipGramOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SkipGramOptionsT NativeTableType;
    typedef SkipGramOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SkipGramOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_NGRAM_SIZE         = 4,
        VT_MAX_SKIP_SIZE      = 6,
        VT_INCLUDE_ALL_NGRAMS = 8
    };
    int32_t ngram_size() const {
        return GetField<int32_t>(VT_NGRAM_SIZE, 0);
    }
    int32_t max_skip_size() const {
        return GetField<int32_t>(VT_MAX_SKIP_SIZE, 0);
    }
    bool include_all_ngrams() const {
        return GetField<uint8_t>(VT_INCLUDE_ALL_NGRAMS, 0) != 0;
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_NGRAM_SIZE) &&
               VerifyField<int32_t>(verifier, VT_MAX_SKIP_SIZE) &&
               VerifyField<uint8_t>(verifier, VT_INCLUDE_ALL_NGRAMS) && verifier.EndTable();
    }
    SkipGramOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SkipGramOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SkipGramOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT *_o,
                                                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SkipGramOptionsBuilder {
    typedef SkipGramOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_ngram_size(int32_t ngram_size) {
        fbb_.AddElement<int32_t>(SkipGramOptions::VT_NGRAM_SIZE, ngram_size, 0);
    }
    void add_max_skip_size(int32_t max_skip_size) {
        fbb_.AddElement<int32_t>(SkipGramOptions::VT_MAX_SKIP_SIZE, max_skip_size, 0);
    }
    void add_include_all_ngrams(bool include_all_ngrams) {
        fbb_.AddElement<uint8_t>(SkipGramOptions::VT_INCLUDE_ALL_NGRAMS, static_cast<uint8_t>(include_all_ngrams), 0);
    }
    explicit SkipGramOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SkipGramOptionsBuilder &operator=(const SkipGramOptionsBuilder &);
    flatbuffers::Offset<SkipGramOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SkipGramOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                  int32_t ngram_size = 0, int32_t max_skip_size = 0,
                                                                  bool include_all_ngrams = false) {
    SkipGramOptionsBuilder builder_(_fbb);
    builder_.add_max_skip_size(max_skip_size);
    builder_.add_ngram_size(ngram_size);
    builder_.add_include_all_ngrams(include_all_ngrams);
    return builder_.Finish();
}

flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                           const SkipGramOptionsT *_o,
                                                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpaceToDepthOptionsT : public flatbuffers::NativeTable {
    typedef SpaceToDepthOptions TableType;
    int32_t block_size;
    SpaceToDepthOptionsT() : block_size(0) {}
};

struct SpaceToDepthOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SpaceToDepthOptionsT NativeTableType;
    typedef SpaceToDepthOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SpaceToDepthOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_BLOCK_SIZE = 4 };
    int32_t block_size() const {
        return GetField<int32_t>(VT_BLOCK_SIZE, 0);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_BLOCK_SIZE) && verifier.EndTable();
    }
    SpaceToDepthOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SpaceToDepthOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SpaceToDepthOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                         const SpaceToDepthOptionsT *_o,
                                                         const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpaceToDepthOptionsBuilder {
    typedef SpaceToDepthOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_block_size(int32_t block_size) {
        fbb_.AddElement<int32_t>(SpaceToDepthOptions::VT_BLOCK_SIZE, block_size, 0);
    }
    explicit SpaceToDepthOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SpaceToDepthOptionsBuilder &operator=(const SpaceToDepthOptionsBuilder &);
    flatbuffers::Offset<SpaceToDepthOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SpaceToDepthOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SpaceToDepthOptions> CreateSpaceToDepthOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                          int32_t block_size = 0) {
    SpaceToDepthOptionsBuilder builder_(_fbb);
    builder_.add_block_size(block_size);
    return builder_.Finish();
}

flatbuffers::Offset<SpaceToDepthOptions> CreateSpaceToDepthOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubOptionsT : public flatbuffers::NativeTable {
    typedef SubOptions TableType;
    tflite::ActivationFunctionType fused_activation_function;
    SubOptionsT() : fused_activation_function(tflite::ActivationFunctionType_NONE) {}
};

struct SubOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SubOptionsT NativeTableType;
    typedef SubOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SubOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_FUSED_ACTIVATION_FUNCTION = 4 };
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
               verifier.EndTable();
    }
    SubOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SubOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SubOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubOptionsBuilder {
    typedef SubOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(SubOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    explicit SubOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SubOptionsBuilder &operator=(const SubOptionsBuilder &);
    flatbuffers::Offset<SubOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SubOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SubOptions> CreateSubOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
    SubOptionsBuilder builder_(_fbb);
    builder_.add_fused_activation_function(fused_activation_function);
    return builder_.Finish();
}

flatbuffers::Offset<SubOptions> CreateSubOptions(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DivOptionsT : public flatbuffers::NativeTable {
    typedef DivOptions TableType;
    tflite::ActivationFunctionType fused_activation_function;
    DivOptionsT() : fused_activation_function(tflite::ActivationFunctionType_NONE) {}
};

struct DivOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef DivOptionsT NativeTableType;
    typedef DivOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return DivOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_FUSED_ACTIVATION_FUNCTION = 4 };
    tflite::ActivationFunctionType fused_activation_function() const {
        return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
               verifier.EndTable();
    }
    DivOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(DivOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<DivOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DivOptionsBuilder {
    typedef DivOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {
        fbb_.AddElement<int8_t>(DivOptions::VT_FUSED_ACTIVATION_FUNCTION,
                                static_cast<int8_t>(fused_activation_function), 0);
    }
    explicit DivOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    DivOptionsBuilder &operator=(const DivOptionsBuilder &);
    flatbuffers::Offset<DivOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<DivOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<DivOptions> CreateDivOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {
    DivOptionsBuilder builder_(_fbb);
    builder_.add_fused_activation_function(fused_activation_function);
    return builder_.Finish();
}

flatbuffers::Offset<DivOptions> CreateDivOptions(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TopKV2OptionsT : public flatbuffers::NativeTable {
    typedef TopKV2Options TableType;
    TopKV2OptionsT() {}
};

struct TopKV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef TopKV2OptionsT NativeTableType;
    typedef TopKV2OptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return TopKV2OptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    TopKV2OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(TopKV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<TopKV2Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TopKV2OptionsBuilder {
    typedef TopKV2Options Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit TopKV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    TopKV2OptionsBuilder &operator=(const TopKV2OptionsBuilder &);
    flatbuffers::Offset<TopKV2Options> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<TopKV2Options>(end);
        return o;
    }
};

inline flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(flatbuffers::FlatBufferBuilder &_fbb) {
    TopKV2OptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EmbeddingLookupSparseOptionsT : public flatbuffers::NativeTable {
    typedef EmbeddingLookupSparseOptions TableType;
    tflite::CombinerType combiner;
    EmbeddingLookupSparseOptionsT() : combiner(tflite::CombinerType_SUM) {}
};

struct EmbeddingLookupSparseOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef EmbeddingLookupSparseOptionsT NativeTableType;
    typedef EmbeddingLookupSparseOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return EmbeddingLookupSparseOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_COMBINER = 4 };
    tflite::CombinerType combiner() const {
        return static_cast<tflite::CombinerType>(GetField<int8_t>(VT_COMBINER, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_COMBINER) && verifier.EndTable();
    }
    EmbeddingLookupSparseOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(EmbeddingLookupSparseOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<EmbeddingLookupSparseOptions> Pack(
        flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT *_o,
        const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EmbeddingLookupSparseOptionsBuilder {
    typedef EmbeddingLookupSparseOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_combiner(tflite::CombinerType combiner) {
        fbb_.AddElement<int8_t>(EmbeddingLookupSparseOptions::VT_COMBINER, static_cast<int8_t>(combiner), 0);
    }
    explicit EmbeddingLookupSparseOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    EmbeddingLookupSparseOptionsBuilder &operator=(const EmbeddingLookupSparseOptionsBuilder &);
    flatbuffers::Offset<EmbeddingLookupSparseOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<EmbeddingLookupSparseOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<EmbeddingLookupSparseOptions> CreateEmbeddingLookupSparseOptions(
    flatbuffers::FlatBufferBuilder &_fbb, tflite::CombinerType combiner = tflite::CombinerType_SUM) {
    EmbeddingLookupSparseOptionsBuilder builder_(_fbb);
    builder_.add_combiner(combiner);
    return builder_.Finish();
}

flatbuffers::Offset<EmbeddingLookupSparseOptions> CreateEmbeddingLookupSparseOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GatherOptionsT : public flatbuffers::NativeTable {
    typedef GatherOptions TableType;
    int32_t axis;
    GatherOptionsT() : axis(0) {}
};

struct GatherOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef GatherOptionsT NativeTableType;
    typedef GatherOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return GatherOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_AXIS = 4 };
    int32_t axis() const {
        return GetField<int32_t>(VT_AXIS, 0);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_AXIS) && verifier.EndTable();
    }
    GatherOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(GatherOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<GatherOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GatherOptionsBuilder {
    typedef GatherOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_axis(int32_t axis) {
        fbb_.AddElement<int32_t>(GatherOptions::VT_AXIS, axis, 0);
    }
    explicit GatherOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    GatherOptionsBuilder &operator=(const GatherOptionsBuilder &);
    flatbuffers::Offset<GatherOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<GatherOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<GatherOptions> CreateGatherOptions(flatbuffers::FlatBufferBuilder &_fbb, int32_t axis = 0) {
    GatherOptionsBuilder builder_(_fbb);
    builder_.add_axis(axis);
    return builder_.Finish();
}

flatbuffers::Offset<GatherOptions> CreateGatherOptions(flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransposeOptionsT : public flatbuffers::NativeTable {
    typedef TransposeOptions TableType;
    TransposeOptionsT() {}
};

struct TransposeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef TransposeOptionsT NativeTableType;
    typedef TransposeOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return TransposeOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    TransposeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(TransposeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<TransposeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT *_o,
                                                      const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransposeOptionsBuilder {
    typedef TransposeOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit TransposeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    TransposeOptionsBuilder &operator=(const TransposeOptionsBuilder &);
    flatbuffers::Offset<TransposeOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<TransposeOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<TransposeOptions> CreateTransposeOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    TransposeOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<TransposeOptions> CreateTransposeOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExpOptionsT : public flatbuffers::NativeTable {
    typedef ExpOptions TableType;
    ExpOptionsT() {}
};

struct ExpOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ExpOptionsT NativeTableType;
    typedef ExpOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ExpOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    ExpOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ExpOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<ExpOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpOptionsBuilder {
    typedef ExpOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit ExpOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ExpOptionsBuilder &operator=(const ExpOptionsBuilder &);
    flatbuffers::Offset<ExpOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<ExpOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<ExpOptions> CreateExpOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    ExpOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<ExpOptions> CreateExpOptions(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReducerOptionsT : public flatbuffers::NativeTable {
    typedef ReducerOptions TableType;
    bool keepDims;
    ReducerOptionsT() : keepDims(false) {}
};

struct ReducerOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ReducerOptionsT NativeTableType;
    typedef ReducerOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ReducerOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_KEEPDIMS = 4 };
    bool keepDims() const {
        return GetField<uint8_t>(VT_KEEPDIMS, 0) != 0;
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_KEEPDIMS) && verifier.EndTable();
    }
    ReducerOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ReducerOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<ReducerOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT *_o,
                                                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReducerOptionsBuilder {
    typedef ReducerOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_keepDims(bool keepDims) {
        fbb_.AddElement<uint8_t>(ReducerOptions::VT_KEEPDIMS, static_cast<uint8_t>(keepDims), 0);
    }
    explicit ReducerOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ReducerOptionsBuilder &operator=(const ReducerOptionsBuilder &);
    flatbuffers::Offset<ReducerOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<ReducerOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<ReducerOptions> CreateReducerOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                bool keepDims = false) {
    ReducerOptionsBuilder builder_(_fbb);
    builder_.add_keepDims(keepDims);
    return builder_.Finish();
}

flatbuffers::Offset<ReducerOptions> CreateReducerOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                         const ReducerOptionsT *_o,
                                                         const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SqueezeOptionsT : public flatbuffers::NativeTable {
    typedef SqueezeOptions TableType;
    std::vector<int32_t> squeezeDims;
    SqueezeOptionsT() {}
};

struct SqueezeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SqueezeOptionsT NativeTableType;
    typedef SqueezeOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SqueezeOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_SQUEEZEDIMS = 4 };
    const flatbuffers::Vector<int32_t> *squeezeDims() const {
        return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SQUEEZEDIMS);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_SQUEEZEDIMS) &&
               verifier.VerifyVector(squeezeDims()) && verifier.EndTable();
    }
    SqueezeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SqueezeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SqueezeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT *_o,
                                                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SqueezeOptionsBuilder {
    typedef SqueezeOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_squeezeDims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> squeezeDims) {
        fbb_.AddOffset(SqueezeOptions::VT_SQUEEZEDIMS, squeezeDims);
    }
    explicit SqueezeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SqueezeOptionsBuilder &operator=(const SqueezeOptionsBuilder &);
    flatbuffers::Offset<SqueezeOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SqueezeOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptions(
    flatbuffers::FlatBufferBuilder &_fbb, flatbuffers::Offset<flatbuffers::Vector<int32_t>> squeezeDims = 0) {
    SqueezeOptionsBuilder builder_(_fbb);
    builder_.add_squeezeDims(squeezeDims);
    return builder_.Finish();
}

inline flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb, const std::vector<int32_t> *squeezeDims = nullptr) {
    auto squeezeDims__ = squeezeDims ? _fbb.CreateVector<int32_t>(*squeezeDims) : 0;
    return tflite::CreateSqueezeOptions(_fbb, squeezeDims__);
}

flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                         const SqueezeOptionsT *_o,
                                                         const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SplitOptionsT : public flatbuffers::NativeTable {
    typedef SplitOptions TableType;
    int32_t num_splits;
    SplitOptionsT() : num_splits(0) {}
};

struct SplitOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SplitOptionsT NativeTableType;
    typedef SplitOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SplitOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_NUM_SPLITS = 4 };
    int32_t num_splits() const {
        return GetField<int32_t>(VT_NUM_SPLITS, 0);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_NUM_SPLITS) && verifier.EndTable();
    }
    SplitOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SplitOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SplitOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT *_o,
                                                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SplitOptionsBuilder {
    typedef SplitOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_num_splits(int32_t num_splits) {
        fbb_.AddElement<int32_t>(SplitOptions::VT_NUM_SPLITS, num_splits, 0);
    }
    explicit SplitOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SplitOptionsBuilder &operator=(const SplitOptionsBuilder &);
    flatbuffers::Offset<SplitOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SplitOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SplitOptions> CreateSplitOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                            int32_t num_splits = 0) {
    SplitOptionsBuilder builder_(_fbb);
    builder_.add_num_splits(num_splits);
    return builder_.Finish();
}

flatbuffers::Offset<SplitOptions> CreateSplitOptions(flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT *_o,
                                                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StridedSliceOptionsT : public flatbuffers::NativeTable {
    typedef StridedSliceOptions TableType;
    int32_t beginMask;
    int32_t endMask;
    int32_t ellipsisMask;
    int32_t newAxisMask;
    int32_t shrinkAxisMask;
    StridedSliceOptionsT() : beginMask(0), endMask(0), ellipsisMask(0), newAxisMask(0), shrinkAxisMask(0) {}
};

struct StridedSliceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef StridedSliceOptionsT NativeTableType;
    typedef StridedSliceOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return StridedSliceOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_BEGINMASK      = 4,
        VT_ENDMASK        = 6,
        VT_ELLIPSISMASK   = 8,
        VT_NEWAXISMASK    = 10,
        VT_SHRINKAXISMASK = 12
    };
    int32_t beginMask() const {
        return GetField<int32_t>(VT_BEGINMASK, 0);
    }
    int32_t endMask() const {
        return GetField<int32_t>(VT_ENDMASK, 0);
    }
    int32_t ellipsisMask() const {
        return GetField<int32_t>(VT_ELLIPSISMASK, 0);
    }
    int32_t newAxisMask() const {
        return GetField<int32_t>(VT_NEWAXISMASK, 0);
    }
    int32_t shrinkAxisMask() const {
        return GetField<int32_t>(VT_SHRINKAXISMASK, 0);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_BEGINMASK) &&
               VerifyField<int32_t>(verifier, VT_ENDMASK) && VerifyField<int32_t>(verifier, VT_ELLIPSISMASK) &&
               VerifyField<int32_t>(verifier, VT_NEWAXISMASK) && VerifyField<int32_t>(verifier, VT_SHRINKAXISMASK) &&
               verifier.EndTable();
    }
    StridedSliceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(StridedSliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<StridedSliceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                         const StridedSliceOptionsT *_o,
                                                         const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StridedSliceOptionsBuilder {
    typedef StridedSliceOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_beginMask(int32_t beginMask) {
        fbb_.AddElement<int32_t>(StridedSliceOptions::VT_BEGINMASK, beginMask, 0);
    }
    void add_endMask(int32_t endMask) {
        fbb_.AddElement<int32_t>(StridedSliceOptions::VT_ENDMASK, endMask, 0);
    }
    void add_ellipsisMask(int32_t ellipsisMask) {
        fbb_.AddElement<int32_t>(StridedSliceOptions::VT_ELLIPSISMASK, ellipsisMask, 0);
    }
    void add_newAxisMask(int32_t newAxisMask) {
        fbb_.AddElement<int32_t>(StridedSliceOptions::VT_NEWAXISMASK, newAxisMask, 0);
    }
    void add_shrinkAxisMask(int32_t shrinkAxisMask) {
        fbb_.AddElement<int32_t>(StridedSliceOptions::VT_SHRINKAXISMASK, shrinkAxisMask, 0);
    }
    explicit StridedSliceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    StridedSliceOptionsBuilder &operator=(const StridedSliceOptionsBuilder &);
    flatbuffers::Offset<StridedSliceOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<StridedSliceOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                          int32_t beginMask = 0, int32_t endMask = 0,
                                                                          int32_t ellipsisMask   = 0,
                                                                          int32_t newAxisMask    = 0,
                                                                          int32_t shrinkAxisMask = 0) {
    StridedSliceOptionsBuilder builder_(_fbb);
    builder_.add_shrinkAxisMask(shrinkAxisMask);
    builder_.add_newAxisMask(newAxisMask);
    builder_.add_ellipsisMask(ellipsisMask);
    builder_.add_endMask(endMask);
    builder_.add_beginMask(beginMask);
    return builder_.Finish();
}

flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogSoftmaxOptionsT : public flatbuffers::NativeTable {
    typedef LogSoftmaxOptions TableType;
    LogSoftmaxOptionsT() {}
};

struct LogSoftmaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef LogSoftmaxOptionsT NativeTableType;
    typedef LogSoftmaxOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return LogSoftmaxOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    LogSoftmaxOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(LogSoftmaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<LogSoftmaxOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                       const LogSoftmaxOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogSoftmaxOptionsBuilder {
    typedef LogSoftmaxOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit LogSoftmaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    LogSoftmaxOptionsBuilder &operator=(const LogSoftmaxOptionsBuilder &);
    flatbuffers::Offset<LogSoftmaxOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<LogSoftmaxOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<LogSoftmaxOptions> CreateLogSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    LogSoftmaxOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<LogSoftmaxOptions> CreateLogSoftmaxOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CastOptionsT : public flatbuffers::NativeTable {
    typedef CastOptions TableType;
    tflite::TensorType in_data_type;
    tflite::TensorType out_data_type;
    CastOptionsT() : in_data_type(tflite::TensorType_FLOAT32), out_data_type(tflite::TensorType_FLOAT32) {}
};

struct CastOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef CastOptionsT NativeTableType;
    typedef CastOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return CastOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_IN_DATA_TYPE = 4, VT_OUT_DATA_TYPE = 6 };
    tflite::TensorType in_data_type() const {
        return static_cast<tflite::TensorType>(GetField<int8_t>(VT_IN_DATA_TYPE, 0));
    }
    tflite::TensorType out_data_type() const {
        return static_cast<tflite::TensorType>(GetField<int8_t>(VT_OUT_DATA_TYPE, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_IN_DATA_TYPE) &&
               VerifyField<int8_t>(verifier, VT_OUT_DATA_TYPE) && verifier.EndTable();
    }
    CastOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(CastOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<CastOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CastOptionsBuilder {
    typedef CastOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_in_data_type(tflite::TensorType in_data_type) {
        fbb_.AddElement<int8_t>(CastOptions::VT_IN_DATA_TYPE, static_cast<int8_t>(in_data_type), 0);
    }
    void add_out_data_type(tflite::TensorType out_data_type) {
        fbb_.AddElement<int8_t>(CastOptions::VT_OUT_DATA_TYPE, static_cast<int8_t>(out_data_type), 0);
    }
    explicit CastOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    CastOptionsBuilder &operator=(const CastOptionsBuilder &);
    flatbuffers::Offset<CastOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<CastOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<CastOptions> CreateCastOptions(
    flatbuffers::FlatBufferBuilder &_fbb, tflite::TensorType in_data_type = tflite::TensorType_FLOAT32,
    tflite::TensorType out_data_type = tflite::TensorType_FLOAT32) {
    CastOptionsBuilder builder_(_fbb);
    builder_.add_out_data_type(out_data_type);
    builder_.add_in_data_type(in_data_type);
    return builder_.Finish();
}

flatbuffers::Offset<CastOptions> CreateCastOptions(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DequantizeOptionsT : public flatbuffers::NativeTable {
    typedef DequantizeOptions TableType;
    DequantizeOptionsT() {}
};

struct DequantizeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef DequantizeOptionsT NativeTableType;
    typedef DequantizeOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return DequantizeOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    DequantizeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(DequantizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<DequantizeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                       const DequantizeOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DequantizeOptionsBuilder {
    typedef DequantizeOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit DequantizeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    DequantizeOptionsBuilder &operator=(const DequantizeOptionsBuilder &);
    flatbuffers::Offset<DequantizeOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<DequantizeOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    DequantizeOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MaximumMinimumOptionsT : public flatbuffers::NativeTable {
    typedef MaximumMinimumOptions TableType;
    MaximumMinimumOptionsT() {}
};

struct MaximumMinimumOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef MaximumMinimumOptionsT NativeTableType;
    typedef MaximumMinimumOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return MaximumMinimumOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    MaximumMinimumOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(MaximumMinimumOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<MaximumMinimumOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                           const MaximumMinimumOptionsT *_o,
                                                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MaximumMinimumOptionsBuilder {
    typedef MaximumMinimumOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit MaximumMinimumOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    MaximumMinimumOptionsBuilder &operator=(const MaximumMinimumOptionsBuilder &);
    flatbuffers::Offset<MaximumMinimumOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<MaximumMinimumOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    MaximumMinimumOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TileOptionsT : public flatbuffers::NativeTable {
    typedef TileOptions TableType;
    TileOptionsT() {}
};

struct TileOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef TileOptionsT NativeTableType;
    typedef TileOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return TileOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    TileOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(TileOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<TileOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TileOptionsBuilder {
    typedef TileOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit TileOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    TileOptionsBuilder &operator=(const TileOptionsBuilder &);
    flatbuffers::Offset<TileOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<TileOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<TileOptions> CreateTileOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    TileOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<TileOptions> CreateTileOptions(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArgMaxOptionsT : public flatbuffers::NativeTable {
    typedef ArgMaxOptions TableType;
    tflite::TensorType output_type;
    ArgMaxOptionsT() : output_type(tflite::TensorType_FLOAT32) {}
};

struct ArgMaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ArgMaxOptionsT NativeTableType;
    typedef ArgMaxOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ArgMaxOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_OUTPUT_TYPE = 4 };
    tflite::TensorType output_type() const {
        return static_cast<tflite::TensorType>(GetField<int8_t>(VT_OUTPUT_TYPE, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_OUTPUT_TYPE) && verifier.EndTable();
    }
    ArgMaxOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ArgMaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<ArgMaxOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArgMaxOptionsBuilder {
    typedef ArgMaxOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_output_type(tflite::TensorType output_type) {
        fbb_.AddElement<int8_t>(ArgMaxOptions::VT_OUTPUT_TYPE, static_cast<int8_t>(output_type), 0);
    }
    explicit ArgMaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ArgMaxOptionsBuilder &operator=(const ArgMaxOptionsBuilder &);
    flatbuffers::Offset<ArgMaxOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<ArgMaxOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<ArgMaxOptions> CreateArgMaxOptions(
    flatbuffers::FlatBufferBuilder &_fbb, tflite::TensorType output_type = tflite::TensorType_FLOAT32) {
    ArgMaxOptionsBuilder builder_(_fbb);
    builder_.add_output_type(output_type);
    return builder_.Finish();
}

flatbuffers::Offset<ArgMaxOptions> CreateArgMaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArgMinOptionsT : public flatbuffers::NativeTable {
    typedef ArgMinOptions TableType;
    tflite::TensorType output_type;
    ArgMinOptionsT() : output_type(tflite::TensorType_FLOAT32) {}
};

struct ArgMinOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ArgMinOptionsT NativeTableType;
    typedef ArgMinOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ArgMinOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_OUTPUT_TYPE = 4 };
    tflite::TensorType output_type() const {
        return static_cast<tflite::TensorType>(GetField<int8_t>(VT_OUTPUT_TYPE, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_OUTPUT_TYPE) && verifier.EndTable();
    }
    ArgMinOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ArgMinOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<ArgMinOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArgMinOptionsBuilder {
    typedef ArgMinOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_output_type(tflite::TensorType output_type) {
        fbb_.AddElement<int8_t>(ArgMinOptions::VT_OUTPUT_TYPE, static_cast<int8_t>(output_type), 0);
    }
    explicit ArgMinOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ArgMinOptionsBuilder &operator=(const ArgMinOptionsBuilder &);
    flatbuffers::Offset<ArgMinOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<ArgMinOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<ArgMinOptions> CreateArgMinOptions(
    flatbuffers::FlatBufferBuilder &_fbb, tflite::TensorType output_type = tflite::TensorType_FLOAT32) {
    ArgMinOptionsBuilder builder_(_fbb);
    builder_.add_output_type(output_type);
    return builder_.Finish();
}

flatbuffers::Offset<ArgMinOptions> CreateArgMinOptions(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GreaterOptionsT : public flatbuffers::NativeTable {
    typedef GreaterOptions TableType;
    GreaterOptionsT() {}
};

struct GreaterOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef GreaterOptionsT NativeTableType;
    typedef GreaterOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return GreaterOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    GreaterOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(GreaterOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<GreaterOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT *_o,
                                                    const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GreaterOptionsBuilder {
    typedef GreaterOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit GreaterOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    GreaterOptionsBuilder &operator=(const GreaterOptionsBuilder &);
    flatbuffers::Offset<GreaterOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<GreaterOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<GreaterOptions> CreateGreaterOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    GreaterOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<GreaterOptions> CreateGreaterOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                         const GreaterOptionsT *_o,
                                                         const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GreaterEqualOptionsT : public flatbuffers::NativeTable {
    typedef GreaterEqualOptions TableType;
    GreaterEqualOptionsT() {}
};

struct GreaterEqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef GreaterEqualOptionsT NativeTableType;
    typedef GreaterEqualOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return GreaterEqualOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    GreaterEqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(GreaterEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<GreaterEqualOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                         const GreaterEqualOptionsT *_o,
                                                         const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GreaterEqualOptionsBuilder {
    typedef GreaterEqualOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit GreaterEqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    GreaterEqualOptionsBuilder &operator=(const GreaterEqualOptionsBuilder &);
    flatbuffers::Offset<GreaterEqualOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<GreaterEqualOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<GreaterEqualOptions> CreateGreaterEqualOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    GreaterEqualOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<GreaterEqualOptions> CreateGreaterEqualOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LessOptionsT : public flatbuffers::NativeTable {
    typedef LessOptions TableType;
    LessOptionsT() {}
};

struct LessOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef LessOptionsT NativeTableType;
    typedef LessOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return LessOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    LessOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(LessOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<LessOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LessOptionsBuilder {
    typedef LessOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit LessOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    LessOptionsBuilder &operator=(const LessOptionsBuilder &);
    flatbuffers::Offset<LessOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<LessOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<LessOptions> CreateLessOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    LessOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<LessOptions> CreateLessOptions(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LessEqualOptionsT : public flatbuffers::NativeTable {
    typedef LessEqualOptions TableType;
    LessEqualOptionsT() {}
};

struct LessEqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef LessEqualOptionsT NativeTableType;
    typedef LessEqualOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return LessEqualOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    LessEqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(LessEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<LessEqualOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT *_o,
                                                      const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LessEqualOptionsBuilder {
    typedef LessEqualOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit LessEqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    LessEqualOptionsBuilder &operator=(const LessEqualOptionsBuilder &);
    flatbuffers::Offset<LessEqualOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<LessEqualOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<LessEqualOptions> CreateLessEqualOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    LessEqualOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<LessEqualOptions> CreateLessEqualOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NegOptionsT : public flatbuffers::NativeTable {
    typedef NegOptions TableType;
    NegOptionsT() {}
};

struct NegOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef NegOptionsT NativeTableType;
    typedef NegOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return NegOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    NegOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(NegOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<NegOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NegOptionsBuilder {
    typedef NegOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit NegOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    NegOptionsBuilder &operator=(const NegOptionsBuilder &);
    flatbuffers::Offset<NegOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<NegOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<NegOptions> CreateNegOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    NegOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<NegOptions> CreateNegOptions(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SelectOptionsT : public flatbuffers::NativeTable {
    typedef SelectOptions TableType;
    SelectOptionsT() {}
};

struct SelectOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SelectOptionsT NativeTableType;
    typedef SelectOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SelectOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    SelectOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SelectOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SelectOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SelectOptionsBuilder {
    typedef SelectOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit SelectOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SelectOptionsBuilder &operator=(const SelectOptionsBuilder &);
    flatbuffers::Offset<SelectOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SelectOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SelectOptions> CreateSelectOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    SelectOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<SelectOptions> CreateSelectOptions(flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SliceOptionsT : public flatbuffers::NativeTable {
    typedef SliceOptions TableType;
    SliceOptionsT() {}
};

struct SliceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SliceOptionsT NativeTableType;
    typedef SliceOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SliceOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    SliceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SliceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT *_o,
                                                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SliceOptionsBuilder {
    typedef SliceOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit SliceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SliceOptionsBuilder &operator=(const SliceOptionsBuilder &);
    flatbuffers::Offset<SliceOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SliceOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SliceOptions> CreateSliceOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    SliceOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<SliceOptions> CreateSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT *_o,
                                                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransposeConvOptionsT : public flatbuffers::NativeTable {
    typedef TransposeConvOptions TableType;
    tflite::Padding padding;
    int32_t stride_w;
    int32_t stride_h;
    TransposeConvOptionsT() : padding(tflite::Padding_SAME), stride_w(0), stride_h(0) {}
};

struct TransposeConvOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef TransposeConvOptionsT NativeTableType;
    typedef TransposeConvOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return TransposeConvOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_PADDING  = 4,
        VT_STRIDE_W = 6,
        VT_STRIDE_H = 8
    };
    tflite::Padding padding() const {
        return static_cast<tflite::Padding>(GetField<int8_t>(VT_PADDING, 0));
    }
    int32_t stride_w() const {
        return GetField<int32_t>(VT_STRIDE_W, 0);
    }
    int32_t stride_h() const {
        return GetField<int32_t>(VT_STRIDE_H, 0);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_PADDING) &&
               VerifyField<int32_t>(verifier, VT_STRIDE_W) && VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
               verifier.EndTable();
    }
    TransposeConvOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(TransposeConvOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<TransposeConvOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                          const TransposeConvOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransposeConvOptionsBuilder {
    typedef TransposeConvOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_padding(tflite::Padding padding) {
        fbb_.AddElement<int8_t>(TransposeConvOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
    }
    void add_stride_w(int32_t stride_w) {
        fbb_.AddElement<int32_t>(TransposeConvOptions::VT_STRIDE_W, stride_w, 0);
    }
    void add_stride_h(int32_t stride_h) {
        fbb_.AddElement<int32_t>(TransposeConvOptions::VT_STRIDE_H, stride_h, 0);
    }
    explicit TransposeConvOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    TransposeConvOptionsBuilder &operator=(const TransposeConvOptionsBuilder &);
    flatbuffers::Offset<TransposeConvOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<TransposeConvOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(
    flatbuffers::FlatBufferBuilder &_fbb, tflite::Padding padding = tflite::Padding_SAME, int32_t stride_w = 0,
    int32_t stride_h = 0) {
    TransposeConvOptionsBuilder builder_(_fbb);
    builder_.add_stride_h(stride_h);
    builder_.add_stride_w(stride_w);
    builder_.add_padding(padding);
    return builder_.Finish();
}

flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExpandDimsOptionsT : public flatbuffers::NativeTable {
    typedef ExpandDimsOptions TableType;
    ExpandDimsOptionsT() {}
};

struct ExpandDimsOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ExpandDimsOptionsT NativeTableType;
    typedef ExpandDimsOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ExpandDimsOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    ExpandDimsOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ExpandDimsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<ExpandDimsOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                       const ExpandDimsOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpandDimsOptionsBuilder {
    typedef ExpandDimsOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit ExpandDimsOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ExpandDimsOptionsBuilder &operator=(const ExpandDimsOptionsBuilder &);
    flatbuffers::Offset<ExpandDimsOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<ExpandDimsOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<ExpandDimsOptions> CreateExpandDimsOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    ExpandDimsOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<ExpandDimsOptions> CreateExpandDimsOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SparseToDenseOptionsT : public flatbuffers::NativeTable {
    typedef SparseToDenseOptions TableType;
    bool validateIndices;
    SparseToDenseOptionsT() : validateIndices(false) {}
};

struct SparseToDenseOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SparseToDenseOptionsT NativeTableType;
    typedef SparseToDenseOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SparseToDenseOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALIDATEINDICES = 4 };
    bool validateIndices() const {
        return GetField<uint8_t>(VT_VALIDATEINDICES, 0) != 0;
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_VALIDATEINDICES) && verifier.EndTable();
    }
    SparseToDenseOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SparseToDenseOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SparseToDenseOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                          const SparseToDenseOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SparseToDenseOptionsBuilder {
    typedef SparseToDenseOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_validateIndices(bool validateIndices) {
        fbb_.AddElement<uint8_t>(SparseToDenseOptions::VT_VALIDATEINDICES, static_cast<uint8_t>(validateIndices), 0);
    }
    explicit SparseToDenseOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SparseToDenseOptionsBuilder &operator=(const SparseToDenseOptionsBuilder &);
    flatbuffers::Offset<SparseToDenseOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SparseToDenseOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SparseToDenseOptions> CreateSparseToDenseOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                            bool validateIndices = false) {
    SparseToDenseOptionsBuilder builder_(_fbb);
    builder_.add_validateIndices(validateIndices);
    return builder_.Finish();
}

flatbuffers::Offset<SparseToDenseOptions> CreateSparseToDenseOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EqualOptionsT : public flatbuffers::NativeTable {
    typedef EqualOptions TableType;
    EqualOptionsT() {}
};

struct EqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef EqualOptionsT NativeTableType;
    typedef EqualOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return EqualOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    EqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(EqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<EqualOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT *_o,
                                                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EqualOptionsBuilder {
    typedef EqualOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit EqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    EqualOptionsBuilder &operator=(const EqualOptionsBuilder &);
    flatbuffers::Offset<EqualOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<EqualOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<EqualOptions> CreateEqualOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    EqualOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<EqualOptions> CreateEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT *_o,
                                                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NotEqualOptionsT : public flatbuffers::NativeTable {
    typedef NotEqualOptions TableType;
    NotEqualOptionsT() {}
};

struct NotEqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef NotEqualOptionsT NativeTableType;
    typedef NotEqualOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return NotEqualOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    NotEqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(NotEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<NotEqualOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT *_o,
                                                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NotEqualOptionsBuilder {
    typedef NotEqualOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit NotEqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    NotEqualOptionsBuilder &operator=(const NotEqualOptionsBuilder &);
    flatbuffers::Offset<NotEqualOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<NotEqualOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<NotEqualOptions> CreateNotEqualOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    NotEqualOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<NotEqualOptions> CreateNotEqualOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                           const NotEqualOptionsT *_o,
                                                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ShapeOptionsT : public flatbuffers::NativeTable {
    typedef ShapeOptions TableType;
    tflite::TensorType out_type;
    ShapeOptionsT() : out_type(tflite::TensorType_FLOAT32) {}
};

struct ShapeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ShapeOptionsT NativeTableType;
    typedef ShapeOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ShapeOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_OUT_TYPE = 4 };
    tflite::TensorType out_type() const {
        return static_cast<tflite::TensorType>(GetField<int8_t>(VT_OUT_TYPE, 0));
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_OUT_TYPE) && verifier.EndTable();
    }
    ShapeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ShapeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<ShapeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT *_o,
                                                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ShapeOptionsBuilder {
    typedef ShapeOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_out_type(tflite::TensorType out_type) {
        fbb_.AddElement<int8_t>(ShapeOptions::VT_OUT_TYPE, static_cast<int8_t>(out_type), 0);
    }
    explicit ShapeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ShapeOptionsBuilder &operator=(const ShapeOptionsBuilder &);
    flatbuffers::Offset<ShapeOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<ShapeOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<ShapeOptions> CreateShapeOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                            tflite::TensorType out_type = tflite::TensorType_FLOAT32) {
    ShapeOptionsBuilder builder_(_fbb);
    builder_.add_out_type(out_type);
    return builder_.Finish();
}

flatbuffers::Offset<ShapeOptions> CreateShapeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT *_o,
                                                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PowOptionsT : public flatbuffers::NativeTable {
    typedef PowOptions TableType;
    PowOptionsT() {}
};

struct PowOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef PowOptionsT NativeTableType;
    typedef PowOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return PowOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    PowOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(PowOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<PowOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PowOptionsBuilder {
    typedef PowOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit PowOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    PowOptionsBuilder &operator=(const PowOptionsBuilder &);
    flatbuffers::Offset<PowOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<PowOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<PowOptions> CreatePowOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    PowOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<PowOptions> CreatePowOptions(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FakeQuantOptionsT : public flatbuffers::NativeTable {
    typedef FakeQuantOptions TableType;
    float min;
    float max;
    int32_t num_bits;
    bool narrow_range;
    FakeQuantOptionsT() : min(0.0f), max(0.0f), num_bits(0), narrow_range(false) {}
};

struct FakeQuantOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef FakeQuantOptionsT NativeTableType;
    typedef FakeQuantOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return FakeQuantOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_MIN          = 4,
        VT_MAX          = 6,
        VT_NUM_BITS     = 8,
        VT_NARROW_RANGE = 10
    };
    float min() const {
        return GetField<float>(VT_MIN, 0.0f);
    }
    float max() const {
        return GetField<float>(VT_MAX, 0.0f);
    }
    int32_t num_bits() const {
        return GetField<int32_t>(VT_NUM_BITS, 0);
    }
    bool narrow_range() const {
        return GetField<uint8_t>(VT_NARROW_RANGE, 0) != 0;
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<float>(verifier, VT_MIN) &&
               VerifyField<float>(verifier, VT_MAX) && VerifyField<int32_t>(verifier, VT_NUM_BITS) &&
               VerifyField<uint8_t>(verifier, VT_NARROW_RANGE) && verifier.EndTable();
    }
    FakeQuantOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(FakeQuantOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<FakeQuantOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT *_o,
                                                      const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FakeQuantOptionsBuilder {
    typedef FakeQuantOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_min(float min) {
        fbb_.AddElement<float>(FakeQuantOptions::VT_MIN, min, 0.0f);
    }
    void add_max(float max) {
        fbb_.AddElement<float>(FakeQuantOptions::VT_MAX, max, 0.0f);
    }
    void add_num_bits(int32_t num_bits) {
        fbb_.AddElement<int32_t>(FakeQuantOptions::VT_NUM_BITS, num_bits, 0);
    }
    void add_narrow_range(bool narrow_range) {
        fbb_.AddElement<uint8_t>(FakeQuantOptions::VT_NARROW_RANGE, static_cast<uint8_t>(narrow_range), 0);
    }
    explicit FakeQuantOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    FakeQuantOptionsBuilder &operator=(const FakeQuantOptionsBuilder &);
    flatbuffers::Offset<FakeQuantOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<FakeQuantOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    float min = 0.0f, float max = 0.0f,
                                                                    int32_t num_bits = 0, bool narrow_range = false) {
    FakeQuantOptionsBuilder builder_(_fbb);
    builder_.add_num_bits(num_bits);
    builder_.add_max(max);
    builder_.add_min(min);
    builder_.add_narrow_range(narrow_range);
    return builder_.Finish();
}

flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PackOptionsT : public flatbuffers::NativeTable {
    typedef PackOptions TableType;
    int32_t values_count;
    int32_t axis;
    PackOptionsT() : values_count(0), axis(0) {}
};

struct PackOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef PackOptionsT NativeTableType;
    typedef PackOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return PackOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VALUES_COUNT = 4, VT_AXIS = 6 };
    int32_t values_count() const {
        return GetField<int32_t>(VT_VALUES_COUNT, 0);
    }
    int32_t axis() const {
        return GetField<int32_t>(VT_AXIS, 0);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_VALUES_COUNT) &&
               VerifyField<int32_t>(verifier, VT_AXIS) && verifier.EndTable();
    }
    PackOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(PackOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<PackOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PackOptionsBuilder {
    typedef PackOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_values_count(int32_t values_count) {
        fbb_.AddElement<int32_t>(PackOptions::VT_VALUES_COUNT, values_count, 0);
    }
    void add_axis(int32_t axis) {
        fbb_.AddElement<int32_t>(PackOptions::VT_AXIS, axis, 0);
    }
    explicit PackOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    PackOptionsBuilder &operator=(const PackOptionsBuilder &);
    flatbuffers::Offset<PackOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<PackOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<PackOptions> CreatePackOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                          int32_t values_count = 0, int32_t axis = 0) {
    PackOptionsBuilder builder_(_fbb);
    builder_.add_axis(axis);
    builder_.add_values_count(values_count);
    return builder_.Finish();
}

flatbuffers::Offset<PackOptions> CreatePackOptions(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalOrOptionsT : public flatbuffers::NativeTable {
    typedef LogicalOrOptions TableType;
    LogicalOrOptionsT() {}
};

struct LogicalOrOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef LogicalOrOptionsT NativeTableType;
    typedef LogicalOrOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return LogicalOrOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    LogicalOrOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(LogicalOrOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<LogicalOrOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT *_o,
                                                      const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalOrOptionsBuilder {
    typedef LogicalOrOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit LogicalOrOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    LogicalOrOptionsBuilder &operator=(const LogicalOrOptionsBuilder &);
    flatbuffers::Offset<LogicalOrOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<LogicalOrOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<LogicalOrOptions> CreateLogicalOrOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    LogicalOrOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<LogicalOrOptions> CreateLogicalOrOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OneHotOptionsT : public flatbuffers::NativeTable {
    typedef OneHotOptions TableType;
    int32_t axis;
    OneHotOptionsT() : axis(0) {}
};

struct OneHotOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef OneHotOptionsT NativeTableType;
    typedef OneHotOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return OneHotOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_AXIS = 4 };
    int32_t axis() const {
        return GetField<int32_t>(VT_AXIS, 0);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_AXIS) && verifier.EndTable();
    }
    OneHotOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(OneHotOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<OneHotOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OneHotOptionsBuilder {
    typedef OneHotOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_axis(int32_t axis) {
        fbb_.AddElement<int32_t>(OneHotOptions::VT_AXIS, axis, 0);
    }
    explicit OneHotOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    OneHotOptionsBuilder &operator=(const OneHotOptionsBuilder &);
    flatbuffers::Offset<OneHotOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<OneHotOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(flatbuffers::FlatBufferBuilder &_fbb, int32_t axis = 0) {
    OneHotOptionsBuilder builder_(_fbb);
    builder_.add_axis(axis);
    return builder_.Finish();
}

flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalAndOptionsT : public flatbuffers::NativeTable {
    typedef LogicalAndOptions TableType;
    LogicalAndOptionsT() {}
};

struct LogicalAndOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef LogicalAndOptionsT NativeTableType;
    typedef LogicalAndOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return LogicalAndOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    LogicalAndOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(LogicalAndOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<LogicalAndOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                       const LogicalAndOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalAndOptionsBuilder {
    typedef LogicalAndOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit LogicalAndOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    LogicalAndOptionsBuilder &operator=(const LogicalAndOptionsBuilder &);
    flatbuffers::Offset<LogicalAndOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<LogicalAndOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<LogicalAndOptions> CreateLogicalAndOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    LogicalAndOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<LogicalAndOptions> CreateLogicalAndOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalNotOptionsT : public flatbuffers::NativeTable {
    typedef LogicalNotOptions TableType;
    LogicalNotOptionsT() {}
};

struct LogicalNotOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef LogicalNotOptionsT NativeTableType;
    typedef LogicalNotOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return LogicalNotOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    LogicalNotOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(LogicalNotOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<LogicalNotOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                       const LogicalNotOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalNotOptionsBuilder {
    typedef LogicalNotOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit LogicalNotOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    LogicalNotOptionsBuilder &operator=(const LogicalNotOptionsBuilder &);
    flatbuffers::Offset<LogicalNotOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<LogicalNotOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<LogicalNotOptions> CreateLogicalNotOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    LogicalNotOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<LogicalNotOptions> CreateLogicalNotOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnpackOptionsT : public flatbuffers::NativeTable {
    typedef UnpackOptions TableType;
    int32_t num;
    int32_t axis;
    UnpackOptionsT() : num(0), axis(0) {}
};

struct UnpackOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef UnpackOptionsT NativeTableType;
    typedef UnpackOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return UnpackOptionsTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_NUM = 4, VT_AXIS = 6 };
    int32_t num() const {
        return GetField<int32_t>(VT_NUM, 0);
    }
    int32_t axis() const {
        return GetField<int32_t>(VT_AXIS, 0);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_NUM) &&
               VerifyField<int32_t>(verifier, VT_AXIS) && verifier.EndTable();
    }
    UnpackOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(UnpackOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<UnpackOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnpackOptionsBuilder {
    typedef UnpackOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_num(int32_t num) {
        fbb_.AddElement<int32_t>(UnpackOptions::VT_NUM, num, 0);
    }
    void add_axis(int32_t axis) {
        fbb_.AddElement<int32_t>(UnpackOptions::VT_AXIS, axis, 0);
    }
    explicit UnpackOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    UnpackOptionsBuilder &operator=(const UnpackOptionsBuilder &);
    flatbuffers::Offset<UnpackOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<UnpackOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(flatbuffers::FlatBufferBuilder &_fbb, int32_t num = 0,
                                                              int32_t axis = 0) {
    UnpackOptionsBuilder builder_(_fbb);
    builder_.add_axis(axis);
    builder_.add_num(num);
    return builder_.Finish();
}

flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FloorDivOptionsT : public flatbuffers::NativeTable {
    typedef FloorDivOptions TableType;
    FloorDivOptionsT() {}
};

struct FloorDivOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef FloorDivOptionsT NativeTableType;
    typedef FloorDivOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return FloorDivOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    FloorDivOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(FloorDivOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<FloorDivOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT *_o,
                                                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FloorDivOptionsBuilder {
    typedef FloorDivOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit FloorDivOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    FloorDivOptionsBuilder &operator=(const FloorDivOptionsBuilder &);
    flatbuffers::Offset<FloorDivOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<FloorDivOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<FloorDivOptions> CreateFloorDivOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    FloorDivOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<FloorDivOptions> CreateFloorDivOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                           const FloorDivOptionsT *_o,
                                                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SquareOptionsT : public flatbuffers::NativeTable {
    typedef SquareOptions TableType;
    SquareOptionsT() {}
};

struct SquareOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SquareOptionsT NativeTableType;
    typedef SquareOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SquareOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    SquareOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SquareOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SquareOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SquareOptionsBuilder {
    typedef SquareOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit SquareOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SquareOptionsBuilder &operator=(const SquareOptionsBuilder &);
    flatbuffers::Offset<SquareOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SquareOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<SquareOptions> CreateSquareOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    SquareOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<SquareOptions> CreateSquareOptions(flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT *_o,
                                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ZerosLikeOptionsT : public flatbuffers::NativeTable {
    typedef ZerosLikeOptions TableType;
    ZerosLikeOptionsT() {}
};

struct ZerosLikeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ZerosLikeOptionsT NativeTableType;
    typedef ZerosLikeOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ZerosLikeOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    ZerosLikeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ZerosLikeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<ZerosLikeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT *_o,
                                                      const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ZerosLikeOptionsBuilder {
    typedef ZerosLikeOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit ZerosLikeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ZerosLikeOptionsBuilder &operator=(const ZerosLikeOptionsBuilder &);
    flatbuffers::Offset<ZerosLikeOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<ZerosLikeOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<ZerosLikeOptions> CreateZerosLikeOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    ZerosLikeOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<ZerosLikeOptions> CreateZerosLikeOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FillOptionsT : public flatbuffers::NativeTable {
    typedef FillOptions TableType;
    FillOptionsT() {}
};

struct FillOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef FillOptionsT NativeTableType;
    typedef FillOptionsBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return FillOptionsTypeTable();
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && verifier.EndTable();
    }
    FillOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(FillOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<FillOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FillOptionsBuilder {
    typedef FillOptions Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    explicit FillOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    FillOptionsBuilder &operator=(const FillOptionsBuilder &);
    flatbuffers::Offset<FillOptions> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<FillOptions>(end);
        return o;
    }
};

inline flatbuffers::Offset<FillOptions> CreateFillOptions(flatbuffers::FlatBufferBuilder &_fbb) {
    FillOptionsBuilder builder_(_fbb);
    return builder_.Finish();
}

flatbuffers::Offset<FillOptions> CreateFillOptions(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT *_o,
                                                   const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OperatorCodeT : public flatbuffers::NativeTable {
    typedef OperatorCode TableType;
    tflite::BuiltinOperator builtin_code;
    std::string custom_code;
    int32_t version;
    OperatorCodeT() : builtin_code(tflite::BuiltinOperator_ADD), version(1) {}
};

struct OperatorCode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef OperatorCodeT NativeTableType;
    typedef OperatorCodeBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return OperatorCodeTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_BUILTIN_CODE = 4,
        VT_CUSTOM_CODE  = 6,
        VT_VERSION      = 8
    };
    tflite::BuiltinOperator builtin_code() const {
        return static_cast<tflite::BuiltinOperator>(GetField<int8_t>(VT_BUILTIN_CODE, 0));
    }
    const flatbuffers::String *custom_code() const {
        return GetPointer<const flatbuffers::String *>(VT_CUSTOM_CODE);
    }
    int32_t version() const {
        return GetField<int32_t>(VT_VERSION, 1);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_BUILTIN_CODE) &&
               VerifyOffset(verifier, VT_CUSTOM_CODE) && verifier.VerifyString(custom_code()) &&
               VerifyField<int32_t>(verifier, VT_VERSION) && verifier.EndTable();
    }
    OperatorCodeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(OperatorCodeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<OperatorCode> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT *_o,
                                                  const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OperatorCodeBuilder {
    typedef OperatorCode Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_builtin_code(tflite::BuiltinOperator builtin_code) {
        fbb_.AddElement<int8_t>(OperatorCode::VT_BUILTIN_CODE, static_cast<int8_t>(builtin_code), 0);
    }
    void add_custom_code(flatbuffers::Offset<flatbuffers::String> custom_code) {
        fbb_.AddOffset(OperatorCode::VT_CUSTOM_CODE, custom_code);
    }
    void add_version(int32_t version) {
        fbb_.AddElement<int32_t>(OperatorCode::VT_VERSION, version, 1);
    }
    explicit OperatorCodeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    OperatorCodeBuilder &operator=(const OperatorCodeBuilder &);
    flatbuffers::Offset<OperatorCode> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<OperatorCode>(end);
        return o;
    }
};

inline flatbuffers::Offset<OperatorCode> CreateOperatorCode(
    flatbuffers::FlatBufferBuilder &_fbb, tflite::BuiltinOperator builtin_code = tflite::BuiltinOperator_ADD,
    flatbuffers::Offset<flatbuffers::String> custom_code = 0, int32_t version = 1) {
    OperatorCodeBuilder builder_(_fbb);
    builder_.add_version(version);
    builder_.add_custom_code(custom_code);
    builder_.add_builtin_code(builtin_code);
    return builder_.Finish();
}

inline flatbuffers::Offset<OperatorCode> CreateOperatorCodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb, tflite::BuiltinOperator builtin_code = tflite::BuiltinOperator_ADD,
    const char *custom_code = nullptr, int32_t version = 1) {
    auto custom_code__ = custom_code ? _fbb.CreateString(custom_code) : 0;
    return tflite::CreateOperatorCode(_fbb, builtin_code, custom_code__, version);
}

flatbuffers::Offset<OperatorCode> CreateOperatorCode(flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT *_o,
                                                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OperatorT : public flatbuffers::NativeTable {
    typedef Operator TableType;
    uint32_t opcode_index;
    std::vector<int32_t> inputs;
    std::vector<int32_t> outputs;
    tflite::BuiltinOptionsUnion builtin_options;
    std::vector<uint8_t> custom_options;
    tflite::CustomOptionsFormat custom_options_format;
    std::vector<bool> mutating_variable_inputs;
    OperatorT() : opcode_index(0), custom_options_format(tflite::CustomOptionsFormat_FLEXBUFFERS) {}
};

struct Operator FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef OperatorT NativeTableType;
    typedef OperatorBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return OperatorTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_OPCODE_INDEX             = 4,
        VT_INPUTS                   = 6,
        VT_OUTPUTS                  = 8,
        VT_BUILTIN_OPTIONS_TYPE     = 10,
        VT_BUILTIN_OPTIONS          = 12,
        VT_CUSTOM_OPTIONS           = 14,
        VT_CUSTOM_OPTIONS_FORMAT    = 16,
        VT_MUTATING_VARIABLE_INPUTS = 18
    };
    uint32_t opcode_index() const {
        return GetField<uint32_t>(VT_OPCODE_INDEX, 0);
    }
    const flatbuffers::Vector<int32_t> *inputs() const {
        return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUTS);
    }
    const flatbuffers::Vector<int32_t> *outputs() const {
        return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
    }
    tflite::BuiltinOptions builtin_options_type() const {
        return static_cast<tflite::BuiltinOptions>(GetField<uint8_t>(VT_BUILTIN_OPTIONS_TYPE, 0));
    }
    const void *builtin_options() const {
        return GetPointer<const void *>(VT_BUILTIN_OPTIONS);
    }
    template <typename T>
    const T *builtin_options_as() const;
    const tflite::Conv2DOptions *builtin_options_as_Conv2DOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_Conv2DOptions
                   ? static_cast<const tflite::Conv2DOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::DepthwiseConv2DOptions *builtin_options_as_DepthwiseConv2DOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_DepthwiseConv2DOptions
                   ? static_cast<const tflite::DepthwiseConv2DOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::ConcatEmbeddingsOptions *builtin_options_as_ConcatEmbeddingsOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_ConcatEmbeddingsOptions
                   ? static_cast<const tflite::ConcatEmbeddingsOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::LSHProjectionOptions *builtin_options_as_LSHProjectionOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_LSHProjectionOptions
                   ? static_cast<const tflite::LSHProjectionOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::Pool2DOptions *builtin_options_as_Pool2DOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_Pool2DOptions
                   ? static_cast<const tflite::Pool2DOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SVDFOptions *builtin_options_as_SVDFOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SVDFOptions
                   ? static_cast<const tflite::SVDFOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::RNNOptions *builtin_options_as_RNNOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_RNNOptions
                   ? static_cast<const tflite::RNNOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::FullyConnectedOptions *builtin_options_as_FullyConnectedOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_FullyConnectedOptions
                   ? static_cast<const tflite::FullyConnectedOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SoftmaxOptions *builtin_options_as_SoftmaxOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SoftmaxOptions
                   ? static_cast<const tflite::SoftmaxOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::ConcatenationOptions *builtin_options_as_ConcatenationOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_ConcatenationOptions
                   ? static_cast<const tflite::ConcatenationOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::AddOptions *builtin_options_as_AddOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_AddOptions
                   ? static_cast<const tflite::AddOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::L2NormOptions *builtin_options_as_L2NormOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_L2NormOptions
                   ? static_cast<const tflite::L2NormOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::LocalResponseNormalizationOptions *builtin_options_as_LocalResponseNormalizationOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_LocalResponseNormalizationOptions
                   ? static_cast<const tflite::LocalResponseNormalizationOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::LSTMOptions *builtin_options_as_LSTMOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_LSTMOptions
                   ? static_cast<const tflite::LSTMOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::ResizeBilinearOptions *builtin_options_as_ResizeBilinearOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_ResizeBilinearOptions
                   ? static_cast<const tflite::ResizeBilinearOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::CallOptions *builtin_options_as_CallOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_CallOptions
                   ? static_cast<const tflite::CallOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::ReshapeOptions *builtin_options_as_ReshapeOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_ReshapeOptions
                   ? static_cast<const tflite::ReshapeOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SkipGramOptions *builtin_options_as_SkipGramOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SkipGramOptions
                   ? static_cast<const tflite::SkipGramOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SpaceToDepthOptions *builtin_options_as_SpaceToDepthOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SpaceToDepthOptions
                   ? static_cast<const tflite::SpaceToDepthOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::EmbeddingLookupSparseOptions *builtin_options_as_EmbeddingLookupSparseOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_EmbeddingLookupSparseOptions
                   ? static_cast<const tflite::EmbeddingLookupSparseOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::MulOptions *builtin_options_as_MulOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_MulOptions
                   ? static_cast<const tflite::MulOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::PadOptions *builtin_options_as_PadOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_PadOptions
                   ? static_cast<const tflite::PadOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::GatherOptions *builtin_options_as_GatherOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_GatherOptions
                   ? static_cast<const tflite::GatherOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::BatchToSpaceNDOptions *builtin_options_as_BatchToSpaceNDOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_BatchToSpaceNDOptions
                   ? static_cast<const tflite::BatchToSpaceNDOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SpaceToBatchNDOptions *builtin_options_as_SpaceToBatchNDOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SpaceToBatchNDOptions
                   ? static_cast<const tflite::SpaceToBatchNDOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::TransposeOptions *builtin_options_as_TransposeOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_TransposeOptions
                   ? static_cast<const tflite::TransposeOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::ReducerOptions *builtin_options_as_ReducerOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_ReducerOptions
                   ? static_cast<const tflite::ReducerOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SubOptions *builtin_options_as_SubOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SubOptions
                   ? static_cast<const tflite::SubOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::DivOptions *builtin_options_as_DivOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_DivOptions
                   ? static_cast<const tflite::DivOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SqueezeOptions *builtin_options_as_SqueezeOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SqueezeOptions
                   ? static_cast<const tflite::SqueezeOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SequenceRNNOptions *builtin_options_as_SequenceRNNOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SequenceRNNOptions
                   ? static_cast<const tflite::SequenceRNNOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::StridedSliceOptions *builtin_options_as_StridedSliceOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_StridedSliceOptions
                   ? static_cast<const tflite::StridedSliceOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::ExpOptions *builtin_options_as_ExpOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_ExpOptions
                   ? static_cast<const tflite::ExpOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::TopKV2Options *builtin_options_as_TopKV2Options() const {
        return builtin_options_type() == tflite::BuiltinOptions_TopKV2Options
                   ? static_cast<const tflite::TopKV2Options *>(builtin_options())
                   : nullptr;
    }
    const tflite::SplitOptions *builtin_options_as_SplitOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SplitOptions
                   ? static_cast<const tflite::SplitOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::LogSoftmaxOptions *builtin_options_as_LogSoftmaxOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_LogSoftmaxOptions
                   ? static_cast<const tflite::LogSoftmaxOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::CastOptions *builtin_options_as_CastOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_CastOptions
                   ? static_cast<const tflite::CastOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::DequantizeOptions *builtin_options_as_DequantizeOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_DequantizeOptions
                   ? static_cast<const tflite::DequantizeOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::MaximumMinimumOptions *builtin_options_as_MaximumMinimumOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_MaximumMinimumOptions
                   ? static_cast<const tflite::MaximumMinimumOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::ArgMaxOptions *builtin_options_as_ArgMaxOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_ArgMaxOptions
                   ? static_cast<const tflite::ArgMaxOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::LessOptions *builtin_options_as_LessOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_LessOptions
                   ? static_cast<const tflite::LessOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::NegOptions *builtin_options_as_NegOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_NegOptions
                   ? static_cast<const tflite::NegOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::PadV2Options *builtin_options_as_PadV2Options() const {
        return builtin_options_type() == tflite::BuiltinOptions_PadV2Options
                   ? static_cast<const tflite::PadV2Options *>(builtin_options())
                   : nullptr;
    }
    const tflite::GreaterOptions *builtin_options_as_GreaterOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_GreaterOptions
                   ? static_cast<const tflite::GreaterOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::GreaterEqualOptions *builtin_options_as_GreaterEqualOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_GreaterEqualOptions
                   ? static_cast<const tflite::GreaterEqualOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::LessEqualOptions *builtin_options_as_LessEqualOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_LessEqualOptions
                   ? static_cast<const tflite::LessEqualOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SelectOptions *builtin_options_as_SelectOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SelectOptions
                   ? static_cast<const tflite::SelectOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SliceOptions *builtin_options_as_SliceOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SliceOptions
                   ? static_cast<const tflite::SliceOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::TransposeConvOptions *builtin_options_as_TransposeConvOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_TransposeConvOptions
                   ? static_cast<const tflite::TransposeConvOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SparseToDenseOptions *builtin_options_as_SparseToDenseOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SparseToDenseOptions
                   ? static_cast<const tflite::SparseToDenseOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::TileOptions *builtin_options_as_TileOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_TileOptions
                   ? static_cast<const tflite::TileOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::ExpandDimsOptions *builtin_options_as_ExpandDimsOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_ExpandDimsOptions
                   ? static_cast<const tflite::ExpandDimsOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::EqualOptions *builtin_options_as_EqualOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_EqualOptions
                   ? static_cast<const tflite::EqualOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::NotEqualOptions *builtin_options_as_NotEqualOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_NotEqualOptions
                   ? static_cast<const tflite::NotEqualOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::ShapeOptions *builtin_options_as_ShapeOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_ShapeOptions
                   ? static_cast<const tflite::ShapeOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::PowOptions *builtin_options_as_PowOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_PowOptions
                   ? static_cast<const tflite::PowOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::ArgMinOptions *builtin_options_as_ArgMinOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_ArgMinOptions
                   ? static_cast<const tflite::ArgMinOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::FakeQuantOptions *builtin_options_as_FakeQuantOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_FakeQuantOptions
                   ? static_cast<const tflite::FakeQuantOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::PackOptions *builtin_options_as_PackOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_PackOptions
                   ? static_cast<const tflite::PackOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::LogicalOrOptions *builtin_options_as_LogicalOrOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_LogicalOrOptions
                   ? static_cast<const tflite::LogicalOrOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::OneHotOptions *builtin_options_as_OneHotOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_OneHotOptions
                   ? static_cast<const tflite::OneHotOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::LogicalAndOptions *builtin_options_as_LogicalAndOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_LogicalAndOptions
                   ? static_cast<const tflite::LogicalAndOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::LogicalNotOptions *builtin_options_as_LogicalNotOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_LogicalNotOptions
                   ? static_cast<const tflite::LogicalNotOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::UnpackOptions *builtin_options_as_UnpackOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_UnpackOptions
                   ? static_cast<const tflite::UnpackOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::FloorDivOptions *builtin_options_as_FloorDivOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_FloorDivOptions
                   ? static_cast<const tflite::FloorDivOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::SquareOptions *builtin_options_as_SquareOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_SquareOptions
                   ? static_cast<const tflite::SquareOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::ZerosLikeOptions *builtin_options_as_ZerosLikeOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_ZerosLikeOptions
                   ? static_cast<const tflite::ZerosLikeOptions *>(builtin_options())
                   : nullptr;
    }
    const tflite::FillOptions *builtin_options_as_FillOptions() const {
        return builtin_options_type() == tflite::BuiltinOptions_FillOptions
                   ? static_cast<const tflite::FillOptions *>(builtin_options())
                   : nullptr;
    }
    const flatbuffers::Vector<uint8_t> *custom_options() const {
        return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CUSTOM_OPTIONS);
    }
    tflite::CustomOptionsFormat custom_options_format() const {
        return static_cast<tflite::CustomOptionsFormat>(GetField<int8_t>(VT_CUSTOM_OPTIONS_FORMAT, 0));
    }
    const flatbuffers::Vector<uint8_t> *mutating_variable_inputs() const {
        return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_MUTATING_VARIABLE_INPUTS);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_OPCODE_INDEX) &&
               VerifyOffset(verifier, VT_INPUTS) && verifier.VerifyVector(inputs()) &&
               VerifyOffset(verifier, VT_OUTPUTS) && verifier.VerifyVector(outputs()) &&
               VerifyField<uint8_t>(verifier, VT_BUILTIN_OPTIONS_TYPE) && VerifyOffset(verifier, VT_BUILTIN_OPTIONS) &&
               VerifyBuiltinOptions(verifier, builtin_options(), builtin_options_type()) &&
               VerifyOffset(verifier, VT_CUSTOM_OPTIONS) && verifier.VerifyVector(custom_options()) &&
               VerifyField<int8_t>(verifier, VT_CUSTOM_OPTIONS_FORMAT) &&
               VerifyOffset(verifier, VT_MUTATING_VARIABLE_INPUTS) &&
               verifier.VerifyVector(mutating_variable_inputs()) && verifier.EndTable();
    }
    OperatorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(OperatorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<Operator> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT *_o,
                                              const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template <>
inline const tflite::Conv2DOptions *Operator::builtin_options_as<tflite::Conv2DOptions>() const {
    return builtin_options_as_Conv2DOptions();
}

template <>
inline const tflite::DepthwiseConv2DOptions *Operator::builtin_options_as<tflite::DepthwiseConv2DOptions>() const {
    return builtin_options_as_DepthwiseConv2DOptions();
}

template <>
inline const tflite::ConcatEmbeddingsOptions *Operator::builtin_options_as<tflite::ConcatEmbeddingsOptions>() const {
    return builtin_options_as_ConcatEmbeddingsOptions();
}

template <>
inline const tflite::LSHProjectionOptions *Operator::builtin_options_as<tflite::LSHProjectionOptions>() const {
    return builtin_options_as_LSHProjectionOptions();
}

template <>
inline const tflite::Pool2DOptions *Operator::builtin_options_as<tflite::Pool2DOptions>() const {
    return builtin_options_as_Pool2DOptions();
}

template <>
inline const tflite::SVDFOptions *Operator::builtin_options_as<tflite::SVDFOptions>() const {
    return builtin_options_as_SVDFOptions();
}

template <>
inline const tflite::RNNOptions *Operator::builtin_options_as<tflite::RNNOptions>() const {
    return builtin_options_as_RNNOptions();
}

template <>
inline const tflite::FullyConnectedOptions *Operator::builtin_options_as<tflite::FullyConnectedOptions>() const {
    return builtin_options_as_FullyConnectedOptions();
}

template <>
inline const tflite::SoftmaxOptions *Operator::builtin_options_as<tflite::SoftmaxOptions>() const {
    return builtin_options_as_SoftmaxOptions();
}

template <>
inline const tflite::ConcatenationOptions *Operator::builtin_options_as<tflite::ConcatenationOptions>() const {
    return builtin_options_as_ConcatenationOptions();
}

template <>
inline const tflite::AddOptions *Operator::builtin_options_as<tflite::AddOptions>() const {
    return builtin_options_as_AddOptions();
}

template <>
inline const tflite::L2NormOptions *Operator::builtin_options_as<tflite::L2NormOptions>() const {
    return builtin_options_as_L2NormOptions();
}

template <>
inline const tflite::LocalResponseNormalizationOptions *
Operator::builtin_options_as<tflite::LocalResponseNormalizationOptions>() const {
    return builtin_options_as_LocalResponseNormalizationOptions();
}

template <>
inline const tflite::LSTMOptions *Operator::builtin_options_as<tflite::LSTMOptions>() const {
    return builtin_options_as_LSTMOptions();
}

template <>
inline const tflite::ResizeBilinearOptions *Operator::builtin_options_as<tflite::ResizeBilinearOptions>() const {
    return builtin_options_as_ResizeBilinearOptions();
}

template <>
inline const tflite::CallOptions *Operator::builtin_options_as<tflite::CallOptions>() const {
    return builtin_options_as_CallOptions();
}

template <>
inline const tflite::ReshapeOptions *Operator::builtin_options_as<tflite::ReshapeOptions>() const {
    return builtin_options_as_ReshapeOptions();
}

template <>
inline const tflite::SkipGramOptions *Operator::builtin_options_as<tflite::SkipGramOptions>() const {
    return builtin_options_as_SkipGramOptions();
}

template <>
inline const tflite::SpaceToDepthOptions *Operator::builtin_options_as<tflite::SpaceToDepthOptions>() const {
    return builtin_options_as_SpaceToDepthOptions();
}

template <>
inline const tflite::EmbeddingLookupSparseOptions *Operator::builtin_options_as<tflite::EmbeddingLookupSparseOptions>()
    const {
    return builtin_options_as_EmbeddingLookupSparseOptions();
}

template <>
inline const tflite::MulOptions *Operator::builtin_options_as<tflite::MulOptions>() const {
    return builtin_options_as_MulOptions();
}

template <>
inline const tflite::PadOptions *Operator::builtin_options_as<tflite::PadOptions>() const {
    return builtin_options_as_PadOptions();
}

template <>
inline const tflite::GatherOptions *Operator::builtin_options_as<tflite::GatherOptions>() const {
    return builtin_options_as_GatherOptions();
}

template <>
inline const tflite::BatchToSpaceNDOptions *Operator::builtin_options_as<tflite::BatchToSpaceNDOptions>() const {
    return builtin_options_as_BatchToSpaceNDOptions();
}

template <>
inline const tflite::SpaceToBatchNDOptions *Operator::builtin_options_as<tflite::SpaceToBatchNDOptions>() const {
    return builtin_options_as_SpaceToBatchNDOptions();
}

template <>
inline const tflite::TransposeOptions *Operator::builtin_options_as<tflite::TransposeOptions>() const {
    return builtin_options_as_TransposeOptions();
}

template <>
inline const tflite::ReducerOptions *Operator::builtin_options_as<tflite::ReducerOptions>() const {
    return builtin_options_as_ReducerOptions();
}

template <>
inline const tflite::SubOptions *Operator::builtin_options_as<tflite::SubOptions>() const {
    return builtin_options_as_SubOptions();
}

template <>
inline const tflite::DivOptions *Operator::builtin_options_as<tflite::DivOptions>() const {
    return builtin_options_as_DivOptions();
}

template <>
inline const tflite::SqueezeOptions *Operator::builtin_options_as<tflite::SqueezeOptions>() const {
    return builtin_options_as_SqueezeOptions();
}

template <>
inline const tflite::SequenceRNNOptions *Operator::builtin_options_as<tflite::SequenceRNNOptions>() const {
    return builtin_options_as_SequenceRNNOptions();
}

template <>
inline const tflite::StridedSliceOptions *Operator::builtin_options_as<tflite::StridedSliceOptions>() const {
    return builtin_options_as_StridedSliceOptions();
}

template <>
inline const tflite::ExpOptions *Operator::builtin_options_as<tflite::ExpOptions>() const {
    return builtin_options_as_ExpOptions();
}

template <>
inline const tflite::TopKV2Options *Operator::builtin_options_as<tflite::TopKV2Options>() const {
    return builtin_options_as_TopKV2Options();
}

template <>
inline const tflite::SplitOptions *Operator::builtin_options_as<tflite::SplitOptions>() const {
    return builtin_options_as_SplitOptions();
}

template <>
inline const tflite::LogSoftmaxOptions *Operator::builtin_options_as<tflite::LogSoftmaxOptions>() const {
    return builtin_options_as_LogSoftmaxOptions();
}

template <>
inline const tflite::CastOptions *Operator::builtin_options_as<tflite::CastOptions>() const {
    return builtin_options_as_CastOptions();
}

template <>
inline const tflite::DequantizeOptions *Operator::builtin_options_as<tflite::DequantizeOptions>() const {
    return builtin_options_as_DequantizeOptions();
}

template <>
inline const tflite::MaximumMinimumOptions *Operator::builtin_options_as<tflite::MaximumMinimumOptions>() const {
    return builtin_options_as_MaximumMinimumOptions();
}

template <>
inline const tflite::ArgMaxOptions *Operator::builtin_options_as<tflite::ArgMaxOptions>() const {
    return builtin_options_as_ArgMaxOptions();
}

template <>
inline const tflite::LessOptions *Operator::builtin_options_as<tflite::LessOptions>() const {
    return builtin_options_as_LessOptions();
}

template <>
inline const tflite::NegOptions *Operator::builtin_options_as<tflite::NegOptions>() const {
    return builtin_options_as_NegOptions();
}

template <>
inline const tflite::PadV2Options *Operator::builtin_options_as<tflite::PadV2Options>() const {
    return builtin_options_as_PadV2Options();
}

template <>
inline const tflite::GreaterOptions *Operator::builtin_options_as<tflite::GreaterOptions>() const {
    return builtin_options_as_GreaterOptions();
}

template <>
inline const tflite::GreaterEqualOptions *Operator::builtin_options_as<tflite::GreaterEqualOptions>() const {
    return builtin_options_as_GreaterEqualOptions();
}

template <>
inline const tflite::LessEqualOptions *Operator::builtin_options_as<tflite::LessEqualOptions>() const {
    return builtin_options_as_LessEqualOptions();
}

template <>
inline const tflite::SelectOptions *Operator::builtin_options_as<tflite::SelectOptions>() const {
    return builtin_options_as_SelectOptions();
}

template <>
inline const tflite::SliceOptions *Operator::builtin_options_as<tflite::SliceOptions>() const {
    return builtin_options_as_SliceOptions();
}

template <>
inline const tflite::TransposeConvOptions *Operator::builtin_options_as<tflite::TransposeConvOptions>() const {
    return builtin_options_as_TransposeConvOptions();
}

template <>
inline const tflite::SparseToDenseOptions *Operator::builtin_options_as<tflite::SparseToDenseOptions>() const {
    return builtin_options_as_SparseToDenseOptions();
}

template <>
inline const tflite::TileOptions *Operator::builtin_options_as<tflite::TileOptions>() const {
    return builtin_options_as_TileOptions();
}

template <>
inline const tflite::ExpandDimsOptions *Operator::builtin_options_as<tflite::ExpandDimsOptions>() const {
    return builtin_options_as_ExpandDimsOptions();
}

template <>
inline const tflite::EqualOptions *Operator::builtin_options_as<tflite::EqualOptions>() const {
    return builtin_options_as_EqualOptions();
}

template <>
inline const tflite::NotEqualOptions *Operator::builtin_options_as<tflite::NotEqualOptions>() const {
    return builtin_options_as_NotEqualOptions();
}

template <>
inline const tflite::ShapeOptions *Operator::builtin_options_as<tflite::ShapeOptions>() const {
    return builtin_options_as_ShapeOptions();
}

template <>
inline const tflite::PowOptions *Operator::builtin_options_as<tflite::PowOptions>() const {
    return builtin_options_as_PowOptions();
}

template <>
inline const tflite::ArgMinOptions *Operator::builtin_options_as<tflite::ArgMinOptions>() const {
    return builtin_options_as_ArgMinOptions();
}

template <>
inline const tflite::FakeQuantOptions *Operator::builtin_options_as<tflite::FakeQuantOptions>() const {
    return builtin_options_as_FakeQuantOptions();
}

template <>
inline const tflite::PackOptions *Operator::builtin_options_as<tflite::PackOptions>() const {
    return builtin_options_as_PackOptions();
}

template <>
inline const tflite::LogicalOrOptions *Operator::builtin_options_as<tflite::LogicalOrOptions>() const {
    return builtin_options_as_LogicalOrOptions();
}

template <>
inline const tflite::OneHotOptions *Operator::builtin_options_as<tflite::OneHotOptions>() const {
    return builtin_options_as_OneHotOptions();
}

template <>
inline const tflite::LogicalAndOptions *Operator::builtin_options_as<tflite::LogicalAndOptions>() const {
    return builtin_options_as_LogicalAndOptions();
}

template <>
inline const tflite::LogicalNotOptions *Operator::builtin_options_as<tflite::LogicalNotOptions>() const {
    return builtin_options_as_LogicalNotOptions();
}

template <>
inline const tflite::UnpackOptions *Operator::builtin_options_as<tflite::UnpackOptions>() const {
    return builtin_options_as_UnpackOptions();
}

template <>
inline const tflite::FloorDivOptions *Operator::builtin_options_as<tflite::FloorDivOptions>() const {
    return builtin_options_as_FloorDivOptions();
}

template <>
inline const tflite::SquareOptions *Operator::builtin_options_as<tflite::SquareOptions>() const {
    return builtin_options_as_SquareOptions();
}

template <>
inline const tflite::ZerosLikeOptions *Operator::builtin_options_as<tflite::ZerosLikeOptions>() const {
    return builtin_options_as_ZerosLikeOptions();
}

template <>
inline const tflite::FillOptions *Operator::builtin_options_as<tflite::FillOptions>() const {
    return builtin_options_as_FillOptions();
}

struct OperatorBuilder {
    typedef Operator Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_opcode_index(uint32_t opcode_index) {
        fbb_.AddElement<uint32_t>(Operator::VT_OPCODE_INDEX, opcode_index, 0);
    }
    void add_inputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs) {
        fbb_.AddOffset(Operator::VT_INPUTS, inputs);
    }
    void add_outputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs) {
        fbb_.AddOffset(Operator::VT_OUTPUTS, outputs);
    }
    void add_builtin_options_type(tflite::BuiltinOptions builtin_options_type) {
        fbb_.AddElement<uint8_t>(Operator::VT_BUILTIN_OPTIONS_TYPE, static_cast<uint8_t>(builtin_options_type), 0);
    }
    void add_builtin_options(flatbuffers::Offset<void> builtin_options) {
        fbb_.AddOffset(Operator::VT_BUILTIN_OPTIONS, builtin_options);
    }
    void add_custom_options(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom_options) {
        fbb_.AddOffset(Operator::VT_CUSTOM_OPTIONS, custom_options);
    }
    void add_custom_options_format(tflite::CustomOptionsFormat custom_options_format) {
        fbb_.AddElement<int8_t>(Operator::VT_CUSTOM_OPTIONS_FORMAT, static_cast<int8_t>(custom_options_format), 0);
    }
    void add_mutating_variable_inputs(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mutating_variable_inputs) {
        fbb_.AddOffset(Operator::VT_MUTATING_VARIABLE_INPUTS, mutating_variable_inputs);
    }
    explicit OperatorBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    OperatorBuilder &operator=(const OperatorBuilder &);
    flatbuffers::Offset<Operator> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<Operator>(end);
        return o;
    }
};

inline flatbuffers::Offset<Operator> CreateOperator(
    flatbuffers::FlatBufferBuilder &_fbb, uint32_t opcode_index = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs  = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs = 0,
    tflite::BuiltinOptions builtin_options_type               = tflite::BuiltinOptions_NONE,
    flatbuffers::Offset<void> builtin_options = 0, flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom_options = 0,
    tflite::CustomOptionsFormat custom_options_format = tflite::CustomOptionsFormat_FLEXBUFFERS,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mutating_variable_inputs = 0) {
    OperatorBuilder builder_(_fbb);
    builder_.add_mutating_variable_inputs(mutating_variable_inputs);
    builder_.add_custom_options(custom_options);
    builder_.add_builtin_options(builtin_options);
    builder_.add_outputs(outputs);
    builder_.add_inputs(inputs);
    builder_.add_opcode_index(opcode_index);
    builder_.add_custom_options_format(custom_options_format);
    builder_.add_builtin_options_type(builtin_options_type);
    return builder_.Finish();
}

inline flatbuffers::Offset<Operator> CreateOperatorDirect(
    flatbuffers::FlatBufferBuilder &_fbb, uint32_t opcode_index = 0, const std::vector<int32_t> *inputs = nullptr,
    const std::vector<int32_t> *outputs         = nullptr,
    tflite::BuiltinOptions builtin_options_type = tflite::BuiltinOptions_NONE,
    flatbuffers::Offset<void> builtin_options = 0, const std::vector<uint8_t> *custom_options = nullptr,
    tflite::CustomOptionsFormat custom_options_format    = tflite::CustomOptionsFormat_FLEXBUFFERS,
    const std::vector<uint8_t> *mutating_variable_inputs = nullptr) {
    auto inputs__         = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;
    auto outputs__        = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
    auto custom_options__ = custom_options ? _fbb.CreateVector<uint8_t>(*custom_options) : 0;
    auto mutating_variable_inputs__ =
        mutating_variable_inputs ? _fbb.CreateVector<uint8_t>(*mutating_variable_inputs) : 0;
    return tflite::CreateOperator(_fbb, opcode_index, inputs__, outputs__, builtin_options_type, builtin_options,
                                  custom_options__, custom_options_format, mutating_variable_inputs__);
}

flatbuffers::Offset<Operator> CreateOperator(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT *_o,
                                             const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubGraphT : public flatbuffers::NativeTable {
    typedef SubGraph TableType;
    std::vector<std::unique_ptr<tflite::TensorT>> tensors;
    std::vector<int32_t> inputs;
    std::vector<int32_t> outputs;
    std::vector<std::unique_ptr<tflite::OperatorT>> operators;
    std::string name;
    SubGraphT() {}
};

struct SubGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef SubGraphT NativeTableType;
    typedef SubGraphBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return SubGraphTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_TENSORS   = 4,
        VT_INPUTS    = 6,
        VT_OUTPUTS   = 8,
        VT_OPERATORS = 10,
        VT_NAME      = 12
    };
    const flatbuffers::Vector<flatbuffers::Offset<tflite::Tensor>> *tensors() const {
        return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::Tensor>> *>(VT_TENSORS);
    }
    const flatbuffers::Vector<int32_t> *inputs() const {
        return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUTS);
    }
    const flatbuffers::Vector<int32_t> *outputs() const {
        return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
    }
    const flatbuffers::Vector<flatbuffers::Offset<tflite::Operator>> *operators() const {
        return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::Operator>> *>(VT_OPERATORS);
    }
    const flatbuffers::String *name() const {
        return GetPointer<const flatbuffers::String *>(VT_NAME);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TENSORS) && verifier.VerifyVector(tensors()) &&
               verifier.VerifyVectorOfTables(tensors()) && VerifyOffset(verifier, VT_INPUTS) &&
               verifier.VerifyVector(inputs()) && VerifyOffset(verifier, VT_OUTPUTS) &&
               verifier.VerifyVector(outputs()) && VerifyOffset(verifier, VT_OPERATORS) &&
               verifier.VerifyVector(operators()) && verifier.VerifyVectorOfTables(operators()) &&
               VerifyOffset(verifier, VT_NAME) && verifier.VerifyString(name()) && verifier.EndTable();
    }
    SubGraphT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(SubGraphT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<SubGraph> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o,
                                              const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubGraphBuilder {
    typedef SubGraph Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_tensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Tensor>>> tensors) {
        fbb_.AddOffset(SubGraph::VT_TENSORS, tensors);
    }
    void add_inputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs) {
        fbb_.AddOffset(SubGraph::VT_INPUTS, inputs);
    }
    void add_outputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs) {
        fbb_.AddOffset(SubGraph::VT_OUTPUTS, outputs);
    }
    void add_operators(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Operator>>> operators) {
        fbb_.AddOffset(SubGraph::VT_OPERATORS, operators);
    }
    void add_name(flatbuffers::Offset<flatbuffers::String> name) {
        fbb_.AddOffset(SubGraph::VT_NAME, name);
    }
    explicit SubGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    SubGraphBuilder &operator=(const SubGraphBuilder &);
    flatbuffers::Offset<SubGraph> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<SubGraph>(end);
        return o;
    }
};

inline flatbuffers::Offset<SubGraph> CreateSubGraph(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Tensor>>> tensors     = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs                                  = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs                                 = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Operator>>> operators = 0,
    flatbuffers::Offset<flatbuffers::String> name                                             = 0) {
    SubGraphBuilder builder_(_fbb);
    builder_.add_name(name);
    builder_.add_operators(operators);
    builder_.add_outputs(outputs);
    builder_.add_inputs(inputs);
    builder_.add_tensors(tensors);
    return builder_.Finish();
}

inline flatbuffers::Offset<SubGraph> CreateSubGraphDirect(
    flatbuffers::FlatBufferBuilder &_fbb, const std::vector<flatbuffers::Offset<tflite::Tensor>> *tensors = nullptr,
    const std::vector<int32_t> *inputs = nullptr, const std::vector<int32_t> *outputs = nullptr,
    const std::vector<flatbuffers::Offset<tflite::Operator>> *operators = nullptr, const char *name = nullptr) {
    auto tensors__   = tensors ? _fbb.CreateVector<flatbuffers::Offset<tflite::Tensor>>(*tensors) : 0;
    auto inputs__    = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;
    auto outputs__   = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
    auto operators__ = operators ? _fbb.CreateVector<flatbuffers::Offset<tflite::Operator>>(*operators) : 0;
    auto name__      = name ? _fbb.CreateString(name) : 0;
    return tflite::CreateSubGraph(_fbb, tensors__, inputs__, outputs__, operators__, name__);
}

flatbuffers::Offset<SubGraph> CreateSubGraph(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o,
                                             const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BufferT : public flatbuffers::NativeTable {
    typedef Buffer TableType;
    std::vector<uint8_t> data;
    BufferT() {}
};

struct Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef BufferT NativeTableType;
    typedef BufferBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return BufferTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_DATA = 4 };
    const flatbuffers::Vector<uint8_t> *data() const {
        return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_DATA) && verifier.VerifyVector(data()) &&
               verifier.EndTable();
    }
    BufferT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(BufferT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<Buffer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BufferT *_o,
                                            const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BufferBuilder {
    typedef Buffer Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
        fbb_.AddOffset(Buffer::VT_DATA, data);
    }
    explicit BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    BufferBuilder &operator=(const BufferBuilder &);
    flatbuffers::Offset<Buffer> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<Buffer>(end);
        return o;
    }
};

inline flatbuffers::Offset<Buffer> CreateBuffer(flatbuffers::FlatBufferBuilder &_fbb,
                                                flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
    BufferBuilder builder_(_fbb);
    builder_.add_data(data);
    return builder_.Finish();
}

inline flatbuffers::Offset<Buffer> CreateBufferDirect(flatbuffers::FlatBufferBuilder &_fbb,
                                                      const std::vector<uint8_t> *data = nullptr) {
    if (data) {
        _fbb.ForceVectorAlignment(data->size(), sizeof(uint8_t), 16);
    }
    auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
    return tflite::CreateBuffer(_fbb, data__);
}

flatbuffers::Offset<Buffer> CreateBuffer(flatbuffers::FlatBufferBuilder &_fbb, const BufferT *_o,
                                         const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ModelT : public flatbuffers::NativeTable {
    typedef Model TableType;
    uint32_t version;
    std::vector<std::unique_ptr<tflite::OperatorCodeT>> operator_codes;
    std::vector<std::unique_ptr<tflite::SubGraphT>> subgraphs;
    std::string description;
    std::vector<std::unique_ptr<tflite::BufferT>> buffers;
    std::vector<int32_t> metadata_buffer;
    ModelT() : version(0) {}
};

struct Model FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef ModelT NativeTableType;
    typedef ModelBuilder Builder;
    static const flatbuffers::TypeTable *MiniReflectTypeTable() {
        return ModelTypeTable();
    }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_VERSION         = 4,
        VT_OPERATOR_CODES  = 6,
        VT_SUBGRAPHS       = 8,
        VT_DESCRIPTION     = 10,
        VT_BUFFERS         = 12,
        VT_METADATA_BUFFER = 14
    };
    uint32_t version() const {
        return GetField<uint32_t>(VT_VERSION, 0);
    }
    const flatbuffers::Vector<flatbuffers::Offset<tflite::OperatorCode>> *operator_codes() const {
        return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::OperatorCode>> *>(VT_OPERATOR_CODES);
    }
    const flatbuffers::Vector<flatbuffers::Offset<tflite::SubGraph>> *subgraphs() const {
        return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::SubGraph>> *>(VT_SUBGRAPHS);
    }
    const flatbuffers::String *description() const {
        return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
    }
    const flatbuffers::Vector<flatbuffers::Offset<tflite::Buffer>> *buffers() const {
        return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::Buffer>> *>(VT_BUFFERS);
    }
    const flatbuffers::Vector<int32_t> *metadata_buffer() const {
        return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_METADATA_BUFFER);
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_VERSION) &&
               VerifyOffset(verifier, VT_OPERATOR_CODES) && verifier.VerifyVector(operator_codes()) &&
               verifier.VerifyVectorOfTables(operator_codes()) && VerifyOffset(verifier, VT_SUBGRAPHS) &&
               verifier.VerifyVector(subgraphs()) && verifier.VerifyVectorOfTables(subgraphs()) &&
               VerifyOffset(verifier, VT_DESCRIPTION) && verifier.VerifyString(description()) &&
               VerifyOffset(verifier, VT_BUFFERS) && verifier.VerifyVector(buffers()) &&
               verifier.VerifyVectorOfTables(buffers()) && VerifyOffset(verifier, VT_METADATA_BUFFER) &&
               verifier.VerifyVector(metadata_buffer()) && verifier.EndTable();
    }
    ModelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    void UnPackTo(ModelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
    static flatbuffers::Offset<Model> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o,
                                           const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ModelBuilder {
    typedef Model Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_version(uint32_t version) {
        fbb_.AddElement<uint32_t>(Model::VT_VERSION, version, 0);
    }
    void add_operator_codes(
        flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::OperatorCode>>> operator_codes) {
        fbb_.AddOffset(Model::VT_OPERATOR_CODES, operator_codes);
    }
    void add_subgraphs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::SubGraph>>> subgraphs) {
        fbb_.AddOffset(Model::VT_SUBGRAPHS, subgraphs);
    }
    void add_description(flatbuffers::Offset<flatbuffers::String> description) {
        fbb_.AddOffset(Model::VT_DESCRIPTION, description);
    }
    void add_buffers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Buffer>>> buffers) {
        fbb_.AddOffset(Model::VT_BUFFERS, buffers);
    }
    void add_metadata_buffer(flatbuffers::Offset<flatbuffers::Vector<int32_t>> metadata_buffer) {
        fbb_.AddOffset(Model::VT_METADATA_BUFFER, metadata_buffer);
    }
    explicit ModelBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ModelBuilder &operator=(const ModelBuilder &);
    flatbuffers::Offset<Model> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o         = flatbuffers::Offset<Model>(end);
        return o;
    }
};

inline flatbuffers::Offset<Model> CreateModel(
    flatbuffers::FlatBufferBuilder &_fbb, uint32_t version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::OperatorCode>>> operator_codes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::SubGraph>>> subgraphs          = 0,
    flatbuffers::Offset<flatbuffers::String> description                                               = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Buffer>>> buffers              = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> metadata_buffer                                  = 0) {
    ModelBuilder builder_(_fbb);
    builder_.add_metadata_buffer(metadata_buffer);
    builder_.add_buffers(buffers);
    builder_.add_description(description);
    builder_.add_subgraphs(subgraphs);
    builder_.add_operator_codes(operator_codes);
    builder_.add_version(version);
    return builder_.Finish();
}

inline flatbuffers::Offset<Model> CreateModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb, uint32_t version = 0,
    const std::vector<flatbuffers::Offset<tflite::OperatorCode>> *operator_codes = nullptr,
    const std::vector<flatbuffers::Offset<tflite::SubGraph>> *subgraphs = nullptr, const char *description = nullptr,
    const std::vector<flatbuffers::Offset<tflite::Buffer>> *buffers = nullptr,
    const std::vector<int32_t> *metadata_buffer                     = nullptr) {
    auto operator_codes__ =
        operator_codes ? _fbb.CreateVector<flatbuffers::Offset<tflite::OperatorCode>>(*operator_codes) : 0;
    auto subgraphs__       = subgraphs ? _fbb.CreateVector<flatbuffers::Offset<tflite::SubGraph>>(*subgraphs) : 0;
    auto description__     = description ? _fbb.CreateString(description) : 0;
    auto buffers__         = buffers ? _fbb.CreateVector<flatbuffers::Offset<tflite::Buffer>>(*buffers) : 0;
    auto metadata_buffer__ = metadata_buffer ? _fbb.CreateVector<int32_t>(*metadata_buffer) : 0;
    return tflite::CreateModel(_fbb, version, operator_codes__, subgraphs__, description__, buffers__,
                               metadata_buffer__);
}

flatbuffers::Offset<Model> CreateModel(flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o,
                                       const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline QuantizationParametersT *QuantizationParameters::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::QuantizationParametersT> _o =
        std::unique_ptr<tflite::QuantizationParametersT>(new QuantizationParametersT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void QuantizationParameters::UnPackTo(QuantizationParametersT *_o,
                                             const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e = min();
        if (_e) {
            _o->min.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->min[_i] = _e->Get(_i);
            }
        }
    }
    {
        auto _e = max();
        if (_e) {
            _o->max.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->max[_i] = _e->Get(_i);
            }
        }
    }
    {
        auto _e = scale();
        if (_e) {
            _o->scale.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->scale[_i] = _e->Get(_i);
            }
        }
    }
    {
        auto _e = zeroPoint();
        if (_e) {
            _o->zeroPoint.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->zeroPoint[_i] = _e->Get(_i);
            }
        }
    }
}

inline flatbuffers::Offset<QuantizationParameters> QuantizationParameters::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateQuantizationParameters(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(
    flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const QuantizationParametersT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _min       = _o->min.size() ? _fbb.CreateVector(_o->min) : 0;
    auto _max       = _o->max.size() ? _fbb.CreateVector(_o->max) : 0;
    auto _scale     = _o->scale.size() ? _fbb.CreateVector(_o->scale) : 0;
    auto _zeroPoint = _o->zeroPoint.size() ? _fbb.CreateVector(_o->zeroPoint) : 0;
    return tflite::CreateQuantizationParameters(_fbb, _min, _max, _scale, _zeroPoint);
}

inline TensorT *Tensor::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::TensorT> _o = std::unique_ptr<tflite::TensorT>(new TensorT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void Tensor::UnPackTo(TensorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e = shape();
        if (_e) {
            _o->shape.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->shape[_i] = _e->Get(_i);
            }
        }
    }
    {
        auto _e  = type();
        _o->type = _e;
    }
    {
        auto _e    = buffer();
        _o->buffer = _e;
    }
    {
        auto _e = name();
        if (_e)
            _o->name = _e->str();
    }
    {
        auto _e = quantization();
        if (_e)
            _o->quantization = std::unique_ptr<tflite::QuantizationParametersT>(_e->UnPack(_resolver));
    }
    {
        auto _e         = is_variable();
        _o->is_variable = _e;
    }
}

inline flatbuffers::Offset<Tensor> Tensor::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateTensor(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Tensor> CreateTensor(flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const TensorT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _shape        = _o->shape.size() ? _fbb.CreateVector(_o->shape) : 0;
    auto _type         = _o->type;
    auto _buffer       = _o->buffer;
    auto _name         = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
    auto _quantization = _o->quantization ? CreateQuantizationParameters(_fbb, _o->quantization.get(), _rehasher) : 0;
    auto _is_variable  = _o->is_variable;
    return tflite::CreateTensor(_fbb, _shape, _type, _buffer, _name, _quantization, _is_variable);
}

inline Conv2DOptionsT *Conv2DOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::Conv2DOptionsT> _o = std::unique_ptr<tflite::Conv2DOptionsT>(new Conv2DOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void Conv2DOptions::UnPackTo(Conv2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e     = padding();
        _o->padding = _e;
    }
    {
        auto _e      = stride_w();
        _o->stride_w = _e;
    }
    {
        auto _e      = stride_h();
        _o->stride_h = _e;
    }
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
    {
        auto _e               = dilation_w_factor();
        _o->dilation_w_factor = _e;
    }
    {
        auto _e               = dilation_h_factor();
        _o->dilation_h_factor = _e;
    }
}

inline flatbuffers::Offset<Conv2DOptions> Conv2DOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const Conv2DOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateConv2DOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const Conv2DOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const Conv2DOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _padding                   = _o->padding;
    auto _stride_w                  = _o->stride_w;
    auto _stride_h                  = _o->stride_h;
    auto _fused_activation_function = _o->fused_activation_function;
    auto _dilation_w_factor         = _o->dilation_w_factor;
    auto _dilation_h_factor         = _o->dilation_h_factor;
    return tflite::CreateConv2DOptions(_fbb, _padding, _stride_w, _stride_h, _fused_activation_function,
                                       _dilation_w_factor, _dilation_h_factor);
}

inline Pool2DOptionsT *Pool2DOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::Pool2DOptionsT> _o = std::unique_ptr<tflite::Pool2DOptionsT>(new Pool2DOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void Pool2DOptions::UnPackTo(Pool2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e     = padding();
        _o->padding = _e;
    }
    {
        auto _e      = stride_w();
        _o->stride_w = _e;
    }
    {
        auto _e      = stride_h();
        _o->stride_h = _e;
    }
    {
        auto _e          = filter_width();
        _o->filter_width = _e;
    }
    {
        auto _e           = filter_height();
        _o->filter_height = _e;
    }
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
}

inline flatbuffers::Offset<Pool2DOptions> Pool2DOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const Pool2DOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    return CreatePool2DOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const Pool2DOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const Pool2DOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _padding                   = _o->padding;
    auto _stride_w                  = _o->stride_w;
    auto _stride_h                  = _o->stride_h;
    auto _filter_width              = _o->filter_width;
    auto _filter_height             = _o->filter_height;
    auto _fused_activation_function = _o->fused_activation_function;
    return tflite::CreatePool2DOptions(_fbb, _padding, _stride_w, _stride_h, _filter_width, _filter_height,
                                       _fused_activation_function);
}

inline DepthwiseConv2DOptionsT *DepthwiseConv2DOptions::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::DepthwiseConv2DOptionsT> _o =
        std::unique_ptr<tflite::DepthwiseConv2DOptionsT>(new DepthwiseConv2DOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void DepthwiseConv2DOptions::UnPackTo(DepthwiseConv2DOptionsT *_o,
                                             const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e     = padding();
        _o->padding = _e;
    }
    {
        auto _e      = stride_w();
        _o->stride_w = _e;
    }
    {
        auto _e      = stride_h();
        _o->stride_h = _e;
    }
    {
        auto _e              = depth_multiplier();
        _o->depth_multiplier = _e;
    }
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
    {
        auto _e               = dilation_w_factor();
        _o->dilation_w_factor = _e;
    }
    {
        auto _e               = dilation_h_factor();
        _o->dilation_h_factor = _e;
    }
}

inline flatbuffers::Offset<DepthwiseConv2DOptions> DepthwiseConv2DOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateDepthwiseConv2DOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const DepthwiseConv2DOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _padding                   = _o->padding;
    auto _stride_w                  = _o->stride_w;
    auto _stride_h                  = _o->stride_h;
    auto _depth_multiplier          = _o->depth_multiplier;
    auto _fused_activation_function = _o->fused_activation_function;
    auto _dilation_w_factor         = _o->dilation_w_factor;
    auto _dilation_h_factor         = _o->dilation_h_factor;
    return tflite::CreateDepthwiseConv2DOptions(_fbb, _padding, _stride_w, _stride_h, _depth_multiplier,
                                                _fused_activation_function, _dilation_w_factor, _dilation_h_factor);
}

inline ConcatEmbeddingsOptionsT *ConcatEmbeddingsOptions::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ConcatEmbeddingsOptionsT> _o =
        std::unique_ptr<tflite::ConcatEmbeddingsOptionsT>(new ConcatEmbeddingsOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void ConcatEmbeddingsOptions::UnPackTo(ConcatEmbeddingsOptionsT *_o,
                                              const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e          = num_channels();
        _o->num_channels = _e;
    }
    {
        auto _e = num_columns_per_channel();
        if (_e) {
            _o->num_columns_per_channel.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->num_columns_per_channel[_i] = _e->Get(_i);
            }
        }
    }
    {
        auto _e = embedding_dim_per_channel();
        if (_e) {
            _o->embedding_dim_per_channel.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->embedding_dim_per_channel[_i] = _e->Get(_i);
            }
        }
    }
}

inline flatbuffers::Offset<ConcatEmbeddingsOptions> ConcatEmbeddingsOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateConcatEmbeddingsOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ConcatEmbeddingsOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _num_channels = _o->num_channels;
    auto _num_columns_per_channel =
        _o->num_columns_per_channel.size() ? _fbb.CreateVector(_o->num_columns_per_channel) : 0;
    auto _embedding_dim_per_channel =
        _o->embedding_dim_per_channel.size() ? _fbb.CreateVector(_o->embedding_dim_per_channel) : 0;
    return tflite::CreateConcatEmbeddingsOptions(_fbb, _num_channels, _num_columns_per_channel,
                                                 _embedding_dim_per_channel);
}

inline LSHProjectionOptionsT *LSHProjectionOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::LSHProjectionOptionsT> _o =
        std::unique_ptr<tflite::LSHProjectionOptionsT>(new LSHProjectionOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void LSHProjectionOptions::UnPackTo(LSHProjectionOptionsT *_o,
                                           const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e  = type();
        _o->type = _e;
    }
}

inline flatbuffers::Offset<LSHProjectionOptions> LSHProjectionOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateLSHProjectionOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LSHProjectionOptions> CreateLSHProjectionOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const LSHProjectionOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _type = _o->type;
    return tflite::CreateLSHProjectionOptions(_fbb, _type);
}

inline SVDFOptionsT *SVDFOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SVDFOptionsT> _o = std::unique_ptr<tflite::SVDFOptionsT>(new SVDFOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SVDFOptions::UnPackTo(SVDFOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e  = rank();
        _o->rank = _e;
    }
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
}

inline flatbuffers::Offset<SVDFOptions> SVDFOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSVDFOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SVDFOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _rank                      = _o->rank;
    auto _fused_activation_function = _o->fused_activation_function;
    return tflite::CreateSVDFOptions(_fbb, _rank, _fused_activation_function);
}

inline RNNOptionsT *RNNOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::RNNOptionsT> _o = std::unique_ptr<tflite::RNNOptionsT>(new RNNOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void RNNOptions::UnPackTo(RNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
}

inline flatbuffers::Offset<RNNOptions> RNNOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateRNNOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RNNOptions> CreateRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const RNNOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _fused_activation_function = _o->fused_activation_function;
    return tflite::CreateRNNOptions(_fbb, _fused_activation_function);
}

inline SequenceRNNOptionsT *SequenceRNNOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SequenceRNNOptionsT> _o =
        std::unique_ptr<tflite::SequenceRNNOptionsT>(new SequenceRNNOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SequenceRNNOptions::UnPackTo(SequenceRNNOptionsT *_o,
                                         const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e        = time_major();
        _o->time_major = _e;
    }
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
}

inline flatbuffers::Offset<SequenceRNNOptions> SequenceRNNOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSequenceRNNOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SequenceRNNOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _time_major                = _o->time_major;
    auto _fused_activation_function = _o->fused_activation_function;
    return tflite::CreateSequenceRNNOptions(_fbb, _time_major, _fused_activation_function);
}

inline BidirectionalSequenceRNNOptionsT *BidirectionalSequenceRNNOptions::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::BidirectionalSequenceRNNOptionsT> _o =
        std::unique_ptr<tflite::BidirectionalSequenceRNNOptionsT>(new BidirectionalSequenceRNNOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void BidirectionalSequenceRNNOptions::UnPackTo(BidirectionalSequenceRNNOptionsT *_o,
                                                      const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e        = time_major();
        _o->time_major = _e;
    }
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
}

inline flatbuffers::Offset<BidirectionalSequenceRNNOptions> BidirectionalSequenceRNNOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateBidirectionalSequenceRNNOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const BidirectionalSequenceRNNOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _time_major                = _o->time_major;
    auto _fused_activation_function = _o->fused_activation_function;
    return tflite::CreateBidirectionalSequenceRNNOptions(_fbb, _time_major, _fused_activation_function);
}

inline FullyConnectedOptionsT *FullyConnectedOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::FullyConnectedOptionsT> _o =
        std::unique_ptr<tflite::FullyConnectedOptionsT>(new FullyConnectedOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void FullyConnectedOptions::UnPackTo(FullyConnectedOptionsT *_o,
                                            const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
    {
        auto _e            = weights_format();
        _o->weights_format = _e;
    }
}

inline flatbuffers::Offset<FullyConnectedOptions> FullyConnectedOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateFullyConnectedOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const FullyConnectedOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _fused_activation_function = _o->fused_activation_function;
    auto _weights_format            = _o->weights_format;
    return tflite::CreateFullyConnectedOptions(_fbb, _fused_activation_function, _weights_format);
}

inline SoftmaxOptionsT *SoftmaxOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SoftmaxOptionsT> _o = std::unique_ptr<tflite::SoftmaxOptionsT>(new SoftmaxOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SoftmaxOptions::UnPackTo(SoftmaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e  = beta();
        _o->beta = _e;
    }
}

inline flatbuffers::Offset<SoftmaxOptions> SoftmaxOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                const SoftmaxOptionsT *_o,
                                                                const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSoftmaxOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SoftmaxOptions> CreateSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                const SoftmaxOptionsT *_o,
                                                                const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SoftmaxOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _beta = _o->beta;
    return tflite::CreateSoftmaxOptions(_fbb, _beta);
}

inline ConcatenationOptionsT *ConcatenationOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ConcatenationOptionsT> _o =
        std::unique_ptr<tflite::ConcatenationOptionsT>(new ConcatenationOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void ConcatenationOptions::UnPackTo(ConcatenationOptionsT *_o,
                                           const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e  = axis();
        _o->axis = _e;
    }
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
}

inline flatbuffers::Offset<ConcatenationOptions> ConcatenationOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateConcatenationOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ConcatenationOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _axis                      = _o->axis;
    auto _fused_activation_function = _o->fused_activation_function;
    return tflite::CreateConcatenationOptions(_fbb, _axis, _fused_activation_function);
}

inline AddOptionsT *AddOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::AddOptionsT> _o = std::unique_ptr<tflite::AddOptionsT>(new AddOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void AddOptions::UnPackTo(AddOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
}

inline flatbuffers::Offset<AddOptions> AddOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateAddOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AddOptions> CreateAddOptions(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const AddOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _fused_activation_function = _o->fused_activation_function;
    return tflite::CreateAddOptions(_fbb, _fused_activation_function);
}

inline MulOptionsT *MulOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::MulOptionsT> _o = std::unique_ptr<tflite::MulOptionsT>(new MulOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void MulOptions::UnPackTo(MulOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
}

inline flatbuffers::Offset<MulOptions> MulOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateMulOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MulOptions> CreateMulOptions(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const MulOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _fused_activation_function = _o->fused_activation_function;
    return tflite::CreateMulOptions(_fbb, _fused_activation_function);
}

inline L2NormOptionsT *L2NormOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::L2NormOptionsT> _o = std::unique_ptr<tflite::L2NormOptionsT>(new L2NormOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void L2NormOptions::UnPackTo(L2NormOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
}

inline flatbuffers::Offset<L2NormOptions> L2NormOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const L2NormOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateL2NormOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const L2NormOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const L2NormOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _fused_activation_function = _o->fused_activation_function;
    return tflite::CreateL2NormOptions(_fbb, _fused_activation_function);
}

inline LocalResponseNormalizationOptionsT *LocalResponseNormalizationOptions::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::LocalResponseNormalizationOptionsT> _o =
        std::unique_ptr<tflite::LocalResponseNormalizationOptionsT>(new LocalResponseNormalizationOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void LocalResponseNormalizationOptions::UnPackTo(LocalResponseNormalizationOptionsT *_o,
                                                        const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e    = radius();
        _o->radius = _e;
    }
    {
        auto _e  = bias();
        _o->bias = _e;
    }
    {
        auto _e   = alpha();
        _o->alpha = _e;
    }
    {
        auto _e  = beta();
        _o->beta = _e;
    }
}

inline flatbuffers::Offset<LocalResponseNormalizationOptions> LocalResponseNormalizationOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateLocalResponseNormalizationOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const LocalResponseNormalizationOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _radius = _o->radius;
    auto _bias   = _o->bias;
    auto _alpha  = _o->alpha;
    auto _beta   = _o->beta;
    return tflite::CreateLocalResponseNormalizationOptions(_fbb, _radius, _bias, _alpha, _beta);
}

inline LSTMOptionsT *LSTMOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::LSTMOptionsT> _o = std::unique_ptr<tflite::LSTMOptionsT>(new LSTMOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void LSTMOptions::UnPackTo(LSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
    {
        auto _e       = cell_clip();
        _o->cell_clip = _e;
    }
    {
        auto _e       = proj_clip();
        _o->proj_clip = _e;
    }
    {
        auto _e         = kernel_type();
        _o->kernel_type = _e;
    }
}

inline flatbuffers::Offset<LSTMOptions> LSTMOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateLSTMOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const LSTMOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _fused_activation_function = _o->fused_activation_function;
    auto _cell_clip                 = _o->cell_clip;
    auto _proj_clip                 = _o->proj_clip;
    auto _kernel_type               = _o->kernel_type;
    return tflite::CreateLSTMOptions(_fbb, _fused_activation_function, _cell_clip, _proj_clip, _kernel_type);
}

inline ResizeBilinearOptionsT *ResizeBilinearOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ResizeBilinearOptionsT> _o =
        std::unique_ptr<tflite::ResizeBilinearOptionsT>(new ResizeBilinearOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void ResizeBilinearOptions::UnPackTo(ResizeBilinearOptionsT *_o,
                                            const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e          = alignCorners();
        _o->alignCorners = _e;
    }
}

inline flatbuffers::Offset<ResizeBilinearOptions> ResizeBilinearOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateResizeBilinearOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ResizeBilinearOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _alignCorners = _o->alignCorners;
    return tflite::CreateResizeBilinearOptions(_fbb, _alignCorners);
}

inline CallOptionsT *CallOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::CallOptionsT> _o = std::unique_ptr<tflite::CallOptionsT>(new CallOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void CallOptions::UnPackTo(CallOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e      = subgraph();
        _o->subgraph = _e;
    }
}

inline flatbuffers::Offset<CallOptions> CallOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateCallOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CallOptions> CreateCallOptions(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const CallOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _subgraph = _o->subgraph;
    return tflite::CreateCallOptions(_fbb, _subgraph);
}

inline PadOptionsT *PadOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::PadOptionsT> _o = std::unique_ptr<tflite::PadOptionsT>(new PadOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void PadOptions::UnPackTo(PadOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<PadOptions> PadOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    return CreatePadOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PadOptions> CreatePadOptions(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const PadOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreatePadOptions(_fbb);
}

inline PadV2OptionsT *PadV2Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::PadV2OptionsT> _o = std::unique_ptr<tflite::PadV2OptionsT>(new PadV2OptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void PadV2Options::UnPackTo(PadV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<PadV2Options> PadV2Options::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const PadV2OptionsT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    return CreatePadV2Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PadV2Options> CreatePadV2Options(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const PadV2OptionsT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const PadV2OptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreatePadV2Options(_fbb);
}

inline ReshapeOptionsT *ReshapeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ReshapeOptionsT> _o = std::unique_ptr<tflite::ReshapeOptionsT>(new ReshapeOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void ReshapeOptions::UnPackTo(ReshapeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e = new_shape();
        if (_e) {
            _o->new_shape.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->new_shape[_i] = _e->Get(_i);
            }
        }
    }
}

inline flatbuffers::Offset<ReshapeOptions> ReshapeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                const ReshapeOptionsT *_o,
                                                                const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateReshapeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReshapeOptions> CreateReshapeOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                const ReshapeOptionsT *_o,
                                                                const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ReshapeOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _new_shape = _o->new_shape.size() ? _fbb.CreateVector(_o->new_shape) : 0;
    return tflite::CreateReshapeOptions(_fbb, _new_shape);
}

inline SpaceToBatchNDOptionsT *SpaceToBatchNDOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SpaceToBatchNDOptionsT> _o =
        std::unique_ptr<tflite::SpaceToBatchNDOptionsT>(new SpaceToBatchNDOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SpaceToBatchNDOptions::UnPackTo(SpaceToBatchNDOptionsT *_o,
                                            const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<SpaceToBatchNDOptions> SpaceToBatchNDOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSpaceToBatchNDOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SpaceToBatchNDOptions> CreateSpaceToBatchNDOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SpaceToBatchNDOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateSpaceToBatchNDOptions(_fbb);
}

inline BatchToSpaceNDOptionsT *BatchToSpaceNDOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::BatchToSpaceNDOptionsT> _o =
        std::unique_ptr<tflite::BatchToSpaceNDOptionsT>(new BatchToSpaceNDOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void BatchToSpaceNDOptions::UnPackTo(BatchToSpaceNDOptionsT *_o,
                                            const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<BatchToSpaceNDOptions> BatchToSpaceNDOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateBatchToSpaceNDOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatchToSpaceNDOptions> CreateBatchToSpaceNDOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const BatchToSpaceNDOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateBatchToSpaceNDOptions(_fbb);
}

inline SkipGramOptionsT *SkipGramOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SkipGramOptionsT> _o = std::unique_ptr<tflite::SkipGramOptionsT>(new SkipGramOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SkipGramOptions::UnPackTo(SkipGramOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e        = ngram_size();
        _o->ngram_size = _e;
    }
    {
        auto _e           = max_skip_size();
        _o->max_skip_size = _e;
    }
    {
        auto _e                = include_all_ngrams();
        _o->include_all_ngrams = _e;
    }
}

inline flatbuffers::Offset<SkipGramOptions> SkipGramOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                  const SkipGramOptionsT *_o,
                                                                  const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSkipGramOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                  const SkipGramOptionsT *_o,
                                                                  const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SkipGramOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _ngram_size         = _o->ngram_size;
    auto _max_skip_size      = _o->max_skip_size;
    auto _include_all_ngrams = _o->include_all_ngrams;
    return tflite::CreateSkipGramOptions(_fbb, _ngram_size, _max_skip_size, _include_all_ngrams);
}

inline SpaceToDepthOptionsT *SpaceToDepthOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SpaceToDepthOptionsT> _o =
        std::unique_ptr<tflite::SpaceToDepthOptionsT>(new SpaceToDepthOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SpaceToDepthOptions::UnPackTo(SpaceToDepthOptionsT *_o,
                                          const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e        = block_size();
        _o->block_size = _e;
    }
}

inline flatbuffers::Offset<SpaceToDepthOptions> SpaceToDepthOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSpaceToDepthOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SpaceToDepthOptions> CreateSpaceToDepthOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SpaceToDepthOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _block_size = _o->block_size;
    return tflite::CreateSpaceToDepthOptions(_fbb, _block_size);
}

inline SubOptionsT *SubOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SubOptionsT> _o = std::unique_ptr<tflite::SubOptionsT>(new SubOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SubOptions::UnPackTo(SubOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
}

inline flatbuffers::Offset<SubOptions> SubOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSubOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SubOptions> CreateSubOptions(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SubOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _fused_activation_function = _o->fused_activation_function;
    return tflite::CreateSubOptions(_fbb, _fused_activation_function);
}

inline DivOptionsT *DivOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::DivOptionsT> _o = std::unique_ptr<tflite::DivOptionsT>(new DivOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void DivOptions::UnPackTo(DivOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e                       = fused_activation_function();
        _o->fused_activation_function = _e;
    }
}

inline flatbuffers::Offset<DivOptions> DivOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateDivOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DivOptions> CreateDivOptions(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const DivOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _fused_activation_function = _o->fused_activation_function;
    return tflite::CreateDivOptions(_fbb, _fused_activation_function);
}

inline TopKV2OptionsT *TopKV2Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::TopKV2OptionsT> _o = std::unique_ptr<tflite::TopKV2OptionsT>(new TopKV2OptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void TopKV2Options::UnPackTo(TopKV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<TopKV2Options> TopKV2Options::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const TopKV2OptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateTopKV2Options(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const TopKV2OptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const TopKV2OptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateTopKV2Options(_fbb);
}

inline EmbeddingLookupSparseOptionsT *EmbeddingLookupSparseOptions::UnPack(
    const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::EmbeddingLookupSparseOptionsT> _o =
        std::unique_ptr<tflite::EmbeddingLookupSparseOptionsT>(new EmbeddingLookupSparseOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void EmbeddingLookupSparseOptions::UnPackTo(EmbeddingLookupSparseOptionsT *_o,
                                                   const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e      = combiner();
        _o->combiner = _e;
    }
}

inline flatbuffers::Offset<EmbeddingLookupSparseOptions> EmbeddingLookupSparseOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateEmbeddingLookupSparseOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EmbeddingLookupSparseOptions> CreateEmbeddingLookupSparseOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const EmbeddingLookupSparseOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _combiner = _o->combiner;
    return tflite::CreateEmbeddingLookupSparseOptions(_fbb, _combiner);
}

inline GatherOptionsT *GatherOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::GatherOptionsT> _o = std::unique_ptr<tflite::GatherOptionsT>(new GatherOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void GatherOptions::UnPackTo(GatherOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e  = axis();
        _o->axis = _e;
    }
}

inline flatbuffers::Offset<GatherOptions> GatherOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const GatherOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateGatherOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GatherOptions> CreateGatherOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const GatherOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const GatherOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _axis = _o->axis;
    return tflite::CreateGatherOptions(_fbb, _axis);
}

inline TransposeOptionsT *TransposeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::TransposeOptionsT> _o = std::unique_ptr<tflite::TransposeOptionsT>(new TransposeOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void TransposeOptions::UnPackTo(TransposeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<TransposeOptions> TransposeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const TransposeOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateTransposeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TransposeOptions> CreateTransposeOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const TransposeOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const TransposeOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateTransposeOptions(_fbb);
}

inline ExpOptionsT *ExpOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ExpOptionsT> _o = std::unique_ptr<tflite::ExpOptionsT>(new ExpOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void ExpOptions::UnPackTo(ExpOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<ExpOptions> ExpOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateExpOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExpOptions> CreateExpOptions(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ExpOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateExpOptions(_fbb);
}

inline ReducerOptionsT *ReducerOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ReducerOptionsT> _o = std::unique_ptr<tflite::ReducerOptionsT>(new ReducerOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void ReducerOptions::UnPackTo(ReducerOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e      = keepDims();
        _o->keepDims = _e;
    }
}

inline flatbuffers::Offset<ReducerOptions> ReducerOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                const ReducerOptionsT *_o,
                                                                const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateReducerOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReducerOptions> CreateReducerOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                const ReducerOptionsT *_o,
                                                                const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ReducerOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _keepDims = _o->keepDims;
    return tflite::CreateReducerOptions(_fbb, _keepDims);
}

inline SqueezeOptionsT *SqueezeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SqueezeOptionsT> _o = std::unique_ptr<tflite::SqueezeOptionsT>(new SqueezeOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SqueezeOptions::UnPackTo(SqueezeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e = squeezeDims();
        if (_e) {
            _o->squeezeDims.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->squeezeDims[_i] = _e->Get(_i);
            }
        }
    }
}

inline flatbuffers::Offset<SqueezeOptions> SqueezeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                const SqueezeOptionsT *_o,
                                                                const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSqueezeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                const SqueezeOptionsT *_o,
                                                                const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SqueezeOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _squeezeDims = _o->squeezeDims.size() ? _fbb.CreateVector(_o->squeezeDims) : 0;
    return tflite::CreateSqueezeOptions(_fbb, _squeezeDims);
}

inline SplitOptionsT *SplitOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SplitOptionsT> _o = std::unique_ptr<tflite::SplitOptionsT>(new SplitOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SplitOptions::UnPackTo(SplitOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e        = num_splits();
        _o->num_splits = _e;
    }
}

inline flatbuffers::Offset<SplitOptions> SplitOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const SplitOptionsT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSplitOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SplitOptions> CreateSplitOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const SplitOptionsT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SplitOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _num_splits = _o->num_splits;
    return tflite::CreateSplitOptions(_fbb, _num_splits);
}

inline StridedSliceOptionsT *StridedSliceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::StridedSliceOptionsT> _o =
        std::unique_ptr<tflite::StridedSliceOptionsT>(new StridedSliceOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void StridedSliceOptions::UnPackTo(StridedSliceOptionsT *_o,
                                          const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e       = beginMask();
        _o->beginMask = _e;
    }
    {
        auto _e     = endMask();
        _o->endMask = _e;
    }
    {
        auto _e          = ellipsisMask();
        _o->ellipsisMask = _e;
    }
    {
        auto _e         = newAxisMask();
        _o->newAxisMask = _e;
    }
    {
        auto _e            = shrinkAxisMask();
        _o->shrinkAxisMask = _e;
    }
}

inline flatbuffers::Offset<StridedSliceOptions> StridedSliceOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateStridedSliceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const StridedSliceOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _beginMask      = _o->beginMask;
    auto _endMask        = _o->endMask;
    auto _ellipsisMask   = _o->ellipsisMask;
    auto _newAxisMask    = _o->newAxisMask;
    auto _shrinkAxisMask = _o->shrinkAxisMask;
    return tflite::CreateStridedSliceOptions(_fbb, _beginMask, _endMask, _ellipsisMask, _newAxisMask, _shrinkAxisMask);
}

inline LogSoftmaxOptionsT *LogSoftmaxOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::LogSoftmaxOptionsT> _o =
        std::unique_ptr<tflite::LogSoftmaxOptionsT>(new LogSoftmaxOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void LogSoftmaxOptions::UnPackTo(LogSoftmaxOptionsT *_o,
                                        const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<LogSoftmaxOptions> LogSoftmaxOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateLogSoftmaxOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogSoftmaxOptions> CreateLogSoftmaxOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const LogSoftmaxOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateLogSoftmaxOptions(_fbb);
}

inline CastOptionsT *CastOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::CastOptionsT> _o = std::unique_ptr<tflite::CastOptionsT>(new CastOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void CastOptions::UnPackTo(CastOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e          = in_data_type();
        _o->in_data_type = _e;
    }
    {
        auto _e           = out_data_type();
        _o->out_data_type = _e;
    }
}

inline flatbuffers::Offset<CastOptions> CastOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateCastOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CastOptions> CreateCastOptions(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const CastOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _in_data_type  = _o->in_data_type;
    auto _out_data_type = _o->out_data_type;
    return tflite::CreateCastOptions(_fbb, _in_data_type, _out_data_type);
}

inline DequantizeOptionsT *DequantizeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::DequantizeOptionsT> _o =
        std::unique_ptr<tflite::DequantizeOptionsT>(new DequantizeOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void DequantizeOptions::UnPackTo(DequantizeOptionsT *_o,
                                        const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<DequantizeOptions> DequantizeOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateDequantizeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const DequantizeOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateDequantizeOptions(_fbb);
}

inline MaximumMinimumOptionsT *MaximumMinimumOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::MaximumMinimumOptionsT> _o =
        std::unique_ptr<tflite::MaximumMinimumOptionsT>(new MaximumMinimumOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void MaximumMinimumOptions::UnPackTo(MaximumMinimumOptionsT *_o,
                                            const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<MaximumMinimumOptions> MaximumMinimumOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateMaximumMinimumOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const MaximumMinimumOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateMaximumMinimumOptions(_fbb);
}

inline TileOptionsT *TileOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::TileOptionsT> _o = std::unique_ptr<tflite::TileOptionsT>(new TileOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void TileOptions::UnPackTo(TileOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<TileOptions> TileOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateTileOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TileOptions> CreateTileOptions(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const TileOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateTileOptions(_fbb);
}

inline ArgMaxOptionsT *ArgMaxOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ArgMaxOptionsT> _o = std::unique_ptr<tflite::ArgMaxOptionsT>(new ArgMaxOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void ArgMaxOptions::UnPackTo(ArgMaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e         = output_type();
        _o->output_type = _e;
    }
}

inline flatbuffers::Offset<ArgMaxOptions> ArgMaxOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const ArgMaxOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateArgMaxOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ArgMaxOptions> CreateArgMaxOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const ArgMaxOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ArgMaxOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _output_type = _o->output_type;
    return tflite::CreateArgMaxOptions(_fbb, _output_type);
}

inline ArgMinOptionsT *ArgMinOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ArgMinOptionsT> _o = std::unique_ptr<tflite::ArgMinOptionsT>(new ArgMinOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void ArgMinOptions::UnPackTo(ArgMinOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e         = output_type();
        _o->output_type = _e;
    }
}

inline flatbuffers::Offset<ArgMinOptions> ArgMinOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const ArgMinOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateArgMinOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ArgMinOptions> CreateArgMinOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const ArgMinOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ArgMinOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _output_type = _o->output_type;
    return tflite::CreateArgMinOptions(_fbb, _output_type);
}

inline GreaterOptionsT *GreaterOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::GreaterOptionsT> _o = std::unique_ptr<tflite::GreaterOptionsT>(new GreaterOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void GreaterOptions::UnPackTo(GreaterOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<GreaterOptions> GreaterOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                const GreaterOptionsT *_o,
                                                                const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateGreaterOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GreaterOptions> CreateGreaterOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                const GreaterOptionsT *_o,
                                                                const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const GreaterOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateGreaterOptions(_fbb);
}

inline GreaterEqualOptionsT *GreaterEqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::GreaterEqualOptionsT> _o =
        std::unique_ptr<tflite::GreaterEqualOptionsT>(new GreaterEqualOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void GreaterEqualOptions::UnPackTo(GreaterEqualOptionsT *_o,
                                          const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<GreaterEqualOptions> GreaterEqualOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateGreaterEqualOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GreaterEqualOptions> CreateGreaterEqualOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const GreaterEqualOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateGreaterEqualOptions(_fbb);
}

inline LessOptionsT *LessOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::LessOptionsT> _o = std::unique_ptr<tflite::LessOptionsT>(new LessOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void LessOptions::UnPackTo(LessOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<LessOptions> LessOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateLessOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LessOptions> CreateLessOptions(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const LessOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateLessOptions(_fbb);
}

inline LessEqualOptionsT *LessEqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::LessEqualOptionsT> _o = std::unique_ptr<tflite::LessEqualOptionsT>(new LessEqualOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void LessEqualOptions::UnPackTo(LessEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<LessEqualOptions> LessEqualOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const LessEqualOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateLessEqualOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LessEqualOptions> CreateLessEqualOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const LessEqualOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const LessEqualOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateLessEqualOptions(_fbb);
}

inline NegOptionsT *NegOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::NegOptionsT> _o = std::unique_ptr<tflite::NegOptionsT>(new NegOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void NegOptions::UnPackTo(NegOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<NegOptions> NegOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateNegOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NegOptions> CreateNegOptions(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const NegOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateNegOptions(_fbb);
}

inline SelectOptionsT *SelectOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SelectOptionsT> _o = std::unique_ptr<tflite::SelectOptionsT>(new SelectOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SelectOptions::UnPackTo(SelectOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<SelectOptions> SelectOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const SelectOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSelectOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SelectOptions> CreateSelectOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const SelectOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SelectOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateSelectOptions(_fbb);
}

inline SliceOptionsT *SliceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SliceOptionsT> _o = std::unique_ptr<tflite::SliceOptionsT>(new SliceOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SliceOptions::UnPackTo(SliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<SliceOptions> SliceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const SliceOptionsT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSliceOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SliceOptions> CreateSliceOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const SliceOptionsT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SliceOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateSliceOptions(_fbb);
}

inline TransposeConvOptionsT *TransposeConvOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::TransposeConvOptionsT> _o =
        std::unique_ptr<tflite::TransposeConvOptionsT>(new TransposeConvOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void TransposeConvOptions::UnPackTo(TransposeConvOptionsT *_o,
                                           const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e     = padding();
        _o->padding = _e;
    }
    {
        auto _e      = stride_w();
        _o->stride_w = _e;
    }
    {
        auto _e      = stride_h();
        _o->stride_h = _e;
    }
}

inline flatbuffers::Offset<TransposeConvOptions> TransposeConvOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateTransposeConvOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const TransposeConvOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _padding  = _o->padding;
    auto _stride_w = _o->stride_w;
    auto _stride_h = _o->stride_h;
    return tflite::CreateTransposeConvOptions(_fbb, _padding, _stride_w, _stride_h);
}

inline ExpandDimsOptionsT *ExpandDimsOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ExpandDimsOptionsT> _o =
        std::unique_ptr<tflite::ExpandDimsOptionsT>(new ExpandDimsOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void ExpandDimsOptions::UnPackTo(ExpandDimsOptionsT *_o,
                                        const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<ExpandDimsOptions> ExpandDimsOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateExpandDimsOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExpandDimsOptions> CreateExpandDimsOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ExpandDimsOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateExpandDimsOptions(_fbb);
}

inline SparseToDenseOptionsT *SparseToDenseOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SparseToDenseOptionsT> _o =
        std::unique_ptr<tflite::SparseToDenseOptionsT>(new SparseToDenseOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SparseToDenseOptions::UnPackTo(SparseToDenseOptionsT *_o,
                                           const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e             = validateIndices();
        _o->validateIndices = _e;
    }
}

inline flatbuffers::Offset<SparseToDenseOptions> SparseToDenseOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSparseToDenseOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SparseToDenseOptions> CreateSparseToDenseOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SparseToDenseOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _validateIndices = _o->validateIndices;
    return tflite::CreateSparseToDenseOptions(_fbb, _validateIndices);
}

inline EqualOptionsT *EqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::EqualOptionsT> _o = std::unique_ptr<tflite::EqualOptionsT>(new EqualOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void EqualOptions::UnPackTo(EqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<EqualOptions> EqualOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const EqualOptionsT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateEqualOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EqualOptions> CreateEqualOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const EqualOptionsT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const EqualOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateEqualOptions(_fbb);
}

inline NotEqualOptionsT *NotEqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::NotEqualOptionsT> _o = std::unique_ptr<tflite::NotEqualOptionsT>(new NotEqualOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void NotEqualOptions::UnPackTo(NotEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<NotEqualOptions> NotEqualOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                  const NotEqualOptionsT *_o,
                                                                  const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateNotEqualOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NotEqualOptions> CreateNotEqualOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                  const NotEqualOptionsT *_o,
                                                                  const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const NotEqualOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateNotEqualOptions(_fbb);
}

inline ShapeOptionsT *ShapeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ShapeOptionsT> _o = std::unique_ptr<tflite::ShapeOptionsT>(new ShapeOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void ShapeOptions::UnPackTo(ShapeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e      = out_type();
        _o->out_type = _e;
    }
}

inline flatbuffers::Offset<ShapeOptions> ShapeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const ShapeOptionsT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateShapeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ShapeOptions> CreateShapeOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const ShapeOptionsT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ShapeOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _out_type = _o->out_type;
    return tflite::CreateShapeOptions(_fbb, _out_type);
}

inline PowOptionsT *PowOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::PowOptionsT> _o = std::unique_ptr<tflite::PowOptionsT>(new PowOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void PowOptions::UnPackTo(PowOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<PowOptions> PowOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    return CreatePowOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PowOptions> CreatePowOptions(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const PowOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreatePowOptions(_fbb);
}

inline FakeQuantOptionsT *FakeQuantOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::FakeQuantOptionsT> _o = std::unique_ptr<tflite::FakeQuantOptionsT>(new FakeQuantOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void FakeQuantOptions::UnPackTo(FakeQuantOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e = min();
        _o->min = _e;
    }
    {
        auto _e = max();
        _o->max = _e;
    }
    {
        auto _e      = num_bits();
        _o->num_bits = _e;
    }
    {
        auto _e          = narrow_range();
        _o->narrow_range = _e;
    }
}

inline flatbuffers::Offset<FakeQuantOptions> FakeQuantOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const FakeQuantOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateFakeQuantOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const FakeQuantOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const FakeQuantOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _min          = _o->min;
    auto _max          = _o->max;
    auto _num_bits     = _o->num_bits;
    auto _narrow_range = _o->narrow_range;
    return tflite::CreateFakeQuantOptions(_fbb, _min, _max, _num_bits, _narrow_range);
}

inline PackOptionsT *PackOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::PackOptionsT> _o = std::unique_ptr<tflite::PackOptionsT>(new PackOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void PackOptions::UnPackTo(PackOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e          = values_count();
        _o->values_count = _e;
    }
    {
        auto _e  = axis();
        _o->axis = _e;
    }
}

inline flatbuffers::Offset<PackOptions> PackOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    return CreatePackOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PackOptions> CreatePackOptions(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const PackOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _values_count = _o->values_count;
    auto _axis         = _o->axis;
    return tflite::CreatePackOptions(_fbb, _values_count, _axis);
}

inline LogicalOrOptionsT *LogicalOrOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::LogicalOrOptionsT> _o = std::unique_ptr<tflite::LogicalOrOptionsT>(new LogicalOrOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void LogicalOrOptions::UnPackTo(LogicalOrOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<LogicalOrOptions> LogicalOrOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const LogicalOrOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateLogicalOrOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogicalOrOptions> CreateLogicalOrOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const LogicalOrOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const LogicalOrOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateLogicalOrOptions(_fbb);
}

inline OneHotOptionsT *OneHotOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::OneHotOptionsT> _o = std::unique_ptr<tflite::OneHotOptionsT>(new OneHotOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void OneHotOptions::UnPackTo(OneHotOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e  = axis();
        _o->axis = _e;
    }
}

inline flatbuffers::Offset<OneHotOptions> OneHotOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const OneHotOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateOneHotOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const OneHotOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const OneHotOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _axis = _o->axis;
    return tflite::CreateOneHotOptions(_fbb, _axis);
}

inline LogicalAndOptionsT *LogicalAndOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::LogicalAndOptionsT> _o =
        std::unique_ptr<tflite::LogicalAndOptionsT>(new LogicalAndOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void LogicalAndOptions::UnPackTo(LogicalAndOptionsT *_o,
                                        const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<LogicalAndOptions> LogicalAndOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateLogicalAndOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogicalAndOptions> CreateLogicalAndOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const LogicalAndOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateLogicalAndOptions(_fbb);
}

inline LogicalNotOptionsT *LogicalNotOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::LogicalNotOptionsT> _o =
        std::unique_ptr<tflite::LogicalNotOptionsT>(new LogicalNotOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void LogicalNotOptions::UnPackTo(LogicalNotOptionsT *_o,
                                        const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<LogicalNotOptions> LogicalNotOptions::Pack(
    flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateLogicalNotOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogicalNotOptions> CreateLogicalNotOptions(
    flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT *_o,
    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const LogicalNotOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateLogicalNotOptions(_fbb);
}

inline UnpackOptionsT *UnpackOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::UnpackOptionsT> _o = std::unique_ptr<tflite::UnpackOptionsT>(new UnpackOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void UnpackOptions::UnPackTo(UnpackOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e = num();
        _o->num = _e;
    }
    {
        auto _e  = axis();
        _o->axis = _e;
    }
}

inline flatbuffers::Offset<UnpackOptions> UnpackOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const UnpackOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateUnpackOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const UnpackOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const UnpackOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _num  = _o->num;
    auto _axis = _o->axis;
    return tflite::CreateUnpackOptions(_fbb, _num, _axis);
}

inline FloorDivOptionsT *FloorDivOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::FloorDivOptionsT> _o = std::unique_ptr<tflite::FloorDivOptionsT>(new FloorDivOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void FloorDivOptions::UnPackTo(FloorDivOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<FloorDivOptions> FloorDivOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                  const FloorDivOptionsT *_o,
                                                                  const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateFloorDivOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FloorDivOptions> CreateFloorDivOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                  const FloorDivOptionsT *_o,
                                                                  const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const FloorDivOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateFloorDivOptions(_fbb);
}

inline SquareOptionsT *SquareOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SquareOptionsT> _o = std::unique_ptr<tflite::SquareOptionsT>(new SquareOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SquareOptions::UnPackTo(SquareOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<SquareOptions> SquareOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const SquareOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSquareOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SquareOptions> CreateSquareOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                              const SquareOptionsT *_o,
                                                              const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SquareOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateSquareOptions(_fbb);
}

inline ZerosLikeOptionsT *ZerosLikeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ZerosLikeOptionsT> _o = std::unique_ptr<tflite::ZerosLikeOptionsT>(new ZerosLikeOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void ZerosLikeOptions::UnPackTo(ZerosLikeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<ZerosLikeOptions> ZerosLikeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const ZerosLikeOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateZerosLikeOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ZerosLikeOptions> CreateZerosLikeOptions(flatbuffers::FlatBufferBuilder &_fbb,
                                                                    const ZerosLikeOptionsT *_o,
                                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ZerosLikeOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateZerosLikeOptions(_fbb);
}

inline FillOptionsT *FillOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::FillOptionsT> _o = std::unique_ptr<tflite::FillOptionsT>(new FillOptionsT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void FillOptions::UnPackTo(FillOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
}

inline flatbuffers::Offset<FillOptions> FillOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateFillOptions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FillOptions> CreateFillOptions(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT *_o,
                                                          const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const FillOptionsT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    return tflite::CreateFillOptions(_fbb);
}

inline OperatorCodeT *OperatorCode::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::OperatorCodeT> _o = std::unique_ptr<tflite::OperatorCodeT>(new OperatorCodeT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void OperatorCode::UnPackTo(OperatorCodeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e          = builtin_code();
        _o->builtin_code = _e;
    }
    {
        auto _e = custom_code();
        if (_e)
            _o->custom_code = _e->str();
    }
    {
        auto _e     = version();
        _o->version = _e;
    }
}

inline flatbuffers::Offset<OperatorCode> OperatorCode::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const OperatorCodeT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateOperatorCode(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OperatorCode> CreateOperatorCode(flatbuffers::FlatBufferBuilder &_fbb,
                                                            const OperatorCodeT *_o,
                                                            const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const OperatorCodeT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _builtin_code = _o->builtin_code;
    auto _custom_code  = _o->custom_code.empty() ? 0 : _fbb.CreateString(_o->custom_code);
    auto _version      = _o->version;
    return tflite::CreateOperatorCode(_fbb, _builtin_code, _custom_code, _version);
}

inline OperatorT *Operator::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::OperatorT> _o = std::unique_ptr<tflite::OperatorT>(new OperatorT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void Operator::UnPackTo(OperatorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e          = opcode_index();
        _o->opcode_index = _e;
    }
    {
        auto _e = inputs();
        if (_e) {
            _o->inputs.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->inputs[_i] = _e->Get(_i);
            }
        }
    }
    {
        auto _e = outputs();
        if (_e) {
            _o->outputs.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->outputs[_i] = _e->Get(_i);
            }
        }
    }
    {
        auto _e                  = builtin_options_type();
        _o->builtin_options.type = _e;
    }
    {
        auto _e = builtin_options();
        if (_e)
            _o->builtin_options.value = tflite::BuiltinOptionsUnion::UnPack(_e, builtin_options_type(), _resolver);
    }
    {
        auto _e = custom_options();
        if (_e) {
            _o->custom_options.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->custom_options[_i] = _e->Get(_i);
            }
        }
    }
    {
        auto _e                   = custom_options_format();
        _o->custom_options_format = _e;
    }
    {
        auto _e = mutating_variable_inputs();
        if (_e) {
            _o->mutating_variable_inputs.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->mutating_variable_inputs[_i] = _e->Get(_i) != 0;
            }
        }
    }
}

inline flatbuffers::Offset<Operator> Operator::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT *_o,
                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateOperator(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Operator> CreateOperator(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT *_o,
                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const OperatorT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _opcode_index          = _o->opcode_index;
    auto _inputs                = _o->inputs.size() ? _fbb.CreateVector(_o->inputs) : 0;
    auto _outputs               = _o->outputs.size() ? _fbb.CreateVector(_o->outputs) : 0;
    auto _builtin_options_type  = _o->builtin_options.type;
    auto _builtin_options       = _o->builtin_options.Pack(_fbb);
    auto _custom_options        = _o->custom_options.size() ? _fbb.CreateVector(_o->custom_options) : 0;
    auto _custom_options_format = _o->custom_options_format;
    auto _mutating_variable_inputs =
        _o->mutating_variable_inputs.size() ? _fbb.CreateVector(_o->mutating_variable_inputs) : 0;
    return tflite::CreateOperator(_fbb, _opcode_index, _inputs, _outputs, _builtin_options_type, _builtin_options,
                                  _custom_options, _custom_options_format, _mutating_variable_inputs);
}

inline SubGraphT *SubGraph::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::SubGraphT> _o = std::unique_ptr<tflite::SubGraphT>(new SubGraphT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void SubGraph::UnPackTo(SubGraphT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e = tensors();
        if (_e) {
            _o->tensors.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->tensors[_i] = std::unique_ptr<tflite::TensorT>(_e->Get(_i)->UnPack(_resolver));
            }
        }
    }
    {
        auto _e = inputs();
        if (_e) {
            _o->inputs.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->inputs[_i] = _e->Get(_i);
            }
        }
    }
    {
        auto _e = outputs();
        if (_e) {
            _o->outputs.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->outputs[_i] = _e->Get(_i);
            }
        }
    }
    {
        auto _e = operators();
        if (_e) {
            _o->operators.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->operators[_i] = std::unique_ptr<tflite::OperatorT>(_e->Get(_i)->UnPack(_resolver));
            }
        }
    }
    {
        auto _e = name();
        if (_e)
            _o->name = _e->str();
    }
}

inline flatbuffers::Offset<SubGraph> SubGraph::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o,
                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateSubGraph(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SubGraph> CreateSubGraph(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o,
                                                    const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const SubGraphT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _tensors = _o->tensors.size()
                        ? _fbb.CreateVector<flatbuffers::Offset<tflite::Tensor>>(
                              _o->tensors.size(),
                              [](size_t i, _VectorArgs *__va) {
                                  return CreateTensor(*__va->__fbb, __va->__o->tensors[i].get(), __va->__rehasher);
                              },
                              &_va)
                        : 0;
    auto _inputs    = _o->inputs.size() ? _fbb.CreateVector(_o->inputs) : 0;
    auto _outputs   = _o->outputs.size() ? _fbb.CreateVector(_o->outputs) : 0;
    auto _operators = _o->operators.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::Operator>>(
                                                 _o->operators.size(),
                                                 [](size_t i, _VectorArgs *__va) {
                                                     return CreateOperator(*__va->__fbb, __va->__o->operators[i].get(),
                                                                           __va->__rehasher);
                                                 },
                                                 &_va)
                                           : 0;
    auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
    return tflite::CreateSubGraph(_fbb, _tensors, _inputs, _outputs, _operators, _name);
}

inline BufferT *Buffer::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::BufferT> _o = std::unique_ptr<tflite::BufferT>(new BufferT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void Buffer::UnPackTo(BufferT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e = data();
        if (_e) {
            _o->data.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->data[_i] = _e->Get(_i);
            }
        }
    }
}

inline flatbuffers::Offset<Buffer> Buffer::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BufferT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateBuffer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Buffer> CreateBuffer(flatbuffers::FlatBufferBuilder &_fbb, const BufferT *_o,
                                                const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const BufferT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    _fbb.ForceVectorAlignment(_o->data.size(), sizeof(uint8_t), 16);
    auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
    return tflite::CreateBuffer(_fbb, _data);
}

inline ModelT *Model::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
    std::unique_ptr<tflite::ModelT> _o = std::unique_ptr<tflite::ModelT>(new ModelT());
    UnPackTo(_o.get(), _resolver);
    return _o.release();
}

inline void Model::UnPackTo(ModelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
    (void)_o;
    (void)_resolver;
    {
        auto _e     = version();
        _o->version = _e;
    }
    {
        auto _e = operator_codes();
        if (_e) {
            _o->operator_codes.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->operator_codes[_i] = std::unique_ptr<tflite::OperatorCodeT>(_e->Get(_i)->UnPack(_resolver));
            }
        }
    }
    {
        auto _e = subgraphs();
        if (_e) {
            _o->subgraphs.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->subgraphs[_i] = std::unique_ptr<tflite::SubGraphT>(_e->Get(_i)->UnPack(_resolver));
            }
        }
    }
    {
        auto _e = description();
        if (_e)
            _o->description = _e->str();
    }
    {
        auto _e = buffers();
        if (_e) {
            _o->buffers.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->buffers[_i] = std::unique_ptr<tflite::BufferT>(_e->Get(_i)->UnPack(_resolver));
            }
        }
    }
    {
        auto _e = metadata_buffer();
        if (_e) {
            _o->metadata_buffer.resize(_e->size());
            for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
                _o->metadata_buffer[_i] = _e->Get(_i);
            }
        }
    }
}

inline flatbuffers::Offset<Model> Model::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o,
                                              const flatbuffers::rehasher_function_t *_rehasher) {
    return CreateModel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Model> CreateModel(flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o,
                                              const flatbuffers::rehasher_function_t *_rehasher) {
    (void)_rehasher;
    (void)_o;
    struct _VectorArgs {
        flatbuffers::FlatBufferBuilder *__fbb;
        const ModelT *__o;
        const flatbuffers::rehasher_function_t *__rehasher;
    } _va = {&_fbb, _o, _rehasher};
    (void)_va;
    auto _version = _o->version;
    auto _operator_codes =
        _o->operator_codes.size()
            ? _fbb.CreateVector<flatbuffers::Offset<tflite::OperatorCode>>(
                  _o->operator_codes.size(),
                  [](size_t i, _VectorArgs *__va) {
                      return CreateOperatorCode(*__va->__fbb, __va->__o->operator_codes[i].get(), __va->__rehasher);
                  },
                  &_va)
            : 0;
    auto _subgraphs = _o->subgraphs.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::SubGraph>>(
                                                 _o->subgraphs.size(),
                                                 [](size_t i, _VectorArgs *__va) {
                                                     return CreateSubGraph(*__va->__fbb, __va->__o->subgraphs[i].get(),
                                                                           __va->__rehasher);
                                                 },
                                                 &_va)
                                           : 0;
    auto _description = _o->description.empty() ? 0 : _fbb.CreateString(_o->description);
    auto _buffers     = _o->buffers.size()
                        ? _fbb.CreateVector<flatbuffers::Offset<tflite::Buffer>>(
                              _o->buffers.size(),
                              [](size_t i, _VectorArgs *__va) {
                                  return CreateBuffer(*__va->__fbb, __va->__o->buffers[i].get(), __va->__rehasher);
                              },
                              &_va)
                        : 0;
    auto _metadata_buffer = _o->metadata_buffer.size() ? _fbb.CreateVector(_o->metadata_buffer) : 0;
    return tflite::CreateModel(_fbb, _version, _operator_codes, _subgraphs, _description, _buffers, _metadata_buffer);
}

inline bool VerifyBuiltinOptions(flatbuffers::Verifier &verifier, const void *obj, BuiltinOptions type) {
    switch (type) {
        case BuiltinOptions_NONE: {
            return true;
        }
        case BuiltinOptions_Conv2DOptions: {
            auto ptr = reinterpret_cast<const tflite::Conv2DOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_DepthwiseConv2DOptions: {
            auto ptr = reinterpret_cast<const tflite::DepthwiseConv2DOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_ConcatEmbeddingsOptions: {
            auto ptr = reinterpret_cast<const tflite::ConcatEmbeddingsOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_LSHProjectionOptions: {
            auto ptr = reinterpret_cast<const tflite::LSHProjectionOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_Pool2DOptions: {
            auto ptr = reinterpret_cast<const tflite::Pool2DOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SVDFOptions: {
            auto ptr = reinterpret_cast<const tflite::SVDFOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_RNNOptions: {
            auto ptr = reinterpret_cast<const tflite::RNNOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_FullyConnectedOptions: {
            auto ptr = reinterpret_cast<const tflite::FullyConnectedOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SoftmaxOptions: {
            auto ptr = reinterpret_cast<const tflite::SoftmaxOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_ConcatenationOptions: {
            auto ptr = reinterpret_cast<const tflite::ConcatenationOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_AddOptions: {
            auto ptr = reinterpret_cast<const tflite::AddOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_L2NormOptions: {
            auto ptr = reinterpret_cast<const tflite::L2NormOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_LocalResponseNormalizationOptions: {
            auto ptr = reinterpret_cast<const tflite::LocalResponseNormalizationOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_LSTMOptions: {
            auto ptr = reinterpret_cast<const tflite::LSTMOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_ResizeBilinearOptions: {
            auto ptr = reinterpret_cast<const tflite::ResizeBilinearOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_CallOptions: {
            auto ptr = reinterpret_cast<const tflite::CallOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_ReshapeOptions: {
            auto ptr = reinterpret_cast<const tflite::ReshapeOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SkipGramOptions: {
            auto ptr = reinterpret_cast<const tflite::SkipGramOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SpaceToDepthOptions: {
            auto ptr = reinterpret_cast<const tflite::SpaceToDepthOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_EmbeddingLookupSparseOptions: {
            auto ptr = reinterpret_cast<const tflite::EmbeddingLookupSparseOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_MulOptions: {
            auto ptr = reinterpret_cast<const tflite::MulOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_PadOptions: {
            auto ptr = reinterpret_cast<const tflite::PadOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_GatherOptions: {
            auto ptr = reinterpret_cast<const tflite::GatherOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_BatchToSpaceNDOptions: {
            auto ptr = reinterpret_cast<const tflite::BatchToSpaceNDOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SpaceToBatchNDOptions: {
            auto ptr = reinterpret_cast<const tflite::SpaceToBatchNDOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_TransposeOptions: {
            auto ptr = reinterpret_cast<const tflite::TransposeOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_ReducerOptions: {
            auto ptr = reinterpret_cast<const tflite::ReducerOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SubOptions: {
            auto ptr = reinterpret_cast<const tflite::SubOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_DivOptions: {
            auto ptr = reinterpret_cast<const tflite::DivOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SqueezeOptions: {
            auto ptr = reinterpret_cast<const tflite::SqueezeOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SequenceRNNOptions: {
            auto ptr = reinterpret_cast<const tflite::SequenceRNNOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_StridedSliceOptions: {
            auto ptr = reinterpret_cast<const tflite::StridedSliceOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_ExpOptions: {
            auto ptr = reinterpret_cast<const tflite::ExpOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_TopKV2Options: {
            auto ptr = reinterpret_cast<const tflite::TopKV2Options *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SplitOptions: {
            auto ptr = reinterpret_cast<const tflite::SplitOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_LogSoftmaxOptions: {
            auto ptr = reinterpret_cast<const tflite::LogSoftmaxOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_CastOptions: {
            auto ptr = reinterpret_cast<const tflite::CastOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_DequantizeOptions: {
            auto ptr = reinterpret_cast<const tflite::DequantizeOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_MaximumMinimumOptions: {
            auto ptr = reinterpret_cast<const tflite::MaximumMinimumOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_ArgMaxOptions: {
            auto ptr = reinterpret_cast<const tflite::ArgMaxOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_LessOptions: {
            auto ptr = reinterpret_cast<const tflite::LessOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_NegOptions: {
            auto ptr = reinterpret_cast<const tflite::NegOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_PadV2Options: {
            auto ptr = reinterpret_cast<const tflite::PadV2Options *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_GreaterOptions: {
            auto ptr = reinterpret_cast<const tflite::GreaterOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_GreaterEqualOptions: {
            auto ptr = reinterpret_cast<const tflite::GreaterEqualOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_LessEqualOptions: {
            auto ptr = reinterpret_cast<const tflite::LessEqualOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SelectOptions: {
            auto ptr = reinterpret_cast<const tflite::SelectOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SliceOptions: {
            auto ptr = reinterpret_cast<const tflite::SliceOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_TransposeConvOptions: {
            auto ptr = reinterpret_cast<const tflite::TransposeConvOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SparseToDenseOptions: {
            auto ptr = reinterpret_cast<const tflite::SparseToDenseOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_TileOptions: {
            auto ptr = reinterpret_cast<const tflite::TileOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_ExpandDimsOptions: {
            auto ptr = reinterpret_cast<const tflite::ExpandDimsOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_EqualOptions: {
            auto ptr = reinterpret_cast<const tflite::EqualOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_NotEqualOptions: {
            auto ptr = reinterpret_cast<const tflite::NotEqualOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_ShapeOptions: {
            auto ptr = reinterpret_cast<const tflite::ShapeOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_PowOptions: {
            auto ptr = reinterpret_cast<const tflite::PowOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_ArgMinOptions: {
            auto ptr = reinterpret_cast<const tflite::ArgMinOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_FakeQuantOptions: {
            auto ptr = reinterpret_cast<const tflite::FakeQuantOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_PackOptions: {
            auto ptr = reinterpret_cast<const tflite::PackOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_LogicalOrOptions: {
            auto ptr = reinterpret_cast<const tflite::LogicalOrOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_OneHotOptions: {
            auto ptr = reinterpret_cast<const tflite::OneHotOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_LogicalAndOptions: {
            auto ptr = reinterpret_cast<const tflite::LogicalAndOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_LogicalNotOptions: {
            auto ptr = reinterpret_cast<const tflite::LogicalNotOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_UnpackOptions: {
            auto ptr = reinterpret_cast<const tflite::UnpackOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_FloorDivOptions: {
            auto ptr = reinterpret_cast<const tflite::FloorDivOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_SquareOptions: {
            auto ptr = reinterpret_cast<const tflite::SquareOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_ZerosLikeOptions: {
            auto ptr = reinterpret_cast<const tflite::ZerosLikeOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case BuiltinOptions_FillOptions: {
            auto ptr = reinterpret_cast<const tflite::FillOptions *>(obj);
            return verifier.VerifyTable(ptr);
        }
        default:
            return true;
    }
}

inline bool VerifyBuiltinOptionsVector(flatbuffers::Verifier &verifier,
                                       const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                                       const flatbuffers::Vector<uint8_t> *types) {
    if (!values || !types)
        return !values && !types;
    if (values->size() != types->size())
        return false;
    for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
        if (!VerifyBuiltinOptions(verifier, values->Get(i), types->GetEnum<BuiltinOptions>(i))) {
            return false;
        }
    }
    return true;
}

inline void *BuiltinOptionsUnion::UnPack(const void *obj, BuiltinOptions type,
                                         const flatbuffers::resolver_function_t *resolver) {
    switch (type) {
        case BuiltinOptions_Conv2DOptions: {
            auto ptr = reinterpret_cast<const tflite::Conv2DOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_DepthwiseConv2DOptions: {
            auto ptr = reinterpret_cast<const tflite::DepthwiseConv2DOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_ConcatEmbeddingsOptions: {
            auto ptr = reinterpret_cast<const tflite::ConcatEmbeddingsOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_LSHProjectionOptions: {
            auto ptr = reinterpret_cast<const tflite::LSHProjectionOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_Pool2DOptions: {
            auto ptr = reinterpret_cast<const tflite::Pool2DOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SVDFOptions: {
            auto ptr = reinterpret_cast<const tflite::SVDFOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_RNNOptions: {
            auto ptr = reinterpret_cast<const tflite::RNNOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_FullyConnectedOptions: {
            auto ptr = reinterpret_cast<const tflite::FullyConnectedOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SoftmaxOptions: {
            auto ptr = reinterpret_cast<const tflite::SoftmaxOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_ConcatenationOptions: {
            auto ptr = reinterpret_cast<const tflite::ConcatenationOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_AddOptions: {
            auto ptr = reinterpret_cast<const tflite::AddOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_L2NormOptions: {
            auto ptr = reinterpret_cast<const tflite::L2NormOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_LocalResponseNormalizationOptions: {
            auto ptr = reinterpret_cast<const tflite::LocalResponseNormalizationOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_LSTMOptions: {
            auto ptr = reinterpret_cast<const tflite::LSTMOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_ResizeBilinearOptions: {
            auto ptr = reinterpret_cast<const tflite::ResizeBilinearOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_CallOptions: {
            auto ptr = reinterpret_cast<const tflite::CallOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_ReshapeOptions: {
            auto ptr = reinterpret_cast<const tflite::ReshapeOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SkipGramOptions: {
            auto ptr = reinterpret_cast<const tflite::SkipGramOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SpaceToDepthOptions: {
            auto ptr = reinterpret_cast<const tflite::SpaceToDepthOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_EmbeddingLookupSparseOptions: {
            auto ptr = reinterpret_cast<const tflite::EmbeddingLookupSparseOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_MulOptions: {
            auto ptr = reinterpret_cast<const tflite::MulOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_PadOptions: {
            auto ptr = reinterpret_cast<const tflite::PadOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_GatherOptions: {
            auto ptr = reinterpret_cast<const tflite::GatherOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_BatchToSpaceNDOptions: {
            auto ptr = reinterpret_cast<const tflite::BatchToSpaceNDOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SpaceToBatchNDOptions: {
            auto ptr = reinterpret_cast<const tflite::SpaceToBatchNDOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_TransposeOptions: {
            auto ptr = reinterpret_cast<const tflite::TransposeOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_ReducerOptions: {
            auto ptr = reinterpret_cast<const tflite::ReducerOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SubOptions: {
            auto ptr = reinterpret_cast<const tflite::SubOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_DivOptions: {
            auto ptr = reinterpret_cast<const tflite::DivOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SqueezeOptions: {
            auto ptr = reinterpret_cast<const tflite::SqueezeOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SequenceRNNOptions: {
            auto ptr = reinterpret_cast<const tflite::SequenceRNNOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_StridedSliceOptions: {
            auto ptr = reinterpret_cast<const tflite::StridedSliceOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_ExpOptions: {
            auto ptr = reinterpret_cast<const tflite::ExpOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_TopKV2Options: {
            auto ptr = reinterpret_cast<const tflite::TopKV2Options *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SplitOptions: {
            auto ptr = reinterpret_cast<const tflite::SplitOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_LogSoftmaxOptions: {
            auto ptr = reinterpret_cast<const tflite::LogSoftmaxOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_CastOptions: {
            auto ptr = reinterpret_cast<const tflite::CastOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_DequantizeOptions: {
            auto ptr = reinterpret_cast<const tflite::DequantizeOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_MaximumMinimumOptions: {
            auto ptr = reinterpret_cast<const tflite::MaximumMinimumOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_ArgMaxOptions: {
            auto ptr = reinterpret_cast<const tflite::ArgMaxOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_LessOptions: {
            auto ptr = reinterpret_cast<const tflite::LessOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_NegOptions: {
            auto ptr = reinterpret_cast<const tflite::NegOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_PadV2Options: {
            auto ptr = reinterpret_cast<const tflite::PadV2Options *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_GreaterOptions: {
            auto ptr = reinterpret_cast<const tflite::GreaterOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_GreaterEqualOptions: {
            auto ptr = reinterpret_cast<const tflite::GreaterEqualOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_LessEqualOptions: {
            auto ptr = reinterpret_cast<const tflite::LessEqualOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SelectOptions: {
            auto ptr = reinterpret_cast<const tflite::SelectOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SliceOptions: {
            auto ptr = reinterpret_cast<const tflite::SliceOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_TransposeConvOptions: {
            auto ptr = reinterpret_cast<const tflite::TransposeConvOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SparseToDenseOptions: {
            auto ptr = reinterpret_cast<const tflite::SparseToDenseOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_TileOptions: {
            auto ptr = reinterpret_cast<const tflite::TileOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_ExpandDimsOptions: {
            auto ptr = reinterpret_cast<const tflite::ExpandDimsOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_EqualOptions: {
            auto ptr = reinterpret_cast<const tflite::EqualOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_NotEqualOptions: {
            auto ptr = reinterpret_cast<const tflite::NotEqualOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_ShapeOptions: {
            auto ptr = reinterpret_cast<const tflite::ShapeOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_PowOptions: {
            auto ptr = reinterpret_cast<const tflite::PowOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_ArgMinOptions: {
            auto ptr = reinterpret_cast<const tflite::ArgMinOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_FakeQuantOptions: {
            auto ptr = reinterpret_cast<const tflite::FakeQuantOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_PackOptions: {
            auto ptr = reinterpret_cast<const tflite::PackOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_LogicalOrOptions: {
            auto ptr = reinterpret_cast<const tflite::LogicalOrOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_OneHotOptions: {
            auto ptr = reinterpret_cast<const tflite::OneHotOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_LogicalAndOptions: {
            auto ptr = reinterpret_cast<const tflite::LogicalAndOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_LogicalNotOptions: {
            auto ptr = reinterpret_cast<const tflite::LogicalNotOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_UnpackOptions: {
            auto ptr = reinterpret_cast<const tflite::UnpackOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_FloorDivOptions: {
            auto ptr = reinterpret_cast<const tflite::FloorDivOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_SquareOptions: {
            auto ptr = reinterpret_cast<const tflite::SquareOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_ZerosLikeOptions: {
            auto ptr = reinterpret_cast<const tflite::ZerosLikeOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        case BuiltinOptions_FillOptions: {
            auto ptr = reinterpret_cast<const tflite::FillOptions *>(obj);
            return ptr->UnPack(resolver);
        }
        default:
            return nullptr;
    }
}

inline flatbuffers::Offset<void> BuiltinOptionsUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb,
                                                           const flatbuffers::rehasher_function_t *_rehasher) const {
    switch (type) {
        case BuiltinOptions_Conv2DOptions: {
            auto ptr = reinterpret_cast<const tflite::Conv2DOptionsT *>(value);
            return CreateConv2DOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_DepthwiseConv2DOptions: {
            auto ptr = reinterpret_cast<const tflite::DepthwiseConv2DOptionsT *>(value);
            return CreateDepthwiseConv2DOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_ConcatEmbeddingsOptions: {
            auto ptr = reinterpret_cast<const tflite::ConcatEmbeddingsOptionsT *>(value);
            return CreateConcatEmbeddingsOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_LSHProjectionOptions: {
            auto ptr = reinterpret_cast<const tflite::LSHProjectionOptionsT *>(value);
            return CreateLSHProjectionOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_Pool2DOptions: {
            auto ptr = reinterpret_cast<const tflite::Pool2DOptionsT *>(value);
            return CreatePool2DOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SVDFOptions: {
            auto ptr = reinterpret_cast<const tflite::SVDFOptionsT *>(value);
            return CreateSVDFOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_RNNOptions: {
            auto ptr = reinterpret_cast<const tflite::RNNOptionsT *>(value);
            return CreateRNNOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_FullyConnectedOptions: {
            auto ptr = reinterpret_cast<const tflite::FullyConnectedOptionsT *>(value);
            return CreateFullyConnectedOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SoftmaxOptions: {
            auto ptr = reinterpret_cast<const tflite::SoftmaxOptionsT *>(value);
            return CreateSoftmaxOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_ConcatenationOptions: {
            auto ptr = reinterpret_cast<const tflite::ConcatenationOptionsT *>(value);
            return CreateConcatenationOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_AddOptions: {
            auto ptr = reinterpret_cast<const tflite::AddOptionsT *>(value);
            return CreateAddOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_L2NormOptions: {
            auto ptr = reinterpret_cast<const tflite::L2NormOptionsT *>(value);
            return CreateL2NormOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_LocalResponseNormalizationOptions: {
            auto ptr = reinterpret_cast<const tflite::LocalResponseNormalizationOptionsT *>(value);
            return CreateLocalResponseNormalizationOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_LSTMOptions: {
            auto ptr = reinterpret_cast<const tflite::LSTMOptionsT *>(value);
            return CreateLSTMOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_ResizeBilinearOptions: {
            auto ptr = reinterpret_cast<const tflite::ResizeBilinearOptionsT *>(value);
            return CreateResizeBilinearOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_CallOptions: {
            auto ptr = reinterpret_cast<const tflite::CallOptionsT *>(value);
            return CreateCallOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_ReshapeOptions: {
            auto ptr = reinterpret_cast<const tflite::ReshapeOptionsT *>(value);
            return CreateReshapeOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SkipGramOptions: {
            auto ptr = reinterpret_cast<const tflite::SkipGramOptionsT *>(value);
            return CreateSkipGramOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SpaceToDepthOptions: {
            auto ptr = reinterpret_cast<const tflite::SpaceToDepthOptionsT *>(value);
            return CreateSpaceToDepthOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_EmbeddingLookupSparseOptions: {
            auto ptr = reinterpret_cast<const tflite::EmbeddingLookupSparseOptionsT *>(value);
            return CreateEmbeddingLookupSparseOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_MulOptions: {
            auto ptr = reinterpret_cast<const tflite::MulOptionsT *>(value);
            return CreateMulOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_PadOptions: {
            auto ptr = reinterpret_cast<const tflite::PadOptionsT *>(value);
            return CreatePadOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_GatherOptions: {
            auto ptr = reinterpret_cast<const tflite::GatherOptionsT *>(value);
            return CreateGatherOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_BatchToSpaceNDOptions: {
            auto ptr = reinterpret_cast<const tflite::BatchToSpaceNDOptionsT *>(value);
            return CreateBatchToSpaceNDOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SpaceToBatchNDOptions: {
            auto ptr = reinterpret_cast<const tflite::SpaceToBatchNDOptionsT *>(value);
            return CreateSpaceToBatchNDOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_TransposeOptions: {
            auto ptr = reinterpret_cast<const tflite::TransposeOptionsT *>(value);
            return CreateTransposeOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_ReducerOptions: {
            auto ptr = reinterpret_cast<const tflite::ReducerOptionsT *>(value);
            return CreateReducerOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SubOptions: {
            auto ptr = reinterpret_cast<const tflite::SubOptionsT *>(value);
            return CreateSubOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_DivOptions: {
            auto ptr = reinterpret_cast<const tflite::DivOptionsT *>(value);
            return CreateDivOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SqueezeOptions: {
            auto ptr = reinterpret_cast<const tflite::SqueezeOptionsT *>(value);
            return CreateSqueezeOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SequenceRNNOptions: {
            auto ptr = reinterpret_cast<const tflite::SequenceRNNOptionsT *>(value);
            return CreateSequenceRNNOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_StridedSliceOptions: {
            auto ptr = reinterpret_cast<const tflite::StridedSliceOptionsT *>(value);
            return CreateStridedSliceOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_ExpOptions: {
            auto ptr = reinterpret_cast<const tflite::ExpOptionsT *>(value);
            return CreateExpOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_TopKV2Options: {
            auto ptr = reinterpret_cast<const tflite::TopKV2OptionsT *>(value);
            return CreateTopKV2Options(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SplitOptions: {
            auto ptr = reinterpret_cast<const tflite::SplitOptionsT *>(value);
            return CreateSplitOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_LogSoftmaxOptions: {
            auto ptr = reinterpret_cast<const tflite::LogSoftmaxOptionsT *>(value);
            return CreateLogSoftmaxOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_CastOptions: {
            auto ptr = reinterpret_cast<const tflite::CastOptionsT *>(value);
            return CreateCastOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_DequantizeOptions: {
            auto ptr = reinterpret_cast<const tflite::DequantizeOptionsT *>(value);
            return CreateDequantizeOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_MaximumMinimumOptions: {
            auto ptr = reinterpret_cast<const tflite::MaximumMinimumOptionsT *>(value);
            return CreateMaximumMinimumOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_ArgMaxOptions: {
            auto ptr = reinterpret_cast<const tflite::ArgMaxOptionsT *>(value);
            return CreateArgMaxOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_LessOptions: {
            auto ptr = reinterpret_cast<const tflite::LessOptionsT *>(value);
            return CreateLessOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_NegOptions: {
            auto ptr = reinterpret_cast<const tflite::NegOptionsT *>(value);
            return CreateNegOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_PadV2Options: {
            auto ptr = reinterpret_cast<const tflite::PadV2OptionsT *>(value);
            return CreatePadV2Options(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_GreaterOptions: {
            auto ptr = reinterpret_cast<const tflite::GreaterOptionsT *>(value);
            return CreateGreaterOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_GreaterEqualOptions: {
            auto ptr = reinterpret_cast<const tflite::GreaterEqualOptionsT *>(value);
            return CreateGreaterEqualOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_LessEqualOptions: {
            auto ptr = reinterpret_cast<const tflite::LessEqualOptionsT *>(value);
            return CreateLessEqualOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SelectOptions: {
            auto ptr = reinterpret_cast<const tflite::SelectOptionsT *>(value);
            return CreateSelectOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SliceOptions: {
            auto ptr = reinterpret_cast<const tflite::SliceOptionsT *>(value);
            return CreateSliceOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_TransposeConvOptions: {
            auto ptr = reinterpret_cast<const tflite::TransposeConvOptionsT *>(value);
            return CreateTransposeConvOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SparseToDenseOptions: {
            auto ptr = reinterpret_cast<const tflite::SparseToDenseOptionsT *>(value);
            return CreateSparseToDenseOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_TileOptions: {
            auto ptr = reinterpret_cast<const tflite::TileOptionsT *>(value);
            return CreateTileOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_ExpandDimsOptions: {
            auto ptr = reinterpret_cast<const tflite::ExpandDimsOptionsT *>(value);
            return CreateExpandDimsOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_EqualOptions: {
            auto ptr = reinterpret_cast<const tflite::EqualOptionsT *>(value);
            return CreateEqualOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_NotEqualOptions: {
            auto ptr = reinterpret_cast<const tflite::NotEqualOptionsT *>(value);
            return CreateNotEqualOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_ShapeOptions: {
            auto ptr = reinterpret_cast<const tflite::ShapeOptionsT *>(value);
            return CreateShapeOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_PowOptions: {
            auto ptr = reinterpret_cast<const tflite::PowOptionsT *>(value);
            return CreatePowOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_ArgMinOptions: {
            auto ptr = reinterpret_cast<const tflite::ArgMinOptionsT *>(value);
            return CreateArgMinOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_FakeQuantOptions: {
            auto ptr = reinterpret_cast<const tflite::FakeQuantOptionsT *>(value);
            return CreateFakeQuantOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_PackOptions: {
            auto ptr = reinterpret_cast<const tflite::PackOptionsT *>(value);
            return CreatePackOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_LogicalOrOptions: {
            auto ptr = reinterpret_cast<const tflite::LogicalOrOptionsT *>(value);
            return CreateLogicalOrOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_OneHotOptions: {
            auto ptr = reinterpret_cast<const tflite::OneHotOptionsT *>(value);
            return CreateOneHotOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_LogicalAndOptions: {
            auto ptr = reinterpret_cast<const tflite::LogicalAndOptionsT *>(value);
            return CreateLogicalAndOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_LogicalNotOptions: {
            auto ptr = reinterpret_cast<const tflite::LogicalNotOptionsT *>(value);
            return CreateLogicalNotOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_UnpackOptions: {
            auto ptr = reinterpret_cast<const tflite::UnpackOptionsT *>(value);
            return CreateUnpackOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_FloorDivOptions: {
            auto ptr = reinterpret_cast<const tflite::FloorDivOptionsT *>(value);
            return CreateFloorDivOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_SquareOptions: {
            auto ptr = reinterpret_cast<const tflite::SquareOptionsT *>(value);
            return CreateSquareOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_ZerosLikeOptions: {
            auto ptr = reinterpret_cast<const tflite::ZerosLikeOptionsT *>(value);
            return CreateZerosLikeOptions(_fbb, ptr, _rehasher).Union();
        }
        case BuiltinOptions_FillOptions: {
            auto ptr = reinterpret_cast<const tflite::FillOptionsT *>(value);
            return CreateFillOptions(_fbb, ptr, _rehasher).Union();
        }
        default:
            return 0;
    }
}

inline BuiltinOptionsUnion::BuiltinOptionsUnion(const BuiltinOptionsUnion &u) : type(u.type), value(nullptr) {
    switch (type) {
        case BuiltinOptions_Conv2DOptions: {
            value = new tflite::Conv2DOptionsT(*reinterpret_cast<tflite::Conv2DOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_DepthwiseConv2DOptions: {
            value = new tflite::DepthwiseConv2DOptionsT(*reinterpret_cast<tflite::DepthwiseConv2DOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_ConcatEmbeddingsOptions: {
            value =
                new tflite::ConcatEmbeddingsOptionsT(*reinterpret_cast<tflite::ConcatEmbeddingsOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_LSHProjectionOptions: {
            value = new tflite::LSHProjectionOptionsT(*reinterpret_cast<tflite::LSHProjectionOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_Pool2DOptions: {
            value = new tflite::Pool2DOptionsT(*reinterpret_cast<tflite::Pool2DOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SVDFOptions: {
            value = new tflite::SVDFOptionsT(*reinterpret_cast<tflite::SVDFOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_RNNOptions: {
            value = new tflite::RNNOptionsT(*reinterpret_cast<tflite::RNNOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_FullyConnectedOptions: {
            value = new tflite::FullyConnectedOptionsT(*reinterpret_cast<tflite::FullyConnectedOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SoftmaxOptions: {
            value = new tflite::SoftmaxOptionsT(*reinterpret_cast<tflite::SoftmaxOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_ConcatenationOptions: {
            value = new tflite::ConcatenationOptionsT(*reinterpret_cast<tflite::ConcatenationOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_AddOptions: {
            value = new tflite::AddOptionsT(*reinterpret_cast<tflite::AddOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_L2NormOptions: {
            value = new tflite::L2NormOptionsT(*reinterpret_cast<tflite::L2NormOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_LocalResponseNormalizationOptions: {
            value = new tflite::LocalResponseNormalizationOptionsT(
                *reinterpret_cast<tflite::LocalResponseNormalizationOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_LSTMOptions: {
            value = new tflite::LSTMOptionsT(*reinterpret_cast<tflite::LSTMOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_ResizeBilinearOptions: {
            value = new tflite::ResizeBilinearOptionsT(*reinterpret_cast<tflite::ResizeBilinearOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_CallOptions: {
            value = new tflite::CallOptionsT(*reinterpret_cast<tflite::CallOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_ReshapeOptions: {
            value = new tflite::ReshapeOptionsT(*reinterpret_cast<tflite::ReshapeOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SkipGramOptions: {
            value = new tflite::SkipGramOptionsT(*reinterpret_cast<tflite::SkipGramOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SpaceToDepthOptions: {
            value = new tflite::SpaceToDepthOptionsT(*reinterpret_cast<tflite::SpaceToDepthOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_EmbeddingLookupSparseOptions: {
            value = new tflite::EmbeddingLookupSparseOptionsT(
                *reinterpret_cast<tflite::EmbeddingLookupSparseOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_MulOptions: {
            value = new tflite::MulOptionsT(*reinterpret_cast<tflite::MulOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_PadOptions: {
            value = new tflite::PadOptionsT(*reinterpret_cast<tflite::PadOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_GatherOptions: {
            value = new tflite::GatherOptionsT(*reinterpret_cast<tflite::GatherOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_BatchToSpaceNDOptions: {
            value = new tflite::BatchToSpaceNDOptionsT(*reinterpret_cast<tflite::BatchToSpaceNDOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SpaceToBatchNDOptions: {
            value = new tflite::SpaceToBatchNDOptionsT(*reinterpret_cast<tflite::SpaceToBatchNDOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_TransposeOptions: {
            value = new tflite::TransposeOptionsT(*reinterpret_cast<tflite::TransposeOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_ReducerOptions: {
            value = new tflite::ReducerOptionsT(*reinterpret_cast<tflite::ReducerOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SubOptions: {
            value = new tflite::SubOptionsT(*reinterpret_cast<tflite::SubOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_DivOptions: {
            value = new tflite::DivOptionsT(*reinterpret_cast<tflite::DivOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SqueezeOptions: {
            value = new tflite::SqueezeOptionsT(*reinterpret_cast<tflite::SqueezeOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SequenceRNNOptions: {
            value = new tflite::SequenceRNNOptionsT(*reinterpret_cast<tflite::SequenceRNNOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_StridedSliceOptions: {
            value = new tflite::StridedSliceOptionsT(*reinterpret_cast<tflite::StridedSliceOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_ExpOptions: {
            value = new tflite::ExpOptionsT(*reinterpret_cast<tflite::ExpOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_TopKV2Options: {
            value = new tflite::TopKV2OptionsT(*reinterpret_cast<tflite::TopKV2OptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SplitOptions: {
            value = new tflite::SplitOptionsT(*reinterpret_cast<tflite::SplitOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_LogSoftmaxOptions: {
            value = new tflite::LogSoftmaxOptionsT(*reinterpret_cast<tflite::LogSoftmaxOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_CastOptions: {
            value = new tflite::CastOptionsT(*reinterpret_cast<tflite::CastOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_DequantizeOptions: {
            value = new tflite::DequantizeOptionsT(*reinterpret_cast<tflite::DequantizeOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_MaximumMinimumOptions: {
            value = new tflite::MaximumMinimumOptionsT(*reinterpret_cast<tflite::MaximumMinimumOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_ArgMaxOptions: {
            value = new tflite::ArgMaxOptionsT(*reinterpret_cast<tflite::ArgMaxOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_LessOptions: {
            value = new tflite::LessOptionsT(*reinterpret_cast<tflite::LessOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_NegOptions: {
            value = new tflite::NegOptionsT(*reinterpret_cast<tflite::NegOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_PadV2Options: {
            value = new tflite::PadV2OptionsT(*reinterpret_cast<tflite::PadV2OptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_GreaterOptions: {
            value = new tflite::GreaterOptionsT(*reinterpret_cast<tflite::GreaterOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_GreaterEqualOptions: {
            value = new tflite::GreaterEqualOptionsT(*reinterpret_cast<tflite::GreaterEqualOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_LessEqualOptions: {
            value = new tflite::LessEqualOptionsT(*reinterpret_cast<tflite::LessEqualOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SelectOptions: {
            value = new tflite::SelectOptionsT(*reinterpret_cast<tflite::SelectOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SliceOptions: {
            value = new tflite::SliceOptionsT(*reinterpret_cast<tflite::SliceOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_TransposeConvOptions: {
            value = new tflite::TransposeConvOptionsT(*reinterpret_cast<tflite::TransposeConvOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SparseToDenseOptions: {
            value = new tflite::SparseToDenseOptionsT(*reinterpret_cast<tflite::SparseToDenseOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_TileOptions: {
            value = new tflite::TileOptionsT(*reinterpret_cast<tflite::TileOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_ExpandDimsOptions: {
            value = new tflite::ExpandDimsOptionsT(*reinterpret_cast<tflite::ExpandDimsOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_EqualOptions: {
            value = new tflite::EqualOptionsT(*reinterpret_cast<tflite::EqualOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_NotEqualOptions: {
            value = new tflite::NotEqualOptionsT(*reinterpret_cast<tflite::NotEqualOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_ShapeOptions: {
            value = new tflite::ShapeOptionsT(*reinterpret_cast<tflite::ShapeOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_PowOptions: {
            value = new tflite::PowOptionsT(*reinterpret_cast<tflite::PowOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_ArgMinOptions: {
            value = new tflite::ArgMinOptionsT(*reinterpret_cast<tflite::ArgMinOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_FakeQuantOptions: {
            value = new tflite::FakeQuantOptionsT(*reinterpret_cast<tflite::FakeQuantOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_PackOptions: {
            value = new tflite::PackOptionsT(*reinterpret_cast<tflite::PackOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_LogicalOrOptions: {
            value = new tflite::LogicalOrOptionsT(*reinterpret_cast<tflite::LogicalOrOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_OneHotOptions: {
            value = new tflite::OneHotOptionsT(*reinterpret_cast<tflite::OneHotOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_LogicalAndOptions: {
            value = new tflite::LogicalAndOptionsT(*reinterpret_cast<tflite::LogicalAndOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_LogicalNotOptions: {
            value = new tflite::LogicalNotOptionsT(*reinterpret_cast<tflite::LogicalNotOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_UnpackOptions: {
            value = new tflite::UnpackOptionsT(*reinterpret_cast<tflite::UnpackOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_FloorDivOptions: {
            value = new tflite::FloorDivOptionsT(*reinterpret_cast<tflite::FloorDivOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_SquareOptions: {
            value = new tflite::SquareOptionsT(*reinterpret_cast<tflite::SquareOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_ZerosLikeOptions: {
            value = new tflite::ZerosLikeOptionsT(*reinterpret_cast<tflite::ZerosLikeOptionsT *>(u.value));
            break;
        }
        case BuiltinOptions_FillOptions: {
            value = new tflite::FillOptionsT(*reinterpret_cast<tflite::FillOptionsT *>(u.value));
            break;
        }
        default:
            break;
    }
}

inline void BuiltinOptionsUnion::Reset() {
    switch (type) {
        case BuiltinOptions_Conv2DOptions: {
            auto ptr = reinterpret_cast<tflite::Conv2DOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_DepthwiseConv2DOptions: {
            auto ptr = reinterpret_cast<tflite::DepthwiseConv2DOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_ConcatEmbeddingsOptions: {
            auto ptr = reinterpret_cast<tflite::ConcatEmbeddingsOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_LSHProjectionOptions: {
            auto ptr = reinterpret_cast<tflite::LSHProjectionOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_Pool2DOptions: {
            auto ptr = reinterpret_cast<tflite::Pool2DOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SVDFOptions: {
            auto ptr = reinterpret_cast<tflite::SVDFOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_RNNOptions: {
            auto ptr = reinterpret_cast<tflite::RNNOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_FullyConnectedOptions: {
            auto ptr = reinterpret_cast<tflite::FullyConnectedOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SoftmaxOptions: {
            auto ptr = reinterpret_cast<tflite::SoftmaxOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_ConcatenationOptions: {
            auto ptr = reinterpret_cast<tflite::ConcatenationOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_AddOptions: {
            auto ptr = reinterpret_cast<tflite::AddOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_L2NormOptions: {
            auto ptr = reinterpret_cast<tflite::L2NormOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_LocalResponseNormalizationOptions: {
            auto ptr = reinterpret_cast<tflite::LocalResponseNormalizationOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_LSTMOptions: {
            auto ptr = reinterpret_cast<tflite::LSTMOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_ResizeBilinearOptions: {
            auto ptr = reinterpret_cast<tflite::ResizeBilinearOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_CallOptions: {
            auto ptr = reinterpret_cast<tflite::CallOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_ReshapeOptions: {
            auto ptr = reinterpret_cast<tflite::ReshapeOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SkipGramOptions: {
            auto ptr = reinterpret_cast<tflite::SkipGramOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SpaceToDepthOptions: {
            auto ptr = reinterpret_cast<tflite::SpaceToDepthOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_EmbeddingLookupSparseOptions: {
            auto ptr = reinterpret_cast<tflite::EmbeddingLookupSparseOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_MulOptions: {
            auto ptr = reinterpret_cast<tflite::MulOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_PadOptions: {
            auto ptr = reinterpret_cast<tflite::PadOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_GatherOptions: {
            auto ptr = reinterpret_cast<tflite::GatherOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_BatchToSpaceNDOptions: {
            auto ptr = reinterpret_cast<tflite::BatchToSpaceNDOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SpaceToBatchNDOptions: {
            auto ptr = reinterpret_cast<tflite::SpaceToBatchNDOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_TransposeOptions: {
            auto ptr = reinterpret_cast<tflite::TransposeOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_ReducerOptions: {
            auto ptr = reinterpret_cast<tflite::ReducerOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SubOptions: {
            auto ptr = reinterpret_cast<tflite::SubOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_DivOptions: {
            auto ptr = reinterpret_cast<tflite::DivOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SqueezeOptions: {
            auto ptr = reinterpret_cast<tflite::SqueezeOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SequenceRNNOptions: {
            auto ptr = reinterpret_cast<tflite::SequenceRNNOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_StridedSliceOptions: {
            auto ptr = reinterpret_cast<tflite::StridedSliceOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_ExpOptions: {
            auto ptr = reinterpret_cast<tflite::ExpOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_TopKV2Options: {
            auto ptr = reinterpret_cast<tflite::TopKV2OptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SplitOptions: {
            auto ptr = reinterpret_cast<tflite::SplitOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_LogSoftmaxOptions: {
            auto ptr = reinterpret_cast<tflite::LogSoftmaxOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_CastOptions: {
            auto ptr = reinterpret_cast<tflite::CastOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_DequantizeOptions: {
            auto ptr = reinterpret_cast<tflite::DequantizeOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_MaximumMinimumOptions: {
            auto ptr = reinterpret_cast<tflite::MaximumMinimumOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_ArgMaxOptions: {
            auto ptr = reinterpret_cast<tflite::ArgMaxOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_LessOptions: {
            auto ptr = reinterpret_cast<tflite::LessOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_NegOptions: {
            auto ptr = reinterpret_cast<tflite::NegOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_PadV2Options: {
            auto ptr = reinterpret_cast<tflite::PadV2OptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_GreaterOptions: {
            auto ptr = reinterpret_cast<tflite::GreaterOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_GreaterEqualOptions: {
            auto ptr = reinterpret_cast<tflite::GreaterEqualOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_LessEqualOptions: {
            auto ptr = reinterpret_cast<tflite::LessEqualOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SelectOptions: {
            auto ptr = reinterpret_cast<tflite::SelectOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SliceOptions: {
            auto ptr = reinterpret_cast<tflite::SliceOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_TransposeConvOptions: {
            auto ptr = reinterpret_cast<tflite::TransposeConvOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SparseToDenseOptions: {
            auto ptr = reinterpret_cast<tflite::SparseToDenseOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_TileOptions: {
            auto ptr = reinterpret_cast<tflite::TileOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_ExpandDimsOptions: {
            auto ptr = reinterpret_cast<tflite::ExpandDimsOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_EqualOptions: {
            auto ptr = reinterpret_cast<tflite::EqualOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_NotEqualOptions: {
            auto ptr = reinterpret_cast<tflite::NotEqualOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_ShapeOptions: {
            auto ptr = reinterpret_cast<tflite::ShapeOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_PowOptions: {
            auto ptr = reinterpret_cast<tflite::PowOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_ArgMinOptions: {
            auto ptr = reinterpret_cast<tflite::ArgMinOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_FakeQuantOptions: {
            auto ptr = reinterpret_cast<tflite::FakeQuantOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_PackOptions: {
            auto ptr = reinterpret_cast<tflite::PackOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_LogicalOrOptions: {
            auto ptr = reinterpret_cast<tflite::LogicalOrOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_OneHotOptions: {
            auto ptr = reinterpret_cast<tflite::OneHotOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_LogicalAndOptions: {
            auto ptr = reinterpret_cast<tflite::LogicalAndOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_LogicalNotOptions: {
            auto ptr = reinterpret_cast<tflite::LogicalNotOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_UnpackOptions: {
            auto ptr = reinterpret_cast<tflite::UnpackOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_FloorDivOptions: {
            auto ptr = reinterpret_cast<tflite::FloorDivOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_SquareOptions: {
            auto ptr = reinterpret_cast<tflite::SquareOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_ZerosLikeOptions: {
            auto ptr = reinterpret_cast<tflite::ZerosLikeOptionsT *>(value);
            delete ptr;
            break;
        }
        case BuiltinOptions_FillOptions: {
            auto ptr = reinterpret_cast<tflite::FillOptionsT *>(value);
            delete ptr;
            break;
        }
        default:
            break;
    }
    value = nullptr;
    type  = BuiltinOptions_NONE;
}

inline const flatbuffers::TypeTable *TensorTypeTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::TensorTypeTypeTable};
    static const char *const names[]                   = {"FLOAT32", "FLOAT16", "INT32", "UINT8",    "INT64",
                                        "STRING",  "BOOL",    "INT16", "COMPLEX64"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_ENUM, 9, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *BuiltinOperatorTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
        {flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::BuiltinOperatorTypeTable};
    static const int64_t values[]    = {0,  1,  2,  3,  4,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
                                     20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,
                                     39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,
                                     58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,
                                     77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94};
    static const char *const names[] = {"ADD",
                                        "AVERAGE_POOL_2D",
                                        "CONCATENATION",
                                        "CONV_2D",
                                        "DEPTHWISE_CONV_2D",
                                        "DEQUANTIZE",
                                        "EMBEDDING_LOOKUP",
                                        "FLOOR",
                                        "FULLY_CONNECTED",
                                        "HASHTABLE_LOOKUP",
                                        "L2_NORMALIZATION",
                                        "L2_POOL_2D",
                                        "LOCAL_RESPONSE_NORMALIZATION",
                                        "LOGISTIC",
                                        "LSH_PROJECTION",
                                        "LSTM",
                                        "MAX_POOL_2D",
                                        "MUL",
                                        "RELU",
                                        "RELU_N1_TO_1",
                                        "RELU6",
                                        "RESHAPE",
                                        "RESIZE_BILINEAR",
                                        "RNN",
                                        "SOFTMAX",
                                        "SPACE_TO_DEPTH",
                                        "SVDF",
                                        "TANH",
                                        "CONCAT_EMBEDDINGS",
                                        "SKIP_GRAM",
                                        "CALL",
                                        "CUSTOM",
                                        "EMBEDDING_LOOKUP_SPARSE",
                                        "PAD",
                                        "UNIDIRECTIONAL_SEQUENCE_RNN",
                                        "GATHER",
                                        "BATCH_TO_SPACE_ND",
                                        "SPACE_TO_BATCH_ND",
                                        "TRANSPOSE",
                                        "MEAN",
                                        "SUB",
                                        "DIV",
                                        "SQUEEZE",
                                        "UNIDIRECTIONAL_SEQUENCE_LSTM",
                                        "STRIDED_SLICE",
                                        "BIDIRECTIONAL_SEQUENCE_RNN",
                                        "EXP",
                                        "TOPK_V2",
                                        "SPLIT",
                                        "LOG_SOFTMAX",
                                        "DELEGATE",
                                        "BIDIRECTIONAL_SEQUENCE_LSTM",
                                        "CAST",
                                        "PRELU",
                                        "MAXIMUM",
                                        "ARG_MAX",
                                        "MINIMUM",
                                        "LESS",
                                        "NEG",
                                        "PADV2",
                                        "GREATER",
                                        "GREATER_EQUAL",
                                        "LESS_EQUAL",
                                        "SELECT",
                                        "SLICE",
                                        "SIN",
                                        "TRANSPOSE_CONV",
                                        "SPARSE_TO_DENSE",
                                        "TILE",
                                        "EXPAND_DIMS",
                                        "EQUAL",
                                        "NOT_EQUAL",
                                        "LOG",
                                        "SUM",
                                        "SQRT",
                                        "RSQRT",
                                        "SHAPE",
                                        "POW",
                                        "ARG_MIN",
                                        "FAKE_QUANT",
                                        "REDUCE_PROD",
                                        "REDUCE_MAX",
                                        "PACK",
                                        "LOGICAL_OR",
                                        "ONE_HOT",
                                        "LOGICAL_AND",
                                        "LOGICAL_NOT",
                                        "UNPACK",
                                        "REDUCE_MIN",
                                        "FLOOR_DIV",
                                        "REDUCE_ANY",
                                        "SQUARE",
                                        "ZEROS_LIKE",
                                        "FILL"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_ENUM, 94, type_codes, type_refs, values, names};
    return &tt;
}

inline const flatbuffers::TypeTable *BuiltinOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {
        {flatbuffers::ET_SEQUENCE, 0, -1}, {flatbuffers::ET_SEQUENCE, 0, 0},  {flatbuffers::ET_SEQUENCE, 0, 1},
        {flatbuffers::ET_SEQUENCE, 0, 2},  {flatbuffers::ET_SEQUENCE, 0, 3},  {flatbuffers::ET_SEQUENCE, 0, 4},
        {flatbuffers::ET_SEQUENCE, 0, 5},  {flatbuffers::ET_SEQUENCE, 0, 6},  {flatbuffers::ET_SEQUENCE, 0, 7},
        {flatbuffers::ET_SEQUENCE, 0, 8},  {flatbuffers::ET_SEQUENCE, 0, 9},  {flatbuffers::ET_SEQUENCE, 0, 10},
        {flatbuffers::ET_SEQUENCE, 0, 11}, {flatbuffers::ET_SEQUENCE, 0, 12}, {flatbuffers::ET_SEQUENCE, 0, 13},
        {flatbuffers::ET_SEQUENCE, 0, 14}, {flatbuffers::ET_SEQUENCE, 0, 15}, {flatbuffers::ET_SEQUENCE, 0, 16},
        {flatbuffers::ET_SEQUENCE, 0, 17}, {flatbuffers::ET_SEQUENCE, 0, 18}, {flatbuffers::ET_SEQUENCE, 0, 19},
        {flatbuffers::ET_SEQUENCE, 0, 20}, {flatbuffers::ET_SEQUENCE, 0, 21}, {flatbuffers::ET_SEQUENCE, 0, 22},
        {flatbuffers::ET_SEQUENCE, 0, 23}, {flatbuffers::ET_SEQUENCE, 0, 24}, {flatbuffers::ET_SEQUENCE, 0, 25},
        {flatbuffers::ET_SEQUENCE, 0, 26}, {flatbuffers::ET_SEQUENCE, 0, 27}, {flatbuffers::ET_SEQUENCE, 0, 28},
        {flatbuffers::ET_SEQUENCE, 0, 29}, {flatbuffers::ET_SEQUENCE, 0, 30}, {flatbuffers::ET_SEQUENCE, 0, 31},
        {flatbuffers::ET_SEQUENCE, 0, 32}, {flatbuffers::ET_SEQUENCE, 0, 33}, {flatbuffers::ET_SEQUENCE, 0, 34},
        {flatbuffers::ET_SEQUENCE, 0, 35}, {flatbuffers::ET_SEQUENCE, 0, 36}, {flatbuffers::ET_SEQUENCE, 0, 37},
        {flatbuffers::ET_SEQUENCE, 0, 38}, {flatbuffers::ET_SEQUENCE, 0, 39}, {flatbuffers::ET_SEQUENCE, 0, 40},
        {flatbuffers::ET_SEQUENCE, 0, 41}, {flatbuffers::ET_SEQUENCE, 0, 42}, {flatbuffers::ET_SEQUENCE, 0, 43},
        {flatbuffers::ET_SEQUENCE, 0, 44}, {flatbuffers::ET_SEQUENCE, 0, 45}, {flatbuffers::ET_SEQUENCE, 0, 46},
        {flatbuffers::ET_SEQUENCE, 0, 47}, {flatbuffers::ET_SEQUENCE, 0, 48}, {flatbuffers::ET_SEQUENCE, 0, 49},
        {flatbuffers::ET_SEQUENCE, 0, 50}, {flatbuffers::ET_SEQUENCE, 0, 51}, {flatbuffers::ET_SEQUENCE, 0, 52},
        {flatbuffers::ET_SEQUENCE, 0, 53}, {flatbuffers::ET_SEQUENCE, 0, 54}, {flatbuffers::ET_SEQUENCE, 0, 55},
        {flatbuffers::ET_SEQUENCE, 0, 56}, {flatbuffers::ET_SEQUENCE, 0, 57}, {flatbuffers::ET_SEQUENCE, 0, 58},
        {flatbuffers::ET_SEQUENCE, 0, 59}, {flatbuffers::ET_SEQUENCE, 0, 60}, {flatbuffers::ET_SEQUENCE, 0, 61},
        {flatbuffers::ET_SEQUENCE, 0, 62}, {flatbuffers::ET_SEQUENCE, 0, 63}, {flatbuffers::ET_SEQUENCE, 0, 64},
        {flatbuffers::ET_SEQUENCE, 0, 65}, {flatbuffers::ET_SEQUENCE, 0, 66}, {flatbuffers::ET_SEQUENCE, 0, 67}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::Conv2DOptionsTypeTable,
                                                          tflite::DepthwiseConv2DOptionsTypeTable,
                                                          tflite::ConcatEmbeddingsOptionsTypeTable,
                                                          tflite::LSHProjectionOptionsTypeTable,
                                                          tflite::Pool2DOptionsTypeTable,
                                                          tflite::SVDFOptionsTypeTable,
                                                          tflite::RNNOptionsTypeTable,
                                                          tflite::FullyConnectedOptionsTypeTable,
                                                          tflite::SoftmaxOptionsTypeTable,
                                                          tflite::ConcatenationOptionsTypeTable,
                                                          tflite::AddOptionsTypeTable,
                                                          tflite::L2NormOptionsTypeTable,
                                                          tflite::LocalResponseNormalizationOptionsTypeTable,
                                                          tflite::LSTMOptionsTypeTable,
                                                          tflite::ResizeBilinearOptionsTypeTable,
                                                          tflite::CallOptionsTypeTable,
                                                          tflite::ReshapeOptionsTypeTable,
                                                          tflite::SkipGramOptionsTypeTable,
                                                          tflite::SpaceToDepthOptionsTypeTable,
                                                          tflite::EmbeddingLookupSparseOptionsTypeTable,
                                                          tflite::MulOptionsTypeTable,
                                                          tflite::PadOptionsTypeTable,
                                                          tflite::GatherOptionsTypeTable,
                                                          tflite::BatchToSpaceNDOptionsTypeTable,
                                                          tflite::SpaceToBatchNDOptionsTypeTable,
                                                          tflite::TransposeOptionsTypeTable,
                                                          tflite::ReducerOptionsTypeTable,
                                                          tflite::SubOptionsTypeTable,
                                                          tflite::DivOptionsTypeTable,
                                                          tflite::SqueezeOptionsTypeTable,
                                                          tflite::SequenceRNNOptionsTypeTable,
                                                          tflite::StridedSliceOptionsTypeTable,
                                                          tflite::ExpOptionsTypeTable,
                                                          tflite::TopKV2OptionsTypeTable,
                                                          tflite::SplitOptionsTypeTable,
                                                          tflite::LogSoftmaxOptionsTypeTable,
                                                          tflite::CastOptionsTypeTable,
                                                          tflite::DequantizeOptionsTypeTable,
                                                          tflite::MaximumMinimumOptionsTypeTable,
                                                          tflite::ArgMaxOptionsTypeTable,
                                                          tflite::LessOptionsTypeTable,
                                                          tflite::NegOptionsTypeTable,
                                                          tflite::PadV2OptionsTypeTable,
                                                          tflite::GreaterOptionsTypeTable,
                                                          tflite::GreaterEqualOptionsTypeTable,
                                                          tflite::LessEqualOptionsTypeTable,
                                                          tflite::SelectOptionsTypeTable,
                                                          tflite::SliceOptionsTypeTable,
                                                          tflite::TransposeConvOptionsTypeTable,
                                                          tflite::SparseToDenseOptionsTypeTable,
                                                          tflite::TileOptionsTypeTable,
                                                          tflite::ExpandDimsOptionsTypeTable,
                                                          tflite::EqualOptionsTypeTable,
                                                          tflite::NotEqualOptionsTypeTable,
                                                          tflite::ShapeOptionsTypeTable,
                                                          tflite::PowOptionsTypeTable,
                                                          tflite::ArgMinOptionsTypeTable,
                                                          tflite::FakeQuantOptionsTypeTable,
                                                          tflite::PackOptionsTypeTable,
                                                          tflite::LogicalOrOptionsTypeTable,
                                                          tflite::OneHotOptionsTypeTable,
                                                          tflite::LogicalAndOptionsTypeTable,
                                                          tflite::LogicalNotOptionsTypeTable,
                                                          tflite::UnpackOptionsTypeTable,
                                                          tflite::FloorDivOptionsTypeTable,
                                                          tflite::SquareOptionsTypeTable,
                                                          tflite::ZerosLikeOptionsTypeTable,
                                                          tflite::FillOptionsTypeTable};
    static const char *const names[]                   = {"NONE",
                                        "Conv2DOptions",
                                        "DepthwiseConv2DOptions",
                                        "ConcatEmbeddingsOptions",
                                        "LSHProjectionOptions",
                                        "Pool2DOptions",
                                        "SVDFOptions",
                                        "RNNOptions",
                                        "FullyConnectedOptions",
                                        "SoftmaxOptions",
                                        "ConcatenationOptions",
                                        "AddOptions",
                                        "L2NormOptions",
                                        "LocalResponseNormalizationOptions",
                                        "LSTMOptions",
                                        "ResizeBilinearOptions",
                                        "CallOptions",
                                        "ReshapeOptions",
                                        "SkipGramOptions",
                                        "SpaceToDepthOptions",
                                        "EmbeddingLookupSparseOptions",
                                        "MulOptions",
                                        "PadOptions",
                                        "GatherOptions",
                                        "BatchToSpaceNDOptions",
                                        "SpaceToBatchNDOptions",
                                        "TransposeOptions",
                                        "ReducerOptions",
                                        "SubOptions",
                                        "DivOptions",
                                        "SqueezeOptions",
                                        "SequenceRNNOptions",
                                        "StridedSliceOptions",
                                        "ExpOptions",
                                        "TopKV2Options",
                                        "SplitOptions",
                                        "LogSoftmaxOptions",
                                        "CastOptions",
                                        "DequantizeOptions",
                                        "MaximumMinimumOptions",
                                        "ArgMaxOptions",
                                        "LessOptions",
                                        "NegOptions",
                                        "PadV2Options",
                                        "GreaterOptions",
                                        "GreaterEqualOptions",
                                        "LessEqualOptions",
                                        "SelectOptions",
                                        "SliceOptions",
                                        "TransposeConvOptions",
                                        "SparseToDenseOptions",
                                        "TileOptions",
                                        "ExpandDimsOptions",
                                        "EqualOptions",
                                        "NotEqualOptions",
                                        "ShapeOptions",
                                        "PowOptions",
                                        "ArgMinOptions",
                                        "FakeQuantOptions",
                                        "PackOptions",
                                        "LogicalOrOptions",
                                        "OneHotOptions",
                                        "LogicalAndOptions",
                                        "LogicalNotOptions",
                                        "UnpackOptions",
                                        "FloorDivOptions",
                                        "SquareOptions",
                                        "ZerosLikeOptions",
                                        "FillOptions"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_UNION, 69, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *PaddingTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::PaddingTypeTable};
    static const char *const names[]                   = {"SAME", "VALID"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *ActivationFunctionTypeTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
                                                       {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
                                                       {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]                   = {"NONE", "RELU", "RELU_N1_TO_1", "RELU6", "TANH", "SIGN_BIT"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_ENUM, 6, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *LSHProjectionTypeTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::LSHProjectionTypeTypeTable};
    static const char *const names[]                   = {"UNKNOWN", "SPARSE", "DENSE"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *FullyConnectedOptionsWeightsFormatTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::FullyConnectedOptionsWeightsFormatTypeTable};
    static const char *const names[]                   = {"DEFAULT", "SHUFFLED4x16INT8"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *LSTMKernelTypeTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::LSTMKernelTypeTypeTable};
    static const char *const names[]                   = {"FULL", "BASIC"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *CombinerTypeTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::CombinerTypeTypeTable};
    static const char *const names[]                   = {"SUM", "MEAN", "SQRTN"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *CustomOptionsFormatTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::CustomOptionsFormatTypeTable};
    static const char *const names[]                   = {"FLEXBUFFERS"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_ENUM, 1, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *QuantizationParametersTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_FLOAT, 1, -1},
                                                       {flatbuffers::ET_FLOAT, 1, -1},
                                                       {flatbuffers::ET_FLOAT, 1, -1},
                                                       {flatbuffers::ET_LONG, 1, -1}};
    static const char *const names[]                = {"min", "max", "scale", "zeroPoint"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *TensorTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {
        {flatbuffers::ET_INT, 1, -1},    {flatbuffers::ET_CHAR, 0, 0},     {flatbuffers::ET_UINT, 0, -1},
        {flatbuffers::ET_STRING, 0, -1}, {flatbuffers::ET_SEQUENCE, 0, 1}, {flatbuffers::ET_BOOL, 0, -1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::TensorTypeTypeTable,
                                                          tflite::QuantizationParametersTypeTable};
    static const char *const names[]       = {"shape", "type", "buffer", "name", "quantization", "is_variable"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *Conv2DOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_INT, 0, -1},
                                                       {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_CHAR, 0, 1},
                                                       {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::PaddingTypeTable,
                                                          tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]                   = {
        "padding", "stride_w", "stride_h", "fused_activation_function", "dilation_w_factor", "dilation_h_factor"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *Pool2DOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_INT, 0, -1},
                                                       {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1},
                                                       {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_CHAR, 0, 1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::PaddingTypeTable,
                                                          tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]                   = {"padding",      "stride_w",      "stride_h",
                                        "filter_width", "filter_height", "fused_activation_function"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *DepthwiseConv2DOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_INT, 0, -1},
                                                       {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1},
                                                       {flatbuffers::ET_CHAR, 0, 1}, {flatbuffers::ET_INT, 0, -1},
                                                       {flatbuffers::ET_INT, 0, -1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::PaddingTypeTable,
                                                          tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]                   = {
        "padding",           "stride_w",         "stride_h", "depth_multiplier", "fused_activation_function",
        "dilation_w_factor", "dilation_h_factor"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *ConcatEmbeddingsOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {
        {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 1, -1}, {flatbuffers::ET_INT, 1, -1}};
    static const char *const names[]       = {"num_channels", "num_columns_per_channel", "embedding_dim_per_channel"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *LSHProjectionOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::LSHProjectionTypeTypeTable};
    static const char *const names[]                   = {"type"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *SVDFOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]                   = {"rank", "fused_activation_function"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *RNNOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]                   = {"fused_activation_function"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *SequenceRNNOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_BOOL, 0, -1}, {flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]                   = {"time_major", "fused_activation_function"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *BidirectionalSequenceRNNOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_BOOL, 0, -1}, {flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]                   = {"time_major", "fused_activation_function"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *FullyConnectedOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable,
                                                          tflite::FullyConnectedOptionsWeightsFormatTypeTable};
    static const char *const names[]                   = {"fused_activation_function", "weights_format"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *SoftmaxOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_FLOAT, 0, -1}};
    static const char *const names[]                = {"beta"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *ConcatenationOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]                   = {"axis", "fused_activation_function"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *AddOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]                   = {"fused_activation_function"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *MulOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]                   = {"fused_activation_function"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *L2NormOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]                   = {"fused_activation_function"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *LocalResponseNormalizationOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 0, -1},
                                                       {flatbuffers::ET_FLOAT, 0, -1},
                                                       {flatbuffers::ET_FLOAT, 0, -1},
                                                       {flatbuffers::ET_FLOAT, 0, -1}};
    static const char *const names[]                = {"radius", "bias", "alpha", "beta"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *LSTMOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0},
                                                       {flatbuffers::ET_FLOAT, 0, -1},
                                                       {flatbuffers::ET_FLOAT, 0, -1},
                                                       {flatbuffers::ET_CHAR, 0, 1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable,
                                                          tflite::LSTMKernelTypeTypeTable};
    static const char *const names[]       = {"fused_activation_function", "cell_clip", "proj_clip", "kernel_type"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *ResizeBilinearOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {
        {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_BOOL, 0, -1}};
    static const char *const names[]       = {"new_height", "new_width", "alignCorners"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *CallOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_UINT, 0, -1}};
    static const char *const names[]                = {"subgraph"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *PadOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *PadV2OptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *ReshapeOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 1, -1}};
    static const char *const names[]                = {"new_shape"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *SpaceToBatchNDOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *BatchToSpaceNDOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *SkipGramOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {
        {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_BOOL, 0, -1}};
    static const char *const names[]       = {"ngram_size", "max_skip_size", "include_all_ngrams"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *SpaceToDepthOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 0, -1}};
    static const char *const names[]                = {"block_size"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *SubOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]                   = {"fused_activation_function"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *DivOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::ActivationFunctionTypeTypeTable};
    static const char *const names[]                   = {"fused_activation_function"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *TopKV2OptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *EmbeddingLookupSparseOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::CombinerTypeTypeTable};
    static const char *const names[]                   = {"combiner"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *GatherOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 0, -1}};
    static const char *const names[]                = {"axis"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *TransposeOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *ExpOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *ReducerOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_BOOL, 0, -1}};
    static const char *const names[]                = {"keepDims"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *SqueezeOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 1, -1}};
    static const char *const names[]                = {"squeezeDims"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *SplitOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 0, -1}};
    static const char *const names[]                = {"num_splits"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *StridedSliceOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 0, -1},
                                                       {flatbuffers::ET_INT, 0, -1},
                                                       {flatbuffers::ET_INT, 0, -1},
                                                       {flatbuffers::ET_INT, 0, -1},
                                                       {flatbuffers::ET_INT, 0, -1}};
    static const char *const names[]       = {"beginMask", "endMask", "ellipsisMask", "newAxisMask", "shrinkAxisMask"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *LogSoftmaxOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *CastOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::TensorTypeTypeTable};
    static const char *const names[]                   = {"in_data_type", "out_data_type"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *DequantizeOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *MaximumMinimumOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *TileOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *ArgMaxOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::TensorTypeTypeTable};
    static const char *const names[]                   = {"output_type"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *ArgMinOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::TensorTypeTypeTable};
    static const char *const names[]                   = {"output_type"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *GreaterOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *GreaterEqualOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *LessOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *LessEqualOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *NegOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *SelectOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *SliceOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *TransposeConvOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::PaddingTypeTable};
    static const char *const names[]                   = {"padding", "stride_w", "stride_h"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *ExpandDimsOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *SparseToDenseOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_BOOL, 0, -1}};
    static const char *const names[]                = {"validateIndices"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *EqualOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *NotEqualOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *ShapeOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_CHAR, 0, 0}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::TensorTypeTypeTable};
    static const char *const names[]                   = {"out_type"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *PowOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *FakeQuantOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_FLOAT, 0, -1},
                                                       {flatbuffers::ET_FLOAT, 0, -1},
                                                       {flatbuffers::ET_INT, 0, -1},
                                                       {flatbuffers::ET_BOOL, 0, -1}};
    static const char *const names[]                = {"min", "max", "num_bits", "narrow_range"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *PackOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1}};
    static const char *const names[]                = {"values_count", "axis"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *LogicalOrOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *OneHotOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 0, -1}};
    static const char *const names[]                = {"axis"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *LogicalAndOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *LogicalNotOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *UnpackOptionsTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1}};
    static const char *const names[]                = {"num", "axis"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *FloorDivOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *SquareOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *ZerosLikeOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *FillOptionsTypeTable() {
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
    return &tt;
}

inline const flatbuffers::TypeTable *OperatorCodeTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {
        {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_STRING, 0, -1}, {flatbuffers::ET_INT, 0, -1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::BuiltinOperatorTypeTable};
    static const char *const names[]                   = {"builtin_code", "custom_code", "version"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *OperatorTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_UINT, 0, -1},    {flatbuffers::ET_INT, 1, -1},
                                                       {flatbuffers::ET_INT, 1, -1},     {flatbuffers::ET_UTYPE, 0, 0},
                                                       {flatbuffers::ET_SEQUENCE, 0, 0}, {flatbuffers::ET_UCHAR, 1, -1},
                                                       {flatbuffers::ET_CHAR, 0, 1},     {flatbuffers::ET_BOOL, 1, -1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::BuiltinOptionsTypeTable,
                                                          tflite::CustomOptionsFormatTypeTable};
    static const char *const names[]                   = {"opcode_index",
                                        "inputs",
                                        "outputs",
                                        "builtin_options_type",
                                        "builtin_options",
                                        "custom_options",
                                        "custom_options_format",
                                        "mutating_variable_inputs"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *SubGraphTypeTable() {
    static const flatbuffers::TypeCode type_codes[]    = {{flatbuffers::ET_SEQUENCE, 1, 0},
                                                       {flatbuffers::ET_INT, 1, -1},
                                                       {flatbuffers::ET_INT, 1, -1},
                                                       {flatbuffers::ET_SEQUENCE, 1, 1},
                                                       {flatbuffers::ET_STRING, 0, -1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::TensorTypeTable, tflite::OperatorTypeTable};
    static const char *const names[]                   = {"tensors", "inputs", "outputs", "operators", "name"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *BufferTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {{flatbuffers::ET_UCHAR, 1, -1}};
    static const char *const names[]                = {"data"};
    static const flatbuffers::TypeTable tt          = {flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
    return &tt;
}

inline const flatbuffers::TypeTable *ModelTypeTable() {
    static const flatbuffers::TypeCode type_codes[] = {
        {flatbuffers::ET_UINT, 0, -1},   {flatbuffers::ET_SEQUENCE, 1, 0}, {flatbuffers::ET_SEQUENCE, 1, 1},
        {flatbuffers::ET_STRING, 0, -1}, {flatbuffers::ET_SEQUENCE, 1, 2}, {flatbuffers::ET_INT, 1, -1}};
    static const flatbuffers::TypeFunction type_refs[] = {tflite::OperatorCodeTypeTable, tflite::SubGraphTypeTable,
                                                          tflite::BufferTypeTable};
    static const char *const names[]                   = {"version",     "operator_codes", "subgraphs",
                                        "description", "buffers",        "metadata_buffer"};
    static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names};
    return &tt;
}

inline const tflite::Model *GetModel(const void *buf) {
    return flatbuffers::GetRoot<tflite::Model>(buf);
}

inline const tflite::Model *GetSizePrefixedModel(const void *buf) {
    return flatbuffers::GetSizePrefixedRoot<tflite::Model>(buf);
}

inline const char *ModelIdentifier() {
    return "TFL3";
}

inline bool ModelBufferHasIdentifier(const void *buf) {
    return flatbuffers::BufferHasIdentifier(buf, ModelIdentifier());
}

inline bool VerifyModelBuffer(flatbuffers::Verifier &verifier) {
    return verifier.VerifyBuffer<tflite::Model>(ModelIdentifier());
}

inline bool VerifySizePrefixedModelBuffer(flatbuffers::Verifier &verifier) {
    return verifier.VerifySizePrefixedBuffer<tflite::Model>(ModelIdentifier());
}

inline const char *ModelExtension() {
    return "tflite";
}

inline void FinishModelBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<tflite::Model> root) {
    fbb.Finish(root, ModelIdentifier());
}

inline void FinishSizePrefixedModelBuffer(flatbuffers::FlatBufferBuilder &fbb,
                                          flatbuffers::Offset<tflite::Model> root) {
    fbb.FinishSizePrefixed(root, ModelIdentifier());
}

inline std::unique_ptr<tflite::ModelT> UnPackModel(const void *buf,
                                                   const flatbuffers::resolver_function_t *res = nullptr) {
    return std::unique_ptr<tflite::ModelT>(GetModel(buf)->UnPack(res));
}

inline std::unique_ptr<tflite::ModelT> UnPackSizePrefixedModel(const void *buf,
                                                               const flatbuffers::resolver_function_t *res = nullptr) {
    return std::unique_ptr<tflite::ModelT>(GetSizePrefixedModel(buf)->UnPack(res));
}

}  // namespace tflite

#endif  // FLATBUFFERS_GENERATED_SCHEMA_TFLITE_H_
